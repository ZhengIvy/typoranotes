1. 考虑边界情况
2. 初始化参数

## 琐碎笔记

### 1. 哈希表

1. 表示哈希函数可以有 直接定址法、除留余数法、平方取中法，其中平方取中法有意思哈，取中间的几位，应该是从后面往前数的几位

   ```c
   int hash_3(int key){
       long temp;
       temp = key*key / 100;
       if(temp >1000){
           temp -= temp/1000 * 1000;//就有一点tricky把
       }
       return templ
   }
   ```

2. 处理冲突的方法是链地址法和开放定址法，前者就是链表，后者就是数组,开放定址法就又有线性探测和二次探测，二次探测的话不是线性的，而是以一个规定好的数据进行探测当发生冲突的时候，1，-1,4，-4这种的

3. 哈希表实现线性探测法解决冲突的要注意的点蛮多的 

   - 要考虑到删除的情况，所以Insert那里就得注意，判断该空是否被删除
   - 要考虑到表满的情况，不可以一直循环的，所以search和insert那里需要注意
   - 哈希表没有重复的值，所以insert，delete前都要查找一遍值才行；
   - 记得初始化哈



### 2. 广义表

1. 表头可以是表也可以是原子。表尾是剩下来的东西哦，很多诶， a1,a2,a3等a1是表头，那a2,a3就是表尾，所以表尾必定是一个广义表
2. 空表的深度为1，长度为0
3. 表尾是表！！！，所以要用括号括起来
4. 广义表的深度可以数括号来看



### 3. 二叉树

1. 结点的层次从根节点开始定义，根为第一层，根的孩子为第二层；深度就是最大层次
2. 二叉排序树这里的删除 当有两个节点的时候没有用递归噢，其实是可以不用的，就分两种情况就可以了，然后主要是要拿到父节点
3. AVL树 LL的话就右转，一步就好了，RR就左转，一步也ok，接着呢，LR,RL可以一步转，但是呢，书上感觉要分开来，那就要从下面先开始反着来就对了哈
4. 这里的并查集是比较简单的，一个点只和一个点之间有连线，所以是不考虑到图的那种情况的
5. 从度数来看 度数为0的个数 = 度数为2个数 +1 有某种关系的哈

### 4. 图

1. 有向边称为弧
2. 度 = 出度 + 入度，树叶有度，树的度是结点的个数哈
3. 包含所有可能的边的图称为 **完全图**，无向完全图包含 n(n-1)/2条边，有向完全图包含n(n-1)条弧，yes，没错哈
4. 带权的图称为网
5. 路径就是从某点可以到某点的路，懂把，如果某个顶点通过某路径可以回到自己，则称有回路
6. 若图中任意两个顶点都是连通的，则称该图为连通图，但通常把，是不可能的，所以我们就有了连通分量，极大连通子图，就是可以连通起来的都拿出来，这个极大是指的是连通的最大程度哈，而不是挑众多子图中最大的一个
7. 简单路径有一个顶点都不相同





终于知道平均查找长度啥意思了，意思就是你每个元素都试一遍，你要查找多少次然后除以个数就好了。