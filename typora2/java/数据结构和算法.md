# e1. 线性结构和非线性结构

看来我以前都不知道这是啥 的

## 线性结构

顺序存储结构和链式存储结构，这个就很通俗易懂不说了

```
1．集合中必存在唯一的一个"第一个元素"；
2．集合中必存在唯一的一个"最后的元素"；
3．除最后元素之外，其它数据元素均有唯一的"后继"；
4．除第一元素之外，其它数据元素均有唯一的"前驱"。
数据结构中线性结构指的是数据元素之间存在着“一对一”的线性关系的数据结构。
如（a0,a1,a2,.....,an）,a0为第一个元素，an为最后一个元素，此集合即为一个线性结构的集合。
相对应于线性结构，非线性结构的逻辑特征是一个结点元素可能对应多个直接前驱和多个后继。
```

的确哈，数组和链表都有一个前驱和一个后继，但非线性表就不是了哈



## 非线性结构

二维数组，多维数组，广义表，树(二叉树等)

没啥好说就这样子吧

# 2.稀疏数组和队列

## 应用场景

下棋的时候基本上都是空盘，要存储数据的时候太浪费空间了就用到了稀疏的表

![image-20201120172949974](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201120172949974.png)

当一个数组中大部分元素为0，或者为同一个值的数组时，可以使用稀疏数组来存储该数组

稀疏数组的处理方法是：

1. 记录数组一共有几行几列，有多少个不同的值
2. 把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模

![image-20201120192014775](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201120192014775.png)

![image-20201120193715161](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201120193715161.png)

还有存到磁盘的操作，真是不可思议 啊

## 代码实现

```java
package com.atguigu.sparsearray;
public class SparseArray {
    public static void main(String[] args) {
        //创建一个原始的二维数组11*11
        //0: 表示没有棋子， 1表示黑子 2 表示蓝子
        int chessArr1[][] = new int[11][11];
        chessArr1[1][2] = 1;
        chessArr1[2][3] = 2;
        //输出原始的二维数组
        for (int[] row: chessArr1
             ) {
            for (int data: row
                 ) {
                System.out.print("\t"+data);
            }
            System.out.println();
        }

        //将二维数组 转 稀疏数组
        //1.先遍历二维数组得到非零数据的个数
        int sum = 0;
        for (int i = 0; i < chessArr1.length; i++) {
            for (int j = 0; j < chessArr1[0].length; j++) {
                if(chessArr1[i][j] != 0){
                    sum++;
                }
            }
        }
       // System.out.println("sum=" + sum);
        //2.创建对应的稀疏数组
        int[][] sparseArr = new int[sum + 1][3];
        //给稀疏数组赋值
        sparseArr[0][0] = 11;
        sparseArr[0][1] = 11;
        sparseArr[0][2] = sum;

        //遍历二维数组，将非0的值存放到sparseArr中
        //count用来记录是第几个非0数据
        int count = 0;
        for (int i = 0; i < chessArr1.length; i++) {
            for (int j = 0; j < chessArr1[0].length; j++) {
                if(chessArr1[i][j] != 0){
                    count++;
                    sparseArr[count][0] = i;
                    sparseArr[count][1] = j;
                    sparseArr[count][2] = chessArr1[i][j];
                }
            }
        }
        //输出稀疏数组的形式
        System.out.println();
        System.out.println("得到的稀疏数组为~~~");
        for (int i = 0; i < sparseArr.length; i++) {
            System.out.print(sparseArr[i][0] + "\t" + sparseArr[i][1] + "\t" + sparseArr[i][2]);
            System.out.println();
        }
        System.out.println();
        //将稀疏数组 --> 恢复成二维数组
        //先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组
        int[][] chessArr2 = new int[sparseArr[0][0]][sparseArr[0][1]];
        //2. 在读取稀疏数组后几行的数组(从第二行开始),并赋值原始的二维数组即可
        for (int i = 1; i <sparseArr.length ; i++) {
            chessArr2[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2];
        }
        //输出恢复后的二维数组
        System.out.println();
        System.out.println("恢复后的二维数组");

        for (int[] row: chessArr2
        ) {
            for (int data: row
            ) {
                System.out.print("\t"+data);
            }
            System.out.println();
        }
    }
}
```

-------------------------------------anki 到这里 11.25---------------------------------------------------

## 课后作业

课后练习
要求：
在前面的基础上，将稀疏数组保存到磁盘上，比如 map.data
恢复原来的数组时，读取map.data 进行恢复

是要用到io的，然后转换流的话学到了点新的东西，不错，很有意思哈，本来打算用对象流的，但是呢二维数组不好转成json数组吧

### 解法1：使用转换流+普通的FileInputStream 和 FileOutputStream

这种比较好的就是你点开文件就能直接看，因为进行编码了

```java
public class SparseArray2 {

    public static void main(String[] args) throws Exception {
        // 先创建一个原始的二维数组 11 * 11
        // 0: 表示没有棋子,1: 表示黑子 2: 表示白字
        int chessArr1[][] = new int[11][11];
        chessArr1[1][2] = 1;
        chessArr1[2][3] = 2;
        // 输出原始的二维数组
        System.out.println("原始的二维数组~~");
        for (int[] row : chessArr1) {
            for (int data : row) {
                System.out.printf("%d\t", data);
            }
            System.out.println();
        }

        // 将二维数组 转 稀疏数组
        // 1. 先遍历二维数组 得到非0数据的个数
        int sum = 0;
        for (int i = 0; i < 11; i++) {
            for (int j = 0; j < 11; j++) {
                if (chessArr1[i][j] != 0) {
                    sum++;
                }
            }
        }

        System.out.println("sum=" + sum);

        // 2.创建对应的稀疏数组
        int sparseArr[][] = new int[sum + 1][3];
        // 给稀疏数组赋值 初始化
        sparseArr[0][0] = 11;
        sparseArr[0][1] = 11;
        sparseArr[0][2] = sum;

        // 遍历二维数组,将非0的值存放到 sparseArr中
        int count = 0;// 用于记录是第几个非0的数据
        for (int i = 0; i < 11; i++) {
            for (int j = 0; j < 11; j++) {
                if (chessArr1[i][j] != 0) {
                    count++;
                    sparseArr[count][0] = i;
                    sparseArr[count][1] = j;
                    sparseArr[count][2] = chessArr1[i][j];
                }
            }
        }
        // 保存稀疏数组
        File file = new File("D:\\maven\\datastructure-atguigu\\DataStructure\\map.data");
        FileOutputStream fos = new FileOutputStream(file);

        OutputStreamWriter write = new OutputStreamWriter(fos, "UTF-8");
        // 输出稀疏数组的形式
        System.out.println();
        System.out.println("得到的稀疏数组为~~~");
        for (int i = 0; i < sparseArr.length; i++) {
            System.out.printf("%d\t%d\t%d\t\n", sparseArr[i][0], sparseArr[i][1], sparseArr[i][2]);

            if (i == sparseArr.length - 1) {
                write.append(sparseArr[i][0] + "," + sparseArr[i][1] + "," + sparseArr[i][2]);
            } else {
                write.append(sparseArr[i][0] + "," + sparseArr[i][1] + "," + sparseArr[i][2] + ",");
            }
        }

        System.out.println("写入文件中...");
        write.close();
        fos.close();

        System.out.println("打开文件中...");
        Desktop.getDesktop().open(file);

        System.out.println("------------------------------先读取_map.data");
        // 创建 FileReader 对象
        FileInputStream fis = new FileInputStream(file);

        InputStreamReader reader = new InputStreamReader(fis, "UTF-8");
        StringBuffer sb = new StringBuffer();
        while (reader.ready()) {
            sb.append((char) reader.read());// 转成char加到StringBuffer对象中
        }

        System.out.println(sb.toString());
        reader.close();// 关闭读取流
        fis.close();// 关闭输入流,释放系统资源

        System.out.println("------------------------------恢复成稀疏数组_sparseArrHf");
        // 2.创建对应的稀疏数组
        String[] str = sb.toString().split(",");
        int sparseArrHf[][] = new int[str.length / 3][3];
        // 给稀疏数组赋值
        int i = 0;
        for (String s : str) {
            sparseArrHf[(i - (i % 3)) / 3][i % 3] = Integer.parseInt(s);
            i++;
        }

        System.out.println("------------------------------再恢复成二维数组_chessArr22");
        // 将稀疏数组 -->恢复成 原始的二维数组
        /*
         * 1. 读取稀疏数组的第一行,根据第一行的数据,创建原始的二维数组,比如上面的 chessArr2 = int[11][11];
         *
         * 2. 在读取稀疏数组后几行的数据,并赋给 原始的二维数组 即可.
         */

        // 1. 读取稀疏数组的第一行,根据第一行的数据,创建原始的二维数组
        int chessArr22[][] = new int[sparseArrHf[0][0]][sparseArrHf[0][1]];

        // 2. 在读取稀疏数组后几行的数据,并赋给 原始的二维数组 即可.
        for (int i3 = 1; i3 < sparseArrHf.length; i3++) {
            chessArr22[sparseArrHf[i3][0]][sparseArrHf[i3][1]] = sparseArrHf[i3][2];
        }

        // 输出恢复的二维数组
        System.out.println();
        for (int[] row : chessArr22) {
            for (int data : row) {
                System.out.printf("%d\t", data);
            }
            System.out.println();
        }

        System.out.println("--------------------------------------------------------恢复完成");

        // 将稀疏数组 -->恢复成 原始的二维数组
        /*
         * 1. 读取稀疏数组的第一行,根据第一行的数据,创建原始的二维数组,比如上面的 chessArr2 = int[11][11];
         *
         * 2. 在读取稀疏数组后几行的数据,并赋给 原始的二维数组 即可.
         */

        // 1. 读取稀疏数组的第一行,根据第一行的数据,创建原始的二维数组
        int chessArr2[][] = new int[sparseArr[0][0]][sparseArr[0][1]];

        // 2. 在读取稀疏数组后几行的数据,并赋给 原始的二维数组 即可.
        for (int i3 = 1; i3 < sparseArr.length; i3++) {
            chessArr2[sparseArr[i3][0]][sparseArr[i3][1]] = sparseArr[i3][2];
        }

        // 输出恢复后的二维数组
        System.out.println();
        System.out.println("恢复后的二维数组");
        for (int[] row : chessArr2) {
            for (int data : row) {
                System.out.printf("%d\t", data);
            }
            System.out.println();
        }
    }
}
```



### 解法2： 使用对象流，直接把对象转为json中保存

优点是你不用拿一个String数组去搞来搞去 的，缺点就是你点开文件的时候你看不清楚，因为没有编码

```java
package com.atguigu.sparsearray;
import java.io.*;
import java.util.Arrays;
public class SparseArray3 {
    public static void main(String[] args) throws Exception{
        //创建一个原始的二维数组11*11
        //0: 表示没有棋子， 1表示黑子 2 表示蓝子
        int chessArr1[][] = new int[11][11];
        chessArr1[1][2] = 1;
        chessArr1[2][3] = 2;
        //输出原始的二维数组
        for (int[] row: chessArr1
        ) {
            for (int data: row
            ) {
                System.out.print("\t"+data);
            }
            System.out.println();
        }

        //将二维数组 转 稀疏数组
        //1.先遍历二维数组得到非零数据的个数
        int sum = 0;
        for (int i = 0; i < chessArr1.length; i++) {
            for (int j = 0; j < chessArr1[0].length; j++) {
                if(chessArr1[i][j] != 0){
                    sum++;
                }
            }
        }
        // System.out.println("sum=" + sum);
        //2.创建对应的稀疏数组
        int[][] sparseArr = new int[sum + 1][3];
        //给稀疏数组赋值
        sparseArr[0][0] = 11;
        sparseArr[0][1] = 11;
        sparseArr[0][2] = sum;

        //遍历二维数组，将非0的值存放到sparseArr中
        //count用来记录是第几个非0数据
        int count = 0;
        for (int i = 0; i < chessArr1.length; i++) {
            for (int j = 0; j < chessArr1[0].length; j++) {
                if(chessArr1[i][j] != 0){
                    count++;
                    sparseArr[count][0] = i;
                    sparseArr[count][1] = j;
                    sparseArr[count][2] = chessArr1[i][j];
                }
            }
        }
        File file = new File("D:\\maven\\datastructure-atguigu\\DataStructure\\map.data");
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(file));
        oos.writeObject(sparseArr);
        oos.flush();
        //输出稀疏数组的形式
        System.out.println();
        System.out.println("得到的稀疏数组为~~~");
        for (int i = 0; i < sparseArr.length; i++) {
            System.out.print(sparseArr[i][0] + "\t" + sparseArr[i][1] + "\t" + sparseArr[i][2]);
            System.out.println();
        }
        System.out.println();

        //从文件中读取对象,直接成功哈哈
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(file));
        Object object = ois.readObject();
        int sparseArrHf[][] = (int[][]) object;


        //将稀疏数组 --> 恢复成二维数组
        //先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组

        int[][] chessArr2 = new int[sparseArr[0][0]][sparseArr[0][1]];

        //2. 在读取稀疏数组后几行的数组(从第二行开始),并赋值原始的二维数组即可

        for (int i = 1; i <sparseArr.length ; i++) {
            chessArr2[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2];
        }
        //输出恢复后的二维数组
        System.out.println();
        System.out.println("恢复后的二维数组");

        for (int[] row: chessArr2
        ) {
            for (int data: row
            ) {
                System.out.print("\t"+data);
            }
            System.out.println();
        }
    }
}
```

# 3. 队列

1. 队列是一个有序列表，可以用 **数组**或是 **链表**实现
2. 遵循先入先出原则，即：先存入队列的数据，要先取出，后存入的要后取出
3. 以下front和rear其实可以有多种表达方法，下面front表示的是实际front的前一个，rear就是真的rear，两个都从-1开始，

## 数组实现

```java
package com.atguigu.queue;
import.java.util.Scanner;
public class ArrayQueueDemo {
    public static void main(String[] args) {
        //测试
        //创建一个队列
        ArrayQueue arrayQueue = new ArrayQueue(3);
        char key = ' ';
        Scanner scanner = new Scanner(System.in);
        boolean loop = true;
        //输出一个菜单
        while (loop){
            System.out.println("s(show):显示队列");
            System.out.println("e(exit):退出程序");
            System.out.println("a(add):添加数据到队列");
            System.out.println("g(get):从队列取出数据");
            System.out.println("h(head):查看队列头的数据");
            //接受一个字符
            key = scanner.next().charAt(0);
            switch (key){
                case 's':
                    arrayQueue.showQueue();
                    break;
                case 'a':
                    System.out.println("输出一个数");
                    int value = scanner.nextInt();
                    arrayQueue.addQueue(value);
                    break;
                case 'g':
                    try{
                        int res = arrayQueue.getQueue();
                        System.out.printf("取出数据是%d\n",res);
                    }catch (Exception e){
                        System.out.println(e.getMessage());
                    }
                    break;
                    //查看队列头数据
                case 'h':
                    try{
                        int res = arrayQueue.peek();
                        System.out.printf("队列头的数据是%d\n",res);
                    }catch (Exception e){
                        System.out.println(e.getMessage());
                    }
                    break;
                    //退出
                case 'e':
                    scanner.close();
                    loop = false;
                    break;
                default:
                    break;
            }
        }
        System.out.println("程序退出");
    }
}

//使用数组模拟队列编写一个ArrayQueue类
class ArrayQueue{
    //表示数组的最大容量
    private int maxSize;
    //队列头
    private int front;
    //队列尾
    private int rear;
    //该数据用于存放数据，模拟队列
    private int[] arr;

    //创建队列的构造器
    public ArrayQueue(int arrMaxSize){
        maxSize = arrMaxSize;
        arr = new int[maxSize];
        //指向队列头部，分析出front是指向队列头的前一个位置
        front = -1;
        //指向队列尾，指向队列尾的数据(即就是队列最后一个数据)
        rear = -1;
    }

    //判断队列是否满
    public boolean isFull(){
        return rear == maxSize - 1;
    }

    //判断队列是否为空
    public boolean isEmpty(){
        return rear == front;
    }

    //添加数据到队列
    public void addQueue(int n){
        //判断队列是否满
        if(isFull()){
            System.out.println("队列满，不能加入数据");
            return;
        }
        rear++;//让rear后移
        arr[rear] = n;

    }

    //获取队列的数据，出队列
    public int getQueue(){
        //判断队列是否为空
        if(isEmpty()){
            //通过抛出异常
            throw new RuntimeException("队列空，不能数据");
        }
        //front后移
        front++;
        return arr[front];
    }

    //显示队列的所有数据
    public void showQueue(){
        //遍历
        if(isEmpty()){
            System.out.println("队列空的，没有数据");
            return;
        }
        for (int i = 0; i < arr.length; i++) {
            System.out.printf("arr[%d]=%d\n",i,arr[i]);
        }
    }
    //显示队列的头数据，注意不是取出数据
    public int peek(){
        //判断
        if(isEmpty()){
            throw new RuntimeException("队列空的,没有数据");
        }
        return arr[front+1];
    }
}
```

这个有个点是你的只能使用一次，因为的判断队列满的方式是你的rear到maxSize-1，那很快就用完了，所以我们 需要环形队列，哇，原来这就是我们为啥要环形队列的原因啊



## 环形队列

这时候有些东西有点不一样了，front和rear代表的含义，这时候front意思就是最前面的位置，rear代表的是最后一个位置的下一个位置

![image-20201122101207465](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201122101207465.png)

而且还会预留一个空间出来，但目前不知道是干嘛的，所以总的size就只有maxSize-1，要好好理解一下队列满和求有效数据的个数的条件哈，有效的数据个数的话是包括最后一个预留空间的maxSize-1,而且的话记住取模是为了搞定负数。

**最重要的是理解有效个数和判满和预留空间**，这几个弄懂了就问题不大了

知道预留空间是干嘛的了，**为了判空和判满的时候分出区别**，判空的时候是 `rear == front`,但是判满的话如果不预留的话那也是这样判断，也就是说**满的时候rear和front之间会预留一个位置出来，不是固定的，是会变化的，看情况反正**。所以就解释得通剩下的了，rear 的话就只是单纯加1，所以就有可能加到预留的位置上去，但是问题不大，只是我之前理解错了，以为会跳到下个位置去，所以求有效个数的也说得通了哈，判断是否满也说得通了。

不过我刚刚是又在想一个东西，为什么最开始的时候front=0，而不是-1，但是为了保证rear == front是空的，这种情况就有点特殊了，而且getQueue会被规避掉的，会先判断是否为空，所以问题不大。

```java
//使用数组模拟队列编写一个ArrayQueue类
class CircleArray{
    //表示数组的最大容量
    private int maxSize;
    //front 的变量含义做一个调整，front就指向队列的第一个元素，也就是说arr[front]
    //front的初始值=0
    private int front;
    //rear 的变量的含义做一个调整：rear指向队列的最后一个元素的后一个位置，因为希望空出一个约束的位置
    //rear的初始值为0
    private int rear;
    //该数据用于存放数据，模拟队列
    private int[] arr;

    //创建队列的构造器
    public CircleArray(int arrMaxSize){
        maxSize = arrMaxSize;
        arr = new int[maxSize];
    }

    //判断队列是否满
    public boolean isFull(){
        return (rear + 1) % maxSize == front;
    }

    //判断队列是否为空
    public boolean isEmpty(){
        return rear == front;
    }

    //添加数据到队列
    public void addQueue(int n){
        //判断队列是否满
        if(isFull()){
            System.out.println("队列满，不能加入数据");
            return;
        }
        //直接将数据加入
        arr[rear] = n;
        //将rear后移，这里必须考虑取模
        rear = (rear + 1) % maxSize;
    }

    //获取队列的数据，出队列
    public int getQueue(){
        //判断队列是否为空
        if(isEmpty()){
            //通过抛出异常
            throw new RuntimeException("队列空，不能数据");
        }
       //front 这里需要分析 出front是指向队列的第一个元素
        //1.先把front对应的值保存到一个临时的变量
        //2.front后移
        //3.将临时保存的变量返回
        int value = arr[front];
        front = (front + 1) % maxSize;
        return value;
    }

    //显示队列的所有数据
    public void showQueue(){
        //遍历
        if(isEmpty()){
            System.out.println("队列空的，没有数据");
            return;
        }
        //思路：从front开始遍历，遍历多少个元素
        //动脑筋
        for (int i = front; i < front + size(); i++) {
            System.out.printf("arr[%d]=%d\n",i % maxSize,arr[i % maxSize]);
        }
    }
    //求出当前队列有效数据的个数
    public int size(){
        return (rear + maxSize -front) % maxSize;
    }
    //显示队列的头数据，注意不是取出数据
    public int peek(){
        //判断
        if(isEmpty()){
            throw new RuntimeException("队列空的,没有数据");
        }
        return arr[front];
    }
}
```

# 4. 链表

![image-20201122121758316](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201122121758316.png)

这个带头结点和不带头结点的我是做了anyview才知道的，诶，所以的话还是学国内的教程可以学到不一样的东西，知识比较全面

![image-20201123152634424](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201123152634424.png)

## 普通的增删查改的操作



## 按顺序插入，有点数组的感觉

![image-20201123160516531](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201123160516531.png)

## 完整代码

看老师的代码的话觉得 写的比较好，低耦合，对应的功能是分开的，也不会合在一起，就觉得很棒,然后代码的逻辑其实不是很难

有增删改，查的话蛮简单，还有一个按顺序增

```java
package com.atguigu.linkedlist;
public class SingleLinkedListDemo {
    public static void main(String[] args) {
        //进行测试
        //先创建结点
        HeroNode hero1 = new HeroNode(1, "宋江", "及时雨");
        HeroNode hero2 = new HeroNode(2,"卢俊义","玉麒麟");
        HeroNode hero3 = new HeroNode(3,"吴用","智多星");
        HeroNode hero4 = new HeroNode(4,"林冲","豹子头");

        //创建新的链表
        SingleLinkedList singleLinkedList = new SingleLinkedList();
        //加入
//        singleLinkedList.add(hero1);
//        singleLinkedList.add(hero2);
//        singleLinkedList.add(hero3);
//        singleLinkedList.add(hero4);

        //加入按照编号的顺序
        singleLinkedList.addByOrder(hero1);
        singleLinkedList.addByOrder(hero4);
        singleLinkedList.addByOrder(hero2);
        singleLinkedList.addByOrder(hero3);
        //显示一把
        singleLinkedList.list();

        //测试修改结点的代码
        HeroNode newHeroNode = new HeroNode(2,"小卢","玉麒麟!!");
        singleLinkedList.update(newHeroNode);

        System.out.println("修改后的链表情况");
        singleLinkedList.list();

        //删除一个结点
        singleLinkedList.del(1);
        System.out.println("删除后链表情况");
        singleLinkedList.list();
    }
}
//定义 SingleLinkedList 管理我们的英雄
class SingleLinkedList{
    //先初始化一个头结点，头结点不要动
    private HeroNode head = new HeroNode(0,"","");

    //添加结点到单向链表
    //思路，当不考虑编号顺序时
    //1.找到当前链表的最后结点
    //2.将最后这个结点的next 指向 新的结点
    public void add(HeroNode node){

        //因为head结点不能动，因此我们需要一个辅助结点遍历temp
        HeroNode temp = head;
        //遍历链表，找到最后
        while (true){
            //找到链表的最后
            if(temp.next == null){
                break;
            }
            //如果没有找到最后，就将temp后移
            temp = temp.next;
        }
        //当退出while循环时，temp就指向了链表的最后
        temp.next = node;
    }

    //修改结点的信息，根据no编号来修改，即no编号不能改。
    //说明
    //1.根据newHeroNode 的no 来修改即可
    public void update(HeroNode newHeroNode){
        //判断是否空
        if(head.next == null){
            System.out.println("链表为空");
            return;
        }
        //找到需要修改的节点，根据no编号
        //定义一个辅助变量
        HeroNode temp = head.next;
        //表示是否找到该结点
        boolean flag= false;
        while (true){
            if(temp == null){
                //已经遍历完链表
                break;
            }
            if(temp.no == newHeroNode.no){
                //找到
                flag = true;
                break;
            }
            temp = temp.next;
        }

        //根据flag 判断是否找到要修改的节点
        if(flag){
            temp.name = newHeroNode.name;
            temp.nickname = newHeroNode.nickname;
        }else {
            //没有找到
            System.out.println("没有找到编号"+newHeroNode.no+"不能修改");
        }
    }

    //删除节点
    //思路
    //1. head不能动，因此我们需要一个temp辅助结点找到待删除节点的前一个结点
    //2. 说明我们在比较时，是temp.next.no 和需要删除的节点的no比较
    public void del(int no){
        HeroNode temp = head;
        //标志是否找到待删除节点的
        boolean flag = false;
        while (true){
            if (temp.next == null){
                //已经到链表的最后
                break;
            }
            if(temp.next.no == no){
                //找到待删除节点的前一个节点temp
                flag = true;
                break;
            }
            //temp后移，遍历
            temp  = temp.next;
        }
        //判断flag
        if(flag) {//找到
            //可以删除
            temp.next = temp.next.next;
        }else {
            System.out.println("要删除的"+no+"结点不存在");
        }
    }
    //显示链表,遍历
    public void list(){
        //判断链表是否为空
        if(head.next == null){
            System.out.println("链表为空");
            return;
        }

        //因为头结点，不能动，因此我们需要一个辅助变量来遍历
        HeroNode temp = head.next;
        while (true){
            //判断是否到链表最后
            if(temp == null){
                break;
            }
            //输出结点信息
            System.out.println(temp);
            //将temp后移，一定小心
            temp = temp.next;
        }
    }

    //第二种方式在添加英雄时，根据排名将英雄插入到指定位置
    //(如果有这个排名，则添加失败，并给出提示)
    public void addByOrder(HeroNode heroNode){
        //因为头结点不能动，因此我们仍然通过一个辅助指针(变量)来帮助我们找到添加的位置
        //因为单链表，我们找的temp 是位于添加位置的前一个结点，否则插入不了
        HeroNode temp = head;
        //标志添加的编号是否存在，默认为false
        boolean flag = false;
        while (true){
            if(temp.next == null){
                //说明temp已经在链表的最后
                break;
            }
            if(temp.next.no > heroNode.no){
                //位置找到，就在temp后面插入
                break;
            }else if(temp.next.no == heroNode.no){
                //说明希望添加的heroNode的编号已经存在
                flag = true;
                break;
            }
            temp = temp.next;
        }
        //判断flag 的值
        if(flag){
            //不能添加，说明编号存在
            System.out.println("准备插入的英雄编号"+heroNode.no + "已经存在了，不能加入");
        }else {
            //插入到链表中，temp的后面
            heroNode.next = temp.next;
            temp.next = heroNode;
        }
    }
}
//定义HeroNode，每个HeroNode对象就是一个结点
class HeroNode{
    public int no;
    public String name;
    public String nickname;
    public HeroNode next;

    @Override
    public String toString() {
        return "HeroNode{" +
                "no=" + no +
                ", name='" + name + '\'' +
                ", nickname='" + nickname + '\'' +
                '}';
    }

    public HeroNode(int no, String name, String nickname){
        this.no = no;
        this.name = name;
        this.nickname = nickname;
    }
}
```

## 面试题

### 链表的逆序输出

目前有三种方法，栈、递归、循环遍历

第一种栈是比较好用的，虽然大家都说不要用递归，但是呢，在这种情况下栈也好不到哪去吧？不过好像是好一点，内存还是少点。

```java
//使用方式2，栈
    public static void reversePrint2(HeroNode head){
        if (head.next == null){
            return;
        }
        //创建一个栈，将各个节点压入栈中
        Stack<HeroNode> stack = new Stack<>();
        HeroNode cur = head.next;
        //将链表的所有节点压入栈中
        while (cur != null){
            stack.push(cur);
            cur = cur.next;
        }
        //将栈中的节点进行打印
        while (stack.size() != 0){
            System.out.println(stack.pop());
        }
    }
```



第二种递归的话哇真的内存爆炸的。但是代码非常的简单

```java
 //反向输出链表,使用递归的方式
    public void reversePrint(HeroNode head){
        if(head  == null || "".equals(head.name)){
            return;
        }
        reversePrint(head.next);
        System.out.println(head);

    }
```

-----------------------------------------------anki 11.26--------------------------------------

这个目前不anki，因为leetcode有个很想的题目，做完再说

### 栈的倒数第k个节点

```java
//查找单链表中的倒数第k个结点
    //思路如下:
    //1. 编写一个方法，接受head结点，同时接受一个index
    //2. index表示是倒数第index个结点
    //3. 先把链表从头到尾遍历一下，得到链表的总的长度 getLength
    //4. 得到size后，我们从链表第一个开始遍历，遍历(size - index)个
    //5. 如果找到，返回该结点，找不到就返回空
    public static HeroNode findLastIndexNode(HeroNode head,int index){
        //判断如果链表为空，返回null
        if(head.next == null){
            return null;
        }
        //第一个遍历 得到链表的长度(结点个数)
        int size = getLength(head);
        //第二次遍历 size - index 位置，这就是我们倒数第k个结点
        //先做一个数据的校验
        if(index <= 0 || index > size){
            return null;
        }
        //定义一个辅助变量,for循环定位倒数的index
        HeroNode cur = head.next;
        for(int i = 0; i < size - index;i++){
            cur = cur.next;
        }
        return cur;
    }
```

还有一种思路是设置两个节点，相差为k，就也可以解决哈

## 双向链表

![image-20201125103738538](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201125103738538.png)

### 完整代码

```java
package com.atguigu.linkedlist;

public class DoubleLinkedListDemo {
    public static void main(String[] args) {

        //测试
        System.out.println("双向链表的测试");
        //先创建节点
        HeroNode2 hero1 = new HeroNode2(1, "宋江", "及时雨");
        HeroNode2 hero2 = new HeroNode2(2,"卢俊义","玉麒麟");
        HeroNode2 hero3 = new HeroNode2(3,"吴用","智多星");
        HeroNode2 hero4 = new HeroNode2(4,"林冲","豹子头");
        //创建一个双向链表
        DoubleLinkedList doubleLinkedList = new DoubleLinkedList();
        doubleLinkedList.add(hero1);
        doubleLinkedList.add(hero2);
        doubleLinkedList.add(hero3);
        doubleLinkedList.add(hero4);
        doubleLinkedList.list();

        //修改
        HeroNode2 newHeroNode = new HeroNode2(4,"公孙胜","入云龙");
        doubleLinkedList.update(newHeroNode );
        System.out.println("修改后的链表情况");
        doubleLinkedList.list();

        //删除
        doubleLinkedList.del(3);
        System.out.println("删除后的链表情况~~");
        doubleLinkedList.list();

        System.out.println();
        doubleLinkedList.addByOrder(hero3);
//        HeroNode2 hero5 = new HeroNode2(5,"ww","ww");
        doubleLinkedList.addByOrder(hero2);
        doubleLinkedList.list();
    }
}
//创建一个双向链表的表
class DoubleLinkedList{
    //先初始化一个头节点，头节点不要动，不存放具体的数据
    private HeroNode2 head = new HeroNode2(0,"","");

    //返回头节点
    public HeroNode2 getHead() {
        return head;
    }

    //遍历双向链表
    public void list(){
        //判断链表是否为空
        if(head.next == null){
            System.out.println("链表为空");
            return;
        }

        //因为头结点，不能动，因此我们需要一个辅助变量来遍历
        HeroNode2 temp = head.next;
        while (true){
            //判断是否到链表最后
            if(temp == null){
                break;
            }
            //输出结点信息
            System.out.println(temp);
            //将temp后移，一定小心
            temp = temp.next;
        }
    }

    //添加一个节点到双向链表的最后
    public void add(HeroNode2 node){

        //因为head结点不能动，因此我们需要一个辅助结点遍历temp
        HeroNode2 temp = head;
        //遍历链表，找到最后
        while (true){
            //找到链表的最后
            if(temp.next == null){
                break;
            }
            //如果没有找到最后，就将temp后移
            temp = temp.next;
        }
        //当退出while循环时，temp就指向了链表的最后
        //形成一个双向链表
        temp.next = node;
        node.pre = temp;
    }

    //修改一个节点的内容，可以看到双向链表的节点内容修改和单向链表的一样
    //只是节点类型改成HeroNode2
    public void update(HeroNode2 newHeroNode){
        //判断是否空
        if(head.next == null){
            System.out.println("链表为空");
            return;
        }
        //找到需要修改的节点，根据no编号
        //定义一个辅助变量
        HeroNode2 temp = head.next;
        //表示是否找到该结点
        boolean flag= false;
        while (true){
            if(temp == null){
                //已经遍历完链表
                break;
            }
            if(temp.no == newHeroNode.no){
                //找到
                flag = true;
                break;
            }
            temp = temp.next;
        }

        //根据flag 判断是否找到要修改的节点
        if(flag){
            temp.name = newHeroNode.name;
            temp.nickname = newHeroNode.nickname;
        }else {
            //没有找到
            System.out.println("没有找到编号"+newHeroNode.no+"不能修改");
        }

    }

    //从双向链表中删除一个节点
    //说明
    //1. 对于双向链表，我们可以直接找到要删除的这个节点
    //2. 找到后，自我删除即可
    public void del(int no){
        //判断链表是否为空
        if(head.next == null){
            System.out.println("链表为空，无法删除");
            return;
        }
        HeroNode2 temp = head.next;
        //标志是否找到待删除节点的
        boolean flag = false;
        while (true){
            if (temp == null){
                //已经到链表的最后
                break;
            }
            if(temp.no == no){
                //找到待删除节点的前一个节点temp
                flag = true;
                break;
            }
            //temp后移，遍历
            temp  = temp.next;
        }
        //判断flag
        if(flag) {//找到
            //可以删除
            temp.pre.next = temp.next;
            //这里我们的代码有问题
            //如果是最后一个节点，就不需要执行下面这句话，否则会出现空指针异常
            if(temp.next != null) {
                temp.next.pre = temp.pre;
            }
        }else {
            System.out.println("要删除的"+no+"结点不存在");
        }
    }
    public void addByOrder(HeroNode2 heroNode){
        //因为头结点不能动，因此我们仍然通过一个辅助指针(变量)来帮助我们找到添加的位置
        //因为单链表，我们找的temp 是位于添加位置的前一个结点，否则插入不了
        if(head.next == null){
            System.out.println("链表为空，无法插入");
            return;
        }
        HeroNode2 temp = head.next;
        //标志添加的编号是否存在，默认为false
        boolean flag = false;
        while (true){
            if(temp.next == null){
                //说明temp已经在链表的最后
                break;
            }
            if(temp.next.no > heroNode.no){
                //位置找到，就在temp后面插入
                break;
            }else if(temp.next.no == heroNode.no){
                //说明希望添加的heroNode的编号已经存在
                flag = true;
                break;
            }
            temp = temp.next;
        }
        //判断flag 的值
        if(flag){
            //不能添加，说明编号存在
            System.out.println("准备插入的英雄编号"+heroNode.no + "已经存在了，不能加入");
        }else {
            //插入到链表中，temp的后面
            heroNode.pre = temp;
            heroNode.next = temp.next;
            if( temp.next != null) {
                temp.next.pre = heroNode;
            }
            temp.next = heroNode;
        }
    }
}

//创建一个双向链表的类
class HeroNode2{
    public int no;
    public String name;
    public String nickname;
    public HeroNode2 next;//指向下一个节点，默认为null
    public HeroNode2 pre;//指向前一个节点，默认为null

    @Override
    public String toString() {
        return "HeroNode{" +
                "no=" + no +
                ", name='" + name + '\'' +
                ", nickname='" + nickname + '\'' +
                '}';
    }
    public HeroNode2(int no, String name, String nickname){
        this.no = no;
        this.name = name;
        this.nickname = nickname;
    }
}
```

-------------------------------------------anki 11.27-----------------------------------

## 约瑟夫环

我在youtube上看的就是杀人，就是士兵想留到最后怎么办，每次都会去杀旁边的人，

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201125150036875.png" alt="image-20201125150036875" style="zoom:67%;" />

所以偶数都会被kill掉

新生成的环可以重新index，所以又是偶数的被kill掉，所以是有一定规律的,但是我看的视频和这边的侧重点不是很一样，这个视频的侧重点是巧妙的找出最后一个，不用让你这样遍历的方式，尚硅谷就是教你如何实现这种遍历的方式

### 思路分析

然后他这里是报数。需要用到环形链表

![image-20201125150017439](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201125150017439.png)

不过这个感觉就更加全面一点

### 构建单向的环形链表

![](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201125151927126.png)



### 链表出圈

![](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201126194458333.png)

### 代码实现

```java
package com.atguigu.linkedlist;

public class Josephu {
    public static void main(String[] args) {

        //测试一把看看单向的环形链表和遍历是否ok
        CircleSingleLinkedList circleSingleLinkedList = new CircleSingleLinkedList();
        circleSingleLinkedList.addBoy(5);
        circleSingleLinkedList.showBoy();

        //测试一把小孩出圈是否正确
        circleSingleLinkedList.countBoy(1,2,5);
    }
}
//创建一个环形的单向链表
class CircleSingleLinkedList{
    //创建一个first节点,当前没有编号
    private Boy first = null;
    //添加小孩节点构建成一个环形的链表
    public void addBoy(int nums){
        //nums 做一个数据校验
        if(nums < 1){
            System.out.println("nums的数值不正确");
            return;
        }
        Boy curBoy = null;
        //使用for循环来创建我们的环形链表
        for (int i = 1; i <= nums; i++) {
            //根据编号创建小孩节点
            Boy boy = new Boy(i);
            //如果是第一个小孩
            if(i == 1){
                first = boy;
                first.setNext(first);
                curBoy = first;
            }else{
                curBoy.setNext(boy);
                boy.setNext(first);
                curBoy = boy;
            }   
        }
    }
    //遍历当前的环形链表
    public void showBoy(){
        //判断链表是否为空
        if(first == null){
            System.out.println("没有任何小孩");
            return;
        }
        //first不能动，使用辅助指针
        Boy curBoy = first;
        while (true){
            System.out.println("小孩的编号为"+curBoy.getNo());
            if(curBoy.getNext().equals(first)){
                //说明已经遍历完毕
                break;
            }
            curBoy = curBoy.getNext();//curBoy后移
        }
    }

    /**
     * @param startNo 表示从第几个小孩开始数数
     * @param countNum 表示数几下
     * @param nums 表示最初有多少小孩在圈中
     */
    //根据 用户的输入，计算出小孩出圈的顺序
    public void countBoy(int startNo, int countNum, int nums){
     //先对数据进行校验
        if(first == null || startNo < 1 || startNo > nums){
            System.out.println("参数输入有误，请重新输入");
            return;
        }
        //创建要给的辅助指针，帮助小孩完成出圈
        Boy helper = first;
        //需求创建一个辅助指针helper，事先应该指向环形链表的最后这个节点
        while (true){
            if(helper.getNext() == first){//说明helper指向最后小孩节点
                break;
            }
            helper = helper.getNext();

        }
        //小孩报数前，先让first和helper移动 k-1次
        for (int i = 0; i < startNo - 1 ; i++) {
            first = first.getNext();
            helper = helper.getNext();
            
        }
        //当小孩报数时，让first和helper指针同时移动 m-1次，然后出圈
        //这里是一个循环操作，直到圈中只有一个节点
        while (true){
            if(helper == first){//说明圈中只有一个人
                break;
            }
            //让first和helper指针同时移动 countNum - 1
            for (int i = 0; i < countNum - 1; i++) {
                first = first.getNext();
                helper = helper.getNext();         
            }
            //这时first指向的节点，就是要出圈的小孩节点，感觉有点重复+浪费了
            System.out.println("小孩"+first.getNo()+"出圈");
            //这时将first指向的小孩节点出圈
            first = first.getNext();
            helper.setNext(first);
        }
        System.out.println("最后留在圈中的小孩编号"+first.getNo());
    }
}
//创建Boy，表示一个节点
class Boy{
    private int no;
    private Boy next;

    public Boy(int no) {
        this.no = no;
    }

    public int getNo() {
        return no;
    }

    public void setNo(int no) {
        this.no = no;
    }

    public Boy getNext() {
        return next;
    }

    public void setNext(Boy next) {
        this.next = next;
    }
}
```

怎么说呢，我感觉可以再优化，因为觉得怪怪的，我个人是觉得helper时可以不用的哈。主要时和我理解的那个问题有些不一样，然后这个问题的话时更加高级的，因为youtube上面的话的间距就只是1而已，但是他会侧重对最后一个数的求解吧

# 5.栈

![image-20201126201644014](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201126201644014.png)

怎么说呢，二叉树遍历的时候我用递归比较多，所以的话非递归应该就时用的时栈吧我猜

## 完整代码

```java
package com.atguigu.stack;
import java.util.Scanner;

public class ArrayStackDemo {
    public static void main(String[] args) {

        //测试一下ArrayStack是否正确
        //先创建一个ArrayStack对象表示栈
        ArrayStack stack = new ArrayStack(4);
        String key = "";
        boolean loop = true;
        Scanner scanner = new Scanner(System.in);

        while (loop){
            System.out.println("show:表示显示栈");
            System.out.println("exit:退出栈");
            System.out.println("push:表示添加数据到栈(入栈)");
            System.out.println("pop:表示从栈取出数据(出栈)");
            System.out.println("请输入你的选择");
            key = scanner.next();
            switch (key){
                case "show":
                    stack.list();
                    break;
                case "push":
                    System.out.println("请输入一个数");
                    int value = scanner.nextInt();
                    stack.push(value);
                    break;
                case "pop":
                    try{
                        int result = stack.pop();
                        System.out.println("出栈的数据是" + result);

                    }catch (Exception e){
                        System.out.println(e.getMessage());
                    }
                    break;
                case "exit":
                    //资源的关闭，话说以前我还从来没这么做过噢
                    scanner.close();
                    loop = false;
                    break;
            }
        }
        System.out.println("程序退出拉");

//        stack.pop();
    }
}
//定义一个 ArrayStack 表示栈
class ArrayStack{
    private int maxSize; //栈的大小
    private int[] stack; //数组，数组模拟栈，数据就放在该数组
    private int top = -1; //top表示栈顶，初始化为-1


    //构造器
    public ArrayStack(int maxSize) {
        this.maxSize = maxSize;
        stack = new int[this.maxSize];
    }

    public ArrayStack() {
    }

    //栈满
    public boolean isFull(){
        return top == maxSize - 1;
    }

    //栈空
    public boolean isEmpty(){
        return top == -1;
    }

    //入栈 push
    public void push(int value){
        //先判断是否满
        if(isFull()){
            System.out.println("栈满");
            return;
        }
        top++;
        stack[top] = value;
    }

    //出栈pop,将栈顶的数据返回
    public int pop(){
        //先判断栈是否空
        if(isEmpty()){
            //抛出异常处理，不抛的话你返回值搞啥呢,不需要return，抛出异常本身就终止了
            throw new RuntimeException("栈空，没有数据");
        }
        int value = stack[top];
        top--;
        return value;

    }

    //显示栈的情况[遍历栈],遍历时需要从栈顶开始显示数据
    public void list(){
        if(isEmpty()){
            System.out.println("栈空，没有数据");
            return;
        }
        for (int i = top; i >= 0 ; i--) {
            System.out.printf("stack[%d]=%d\n",i,stack[i]);

        }

    }
}
```

然后用链表实现的话也非常的简单，用头插法就号，没必要尾插法，不过我倒是在这里学到了异常的用法

## 实现综合计算器

![image-20201127092403348](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201127092403348.png)![image-20201127092646908](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201127092646908.png)

### 先实现个位数，再实现多位数

```java
package com.atguigu.stack;
/**
 * version 1.0
 * 还有一些问题
 * 多位数，等等，这个先不说，但是呢
 * 减号这里出现了问题
 * 3-2*6+2,就有问题,我后面再想想能怎么解决,目前的想法是如果是负号的话，那就把数字改成负的，减号改成加号,成功拉哈哈，其实之前是有想到的，但是自己蠢了没去实现
 */
public class Calculator {
    public static void main(String[] args) {

        String expression = "10-1*2-4";
        //根据前面老师思路，完成表达式的运算
        //创建两个栈，数栈，一个符号栈
        ArrayStack2 numStack = new ArrayStack2(10);
        ArrayStack2 operStack = new ArrayStack2(10);
        //定义需要的相关变量
        int index = 0;//用于扫描
        int num1 = 0;
        int num2 = 0;
        int oper = 0;
        int res = 0;
        char ch = ' ';//将每次扫描得到char保存到ch
        String keepNum = "";//用于拼接多位数
        //卡死hiwhile循环的扫描expression
        while (true){
            //依次得到expression的每一个字符,我不懂，为啥要subString
            ch = expression.substring(index,index+1).charAt(0);
            //判断ch是什么，然后做相应的处理
            if(operStack.isOper(ch)){
                //如果是运算符
                //判断当前符号栈是否为空
                if(!operStack.isEmpty()){
                    //进行比较，如果当前的操作符的优先级小于或者等于栈中的操作符，就需要从数栈中pop出两个数，
                    //再从符号栈中pop出一个符号进行运算，将得到的结果，入数栈，然后将当前的操作符入符号栈
                    if(operStack.priority(ch) <= operStack.priority(operStack.peek())){
                        num1 = numStack.pop();
                        num2 = numStack.pop();
                        oper = operStack.pop();
                        res = numStack.cal(num1,num2,oper);
                        //把运算的结果入数栈
                        numStack.push(res);
                        //然后把当前的操作符入栈
                        operStack.push(ch);
                    }else{
                        //大于
                        operStack.push(ch);
                    }
                }else{
                    //如果为空直接入栈
                    operStack.push(ch);
                }
            }else{//如果是数，则需要直接入数栈
                //分析思路
                //1.当处理多位数时，不能发现是一个数就立即入栈，因为他可能是多位数
                //2.在处理数，需要向expression的表达式的index再看一位，如果是数据就扫描，如果是符号才入栈
                //3.需要定义一个变量字符串，用于拼接

                //处理多位数
                if(!operStack.isEmpty() && operStack.peek() == '-'){
                    keepNum += '-';
                    operStack.pop();
                    operStack.push('+');
                }
                keepNum += ch;

                //如果ch已经是expression的最后一位，就直接入栈
                if(index == expression.length() - 1){
                    numStack.push(Integer.parseInt(keepNum));
                }
                //判断下一个字符是不是数字，如果是数字，就继续扫描，如果是运算符则入栈
                //注意只是往后看一位，不是index++
                else if(operStack.isOper(expression.substring(index+1,index+2).charAt(0))){
                    //如果后一位是运算符
                    numStack.push(Integer.parseInt(keepNum));
                    //重要！！！，keepNum清空
                    keepNum = "";


                }
            }
            //让index+1，并判断是否扫描到expression的最后
            index++;
            if (index >= expression.length()) {
                break;

            }
        }
        //当扫描完毕，就顺序的从数栈和符号栈中pop出相应的数和符号，并运行
        while (true){
            //如果符号栈为空，则计算到最后的结果，数栈中只有一个数组[结果]
            if(operStack.isEmpty()){
                break;
            }
            num1 = numStack.pop();
            num2 = numStack.pop();
            oper = operStack.pop();
            res = numStack.cal(num1,num2,oper);
            numStack.push(res);//入栈
        }
        System.out.println("表达式"+expression+"="+numStack.pop());
    }
}

//先创建一个栈，直接使用前面创建好的
//需要扩展功能
class ArrayStack2 {
    private int maxSize; //栈的大小
    private int[] stack; //数组，数组模拟栈，数据就放在该数组
    private int top = -1; //top表示栈顶，初始化为-1


    //构造器
    public ArrayStack2(int maxSize) {
        this.maxSize = maxSize;
        stack = new int[this.maxSize];
    }

    public ArrayStack2() {
    }

    //栈满
    public boolean isFull() {
        return top == maxSize - 1;
    }

    //栈空
    public boolean isEmpty() {
        return top == -1;
    }

    //入栈 push
    public void push(int value) {
        //先判断是否满
        if (isFull()) {
            System.out.println("栈满");
            return;
        }
        top++;
        stack[top] = value;
    }

    //出栈pop,将栈顶的数据返回
    public int pop() {
        //先判断栈是否空
        if (isEmpty()) {
            //抛出异常处理，不抛的话你返回值搞啥呢,不需要return，抛出异常本身就终止了
            throw new RuntimeException("栈空，没有数据");
        }
        int value = stack[top];
        top--;
        return value;
    }

    //显示栈的情况[遍历栈],遍历时需要从栈顶开始显示数据
    public void list() {
        if (isEmpty()) {
            System.out.println("栈空，没有数据");
            return;
        }
        for (int i = top; i >= 0; i--) {
            System.out.printf("stack[%d]=%d\n", i, stack[i]);
        }
    }

    //返回运算符的优先级，优先级是程序员来确定，优先级使用数字表示
    //数字越大，则优先级越高
    public int priority(int oper){
        if(oper == '*' || oper == '/'){
            return 1;
        }else if(oper == '+' || oper == '-'){
            return 0;
        }else {
            return -1;//假定目前的表达式只有+，-，*，/
        }

    }

    //判断是不是一个运算符
    public boolean isOper(char val){
        return val == '+' || val == '-' || val == '*' || val == '/';
    }
    //计算方法
    public int cal(int num1,int num2,int oper){
        int res = 0;//res用于存放计算的结果
        switch (oper){
            case '+':
                res = num1 + num2;
                break;
            case '-':
                res = num2 - num1;//注意顺序
                break;
            case '*':
                res = num1 * num2;
                break;
            case '/':
                res = num2 / num1;
                break;
            default:
                break;
        }
        return res;
    }
    //增加一个方法，可以返回当前栈顶的值，但式不是真正的pop
    public int peek(){
        return stack[top];
    }
}
```

### 前缀表达式

![image-20201128214208214](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201128214208214.png)

我还是第一次听过这个说法

![image-20201128214349027](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201128214349027.png)

这个前缀表达式时已经排序好的。但怎么去获取这个表达式呢就应该有判断的

![image-20201129111805458](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201129111805458.png)

两边不一样，晕了，不其实是一样的，是上面那个课件错了

![image-20201129112223858](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201129112223858.png)

![image-20201128214914190](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201128214914190.png)

这个是最不好操作的，

### 后缀表达式，逆波兰表达式

![image-20201128215154135](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201128215154135.png)

![image-20201128215204420](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201128215204420.png)



![image-20201129112730359](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201129112730359.png)

所以的话前缀和后缀的都是machine，中缀是human-readable

![image-20201129113310250](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201129113310250.png)

转成后缀的

![image-20201129113800810](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201129113800810.png)



### 逆波兰计算器

![image-20201129105950986](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201129105950986.png)

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201129114625683.png" alt="image-20201129114625683" style="zoom:67%;" />

```java
package com.atguigu.stack;
import java.util.ArrayList;
import java.util.List;
import java.util.Stack;
//这个比较不一样的是他如何储存数据的方式，思路还是比较简单的，他是把分割开来的数据都以String的形式储存，而且遍历的话采用的是list的集合进行遍历，而不是数组，那就基本上是这些
public class PolandNotation {
    public static void main(String[] args) {
        //先定义一个逆波兰表达式
        //(3+4)x5-6 -> 3 4 + 5 x 6 -
        //说明为了方便，逆波兰表达式的数字和符号使用空格隔开
        String suffixExpression = "30 4 + 5 * 6 -";
        //思路 
        //1.先将"3 4 + 5 x 6 -" => 放到ArrayList中
        //2.将ArrayList 传递给一个方法，遍历配合栈完成计算
        List<String> list = getListString(suffixExpression);
        System.out.println(list);
        int res = calculate(list);
        System.out.println(res);
    }

    //将一个逆波兰表达式依次将数据和运算符放到ArrayList中,而不是直接去取，不然的话要设置一个个index，就太累了
    public static List<String> getListString(String suffixExpression) {
        //将suffixExpression 分割
        String[] split = suffixExpression.split(" ");
        List<String> list = new ArrayList<>();
        for (String ele : split) {
            list.add(ele);
        }
        return list;
    }

    //完成对逆波兰表达式的运算
    public static int calculate(List<String> list) {
        //创建栈，只需要一个栈即可
        Stack<String> stack = new Stack<>();
        //遍历list
        for (String item : list) {
            //这里用正则表达式来取出数,没错以后这些东西是可以用正则的
            if (item.matches("\\d+")) {//匹配的是多位数
                //入栈
                stack.push(item);
            } else {
                //pop出两个数，并运算,再入栈
                int num2 = Integer.parseInt(stack.pop());
                int num1 = Integer.parseInt(stack.pop());
                int res = 0;
                if (item.equals("+")) {
                    res = num1 + num2;
                } else if (item.equals("-")) {
                    res = num1 - num2;
                } else if (item.equals("*")) {
                    res = num1 * num2;
                } else if (item.equals("/")) {
                    res = num1 / num2;
                } else {
                    throw new RuntimeException("运算符有误");
                }
                //把res入栈
                stack.push(res + "");
            }
        }
        //最后留在stack中的数据是结果
        return Integer.parseInt(stack.pop());
    }
}
```

### 中缀表达式转后缀表达式

![image-20201129153536511](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201129153536511.png)

![image-20201129153808204](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201129153808204.png)

![image-20201129154956593](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201129154956593.png)

![image-20201129114839690](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201129114839690.png)

从右扫到左，还是可以理解的

### 完整代码

```java
package com.atguigu.stack;
import java.util.ArrayList;
import java.util.List;
import java.util.Stack;
/**
 * 学到了啥？目前就是又复习了一遍中缀后缀表达式，之前学的毕竟都忘了啊
 */
public class PolandNotation {
    public static void main(String[] args) {
       //完成将一个中缀表达式转成后缀表达式的功能
        //说明
        //1. 1+((2+3)x4)-5
        //2. 因为直接对str进行操作，不方便，因此先将"1+((2+3)x4)-5" -> 中缀表达式对应的List
        // 即 ArrayList [1,+,(,(,2,+,3,),*,4,),-,5]
        //3. 将得到的中缀表达式对应的List => 后缀表达式对应的LiST
        // 即ArrayList [1, +, (, (, 2, +, 3, ), x, 4, ), -, 5] -> [1,2,3,+,4,*,+,5,-]
        String expression = "1+((2+3)*4)-5";
        List<String> infixExpressionList = toInfixExpressionList(expression);
        System.out.println(infixExpressionList);
        List<String> list = parseSuffixExpressionList(infixExpressionList);
        System.out.println(list);
        int calculate = calculate(list);
        System.out.println(calculate);
/*
        //先定义一个逆波兰表达式
        //(3+4)x5-6 -> 3 4 + 5 x 6 -
        //说明为了方便，逆波兰表达式的数字和符号使用空格隔开
        String suffixExpression = "30 4 + 5 * 6 -";
        //思路
        //1.先将"3 4 + 5 x 6 -" => 放到ArrayList中
        //2.将ArrayList 传递给一个方法，遍历配合栈完成计算

        List<String> list = getListString(suffixExpression);
        System.out.println(list);

        int res = calculate(list);
        System.out.println(res);
 */
    }

    //中缀表达式的list转成后缀表达式
    public static List<String> parseSuffixExpressionList(List<String> list){
        //定义两个栈
        Stack<String> s1 = new Stack<>();
        //说明：因为s2这个栈，在整个转换过程中，没有pop操作，而且我们后面还要逆序输出
        //因此比较麻烦，这里我们就不用Stack<String> 直接使用List<String> s2
//        Stack<String> s2 = new Stack<>();
        //储存中间结果的栈s2
        List<String> s2 = new ArrayList<>();
        //遍历s1
        for (String item : list){
            //如果是一个数：加入s2
            if(item.matches("\\d+")){
                s2.add(item);
            }else if(item.equals("(")){
                s1.push(item);
            }else if(item.equals(")")){
                //一次弹出s1栈顶的运算符，并亚茹s2，直到遇到左括号为止
                while(!s1.peek().equals("(")){
                    s2.add(s1.pop());
                }
                s1.pop();//!!! 将( 弹出s1，消除小括号
            }else{
                //当item的优先级小于等于s1栈顶运算符，将s1栈顶的运算符弹出并压入到s2中，再次转到循环中与s1中的新的栈顶元素比较
                //问题：我们缺少一个比较优先级高低的方法
                while (s1.size() != 0 && Operation.getValue(s1.peek()) >= Operation.getValue(item)){
                    s2.add(s1.pop());
                }
                //还需要将item压入栈
                s1.push(item);
            }
        }

        //将s1中剩余的运算符依次弹出并加入s2
        while (s1.size() != 0){
            s2.add(s1.pop());
        }
        return s2;
    }

    //方法：将中缀表达式转成对应的List
    public static List<String> toInfixExpressionList(String s){
        //定义一个List，存放中缀表达式对应的内容
        List<String> list = new ArrayList<>();
        int i = 0;//指针，用于遍历中缀表达式的字符串
        String str;//对于多位数的拼接
        char c;//每遍历到一个字符，就放入c
        do{
            //如果c是一个非数字，就需要加入到list里面去
            if((c=s.charAt(i)) < 48 || (c=s.charAt(i)) > 57){
                list.add(""+c);
                i++;
            }else{//如果是一个数，需要考虑多位数的问题
                str = "";//现将str置成""
                while (i < s.length() && (c=s.charAt(i)) >= 48 && (c=s.charAt(i)) <= 57){
                    str += c;//拼接
                    i++;
                }
                list.add(str);
            }
        }while (i < s.length());
        return list;//返回list

    }
    //将一个逆波兰表达式依次将数据和运算符放到ArrayList中,而不是直接去取，不然的话要设置一个个index，就太累了
    public static List<String> getListString(String suffixExpression) {
        //将suffixExpression 分割
        String[] split = suffixExpression.split(" ");
        List<String> list = new ArrayList<>();
        for (String ele : split) {
            list.add(ele);
        }
        return list;
    }

    //完成对逆波兰表达式的运算
    public static int calculate(List<String> list) {
        //创建栈，只需要一个栈即可
        Stack<String> stack = new Stack<>();
        //遍历list
        for (String item : list) {
            //这里用正则表达式来取出数,没错以后这些东西是可以用正则的
            if (item.matches("\\d+")) {//匹配的是多位数
                //入栈
                stack.push(item);
            } else {
                //pop出两个数，并运算,再入栈
                int num2 = Integer.parseInt(stack.pop());
                int num1 = Integer.parseInt(stack.pop());
                int res = 0;
                if (item.equals("+")) {
                    res = num1 + num2;
                } else if (item.equals("-")) {
                    res = num1 - num2;
                } else if (item.equals("*")) {
                    res = num1 * num2;
                } else if (item.equals("/")) {
                    res = num1 / num2;
                } else {
                    throw new RuntimeException("运算符有误");
//                    System.out.println("不存在该运算符");
//                    break;
                }
                //把res入栈
                stack.push(res + "");
            }
        }
        //最后留在stack中的数据是结果
        return Integer.parseInt(stack.pop());
    }
}

//编写一个类 Operation 可以返回一个运算符的优先级
class Operation{
    private static int ADD = 1;
    private static int SUB = 1;
    private static int MUL = 2;
    private static int DIV = 2;

    //写一个方法，返回对应的优先级数字
    public static int getValue(String operation){
        int result = 0;
        switch (operation){
            case "+":
                result = ADD;
                break;
            case "-":
                result = SUB;
                break;
            case "*":
                result = MUL;
                break;
            case "/":
                result = DIV;
                break;
            default:
                System.out.println("不存在该运算符");
                break;
//                throw new RuntimeException("不存在该运算符");
        }
        return result;
    }
}
```

现在需要想的是小数点怎么搞，感觉也没有那么难的样子

# 6. 递归问题 √

## 1.迷宫

就是

![image-20201202202432054](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201202202432054.png)

小球的路径去到某个终点，我们采用的是回溯的算法，就是 回去又回来，先设置好值，然后判断ok不ok，不ok再设置回来

```java
package com.atguigu.recursion;

public class MiGong {
    public static int[][] trace = new int[8][7];
    public static void main(String[] args) {

        //先创建一个二维数组，模拟迷宫
        //地图
        int[][] map = new int[8][7];
        //使用1表示墙
        //上下全部置为1
        for (int i = 0; i < 7; i++) {
            map[0][i] = 1;
            map[7][i] = 1;
        }
        //左右全部置为1
        for (int i = 0; i < 8; i++) {
            map[i][0] = 1;
            map[i][6] = 1;
        }
        //设置挡板
        map[3][1] = map[3][2] = 1;

        //输出地图
        System.out.println("当前地图的情况");
        for (int i = 0; i < 8; i++) {
            for (int j = 0; j < 7; j++) {
                System.out.print(map[i][j] + " ");
            }
            System.out.println();
        }

        //使用递归回溯给小球找路
        setWay(map, 1, 1);
        //输出新的地图
        System.out.println("新的地图");
        for (int i = 0; i < 8; i++) {
            for (int j = 0; j < 7; j++) {
                System.out.print(map[i][j] + " ");
            }
            System.out.println();
        }
    }
    //说明
    //1. map表示地图
    //2. i，j表示从哪个位置出发(1,1)
    //3. 如果小球能到map[6][5] 位置，则说明通路找到
    //4. 约定：当map[i][j] 为0表示该点没有走过 当为1表示墙 2 表示通路可以走； 3表示该点已经走过，但是不通
    //5. 在走迷宫时，需要确定一个策略(方法)，下-> 右 -> 上 -> 左，如果该点走不通，再回溯
    /**
     * @param map 表示地图
     * @param i 从哪个位置开始找
     * @param j
     * @return 如果找到通路，就返回 true，否则返回false
     */
    //使用递归回溯来给小球找路
    public static boolean setWay(int[][] map, int i, int j){
        if(map[6][5] == 2){//通路已经找到ok
                return true;
        }else {
            if(map[i][j] == 0){
                //如果当前这个点还没有走过
                //按照策略走 下-> 右 -> 上 -> 左
                map[i][j] = 2;//假设该点可以走通
                if(setWay(map, i+1 , j)){
                    //向下走
                    return true;
                }else if(setWay(map, i, j+1)){
                    //向右走
                    return true;
                }else if(setWay(map, i - 1, j)){
                    //向上
                    return true;
                }else if(setWay(map, i, j - 1)){
                    //向左走
                    return true;
                }else{
                    //说明该点走不通
                    map[i][j] = 3;
                    return false;
                }
            }else{
                //如果map不等于0，可能是1,2,3
                return false;
            }
        }
    }
}
```

这个递归有意思

```c
/**********
【题目】编写递归算法，求对二叉树T先序遍历时
第k个访问的结点的值。
二叉链表类型定义：
typedef struct BiTNode {
  TElemType data;
  struct BiTNode  *lchild, *rchild;
} BiTNode, *BiTree;
**********/

TElemType PreOrder(BiTree T,int &cnt){
       TElemType e;
     if(cnt == 0 || !T){
       return '#';
     }
     if(cnt == 1){
        return T->data;
     }
       cnt--;
       if(T->lchild){
      e =  PreOrder(T->lchild,cnt);
      if(e != '#'){
        return e;    
         }
          }
          if(T->rchild){
       e =  PreOrder(T->rchild,cnt);
        return e;
       }
       return '#';  


}

TElemType PreOrderK(BiTree T, int k)
/* 求对二叉树T先序遍历时第k个访问的结点的值。*/
/* 若失败，则返回'#'                         */
{
int cnt = k;
return PreOrder(T,cnt);
   
}
我终于明白了为什么，这就是c的特性把

```

## 2. 八皇后问题

![image-20201203201024393](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201203201024393.png)

![image-20201203201754118](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201203201754118.png)

这里的话有些不一样的方法去backtracking，这里用到了一个tree，一条路行不通就kill掉，就蛮有趣的把，的确很完美地展现了backtracking的思路

---------------------------------------------------------------

皇后的可以上下左右走，所以的话就相当于最后不能在前后左右斜线中遇到，然后为什么用一个一维数组就能解决问题呢？因为刚好像是数字不重复，同时也不能斜线一排。

![](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201203171456972.png)

怎么说呢，代码也十分的简单，我觉得我也可以写出来，干巴爹

```java
package com.atguigu.recursion;
public class Queen8 {
    //定义一个max表示共有多少个皇后
    int max = 8;
    //定义数组array，保存皇后放置位置的结果，比如 arr[8] = {0,4,7,5,2,6,1,3}
    int[] array = new int[max];
    static int count = 0;
    public static void main(String[] args) {
        //测试一把，8皇后是否正确
        Queen8 queen8 = new Queen8();
        queen8.check(0);
        System.out.println("一共有"+ count + "种解法");

    }

    //编写一个方法，放置第n个皇后
    //特别注意：check 是每一次递归时，进入到check中都有一套for循环
    private void check(int n){
        if(n == max){//n = 8,其实8个皇后已经放好了，n从0开始的
            print();
            return;
        }
        //依次放入皇后并判断是否冲突
        for (int i = 0; i < max; i++) {
            //先把当前这个皇后n，放到该行的第1列
            array[n] = i;
            //判断当放置第n个皇后到i列时，是否冲突
            if(judge(n)){//不冲突
                //接着放n+1个皇后，即开始递归
                check(n+1);
            }
            //如果冲突，就继续执行array[n] = i;即将第n个皇后放置在本行的后移一个位置
        }
    }

    //查看当我们放置第n个皇后，就去检测该皇后是否和前面已经摆放的皇后冲突

    /**
     * @param n 表示第n个皇后
     * @return
     */
    private boolean judge(int n){
        for (int i = 0; i < n; i++) {
            //之前还在想怎么处理diagonal，然后现在哇，的确没错，对角线45°
            if(array[i] == array[n] || Math.abs(n -i) == Math.abs(array[n] - array[i])){
                return false;
            }
        }
        return true;
    }
    //写一个方法，可以将皇后摆放的位置输出
    private void print(){
        count++;
        for (int i = 0; i <array.length ; i++) {
            System.out.print(array[i] + " ");
        }
        System.out.println();
    }
}
```

其实你只要按一次的想就很简单，把一段内容分完功能模块之后就很简单。

# 7. 排序算法

![image-20201204101313440](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201204101313440.png)

没有想到分为两类

![image-20201204101925981](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201204101925981.png)

这个稳定性后面想一下，两个相同的数，前面那个排序好的还是在前面

## 1.选择排序 √

很简单，就是忘了他怎么做的了

![image-20201204104113483](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201204104113483.png)

记下这个思路就可以了吧

而且吼，速度会比冒泡的快噢，好像是在for循环里面的语句比较少把，没想到差别这么大

## 2. 希尔排序  √

![image-20201204204155455](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201204204155455.png)

的确是哈

![image-20201204204218379](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201204204218379.png)

![image-20201204204535351](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201204204535351.png)

```java
package com.atguigu.sort;
import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;

public class ShellSort {
    public static void main(String[] args) {
//        int[] arr = {8,9,1,7,2,3,5,4,6,0};
        //创建80000个随机数的数组
        int length = 80000;
        int[] arr = new int[length];
        for (int i = 0; i < length; i++) {
            arr[i] = (int)(Math.random() * 8000000);
        }
//        System.out.println("排序前");
        Date date = new Date();
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String parse = sdf.format(date);
        System.out.println("排序前时间是=" + parse);
        shellSort2(arr);
        System.out.println(Arrays.toString(arr));
        Date date1 = new Date();
        String date2Str = sdf.format(date1);
        System.out.println("排序后时间是=" + date2Str);
    }

    //这个非常慢是因为他内部用到了冒泡的内核，不断地进行交换交换造成的。然后怎么理解这个-gap呢，实际上你到后面一组有多个的时候，你要不断地往前再去找，7s的样子
    public static void shellSort(int[] arr){

        int count = 0;
        for (int gap = arr.length / 2; gap > 0 ;gap /= 2){
            //希尔排序的第一轮排序
            for (int i = gap; i < arr.length; i++) {
                for (int j = i - gap; j >= 0 ; j-=gap){ {
                    //如果当前元素大于加上步长后的那个元素，说明交换
                    if(arr[j] > arr[j + gap]){
                        int temp = arr[j];
                        arr[j] = arr[j + gap];
                        arr[j + gap] = temp;
                    }
                }
                }
        }
        }
    }

    //这个真的快了超多，没有想到只是移位不交换就会提升那么多，看来是我低估了哈。不到1s
    public static void shellSort2(int[] arr){
        for (int gap = arr.length / 2; gap > 0 ;gap /= 2){
            //从第gap个元素，逐个对其所在的组进行直接插入排序
            for (int i = gap; i< arr.length;i++){
                int j = i;
                int temp = arr[j];
                if(arr[j] < arr[j - gap]){
                    while (j - gap >= 0 && temp < arr[j - gap]){
                        //移动
                        arr[j] = arr[j - gap];
                        j -= gap;
                    }
                    //当退出while后，就给temp找到插入的位置
                    arr[j] = temp;
                }
            }
        }
    }
}
```

这个怎么说呢，很有趣，希望自己也能写出这个代码出来。

## 3. 快速排序 √

![image-20201205184034389](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201205184034389.png)

忘了好烦，学过的忘了好多

![image-20201205184546614](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201205184546614.png)

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201205185853022.png" alt="image-20201205185853022" style="zoom:50%;" />

思路很简单了啦，我就记得要分一半，其他的不是很记得了，而且还用到了递归，这么一看实际上是冒泡的升级版，因为他也是两两交换，但他更加聪明了，拆成了两半。不断地拆。

主要是选pivot，有些人会从最后选，有些人直接从中间选, 我还是觉得从后面选比较好

```java
package com.atguigu.sort;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;

public class QuickSort {

    public static void main(String[] args) {
        int length = 80000;
        int[] arr = new int[length];
        for (int i = 0; i < length; i++) {
            arr[i] = (int)(Math.random() * 8000000);
        }
        Date date = new Date();
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String parse = sdf.format(date);
        System.out.println("排序前时间是=" + parse);
        
        quickSort(arr,0,arr.length-1);
        System.out.println(Arrays.toString(arr));

        Date date1 = new Date();
        String date2Str = sdf.format(date1);
        System.out.println("排序后时间是=" + date2Str);
    }

    public static void quickSort(int[] arr,int left,int right){
        int l = left;
        int r = right;
        //pivot 中轴
        int pivot = arr[(left + right) / 2];
        int temp = 0;//临时变量，作为交换时使用
        //while循环的目的：让比pivot 小的值放到左边
        //比pivot值大的放到右边
        while (l < r){
            //在pivot左边一直找，找到大于等于pivot值，才退出
            while (arr[l] < pivot){
                l+=1;
            }
            //在pivot右边一直，找到小于等于pivot值，才退出
            while (arr[r] > pivot){
                r-=1;
            }

            //如果 l>=r说明pivot的左右两值，已经按照左边全部是小于等于pivot值，右边全部是大于pivot值
            if( l >= r){
                break;
            }
            //交换
            temp = arr[l];
            arr[l] = arr[r];
            arr[r] = temp;

            //如果交换完后，发现这个arr[l] == pivot值 -- ，前移
            if(arr[l] == pivot){
                r -= 1;
            }
            //如果交换完后，发现这个arr[r] == pivot值 相等 l++,右移
            if(arr[r] == pivot){
                l += 1;
            }
        }

        //如果 l == r,必须l++,r--，否则为出现栈溢出
        //怎么说呢，我个人觉得不需要这个判断。而且这里比较tricky的是r是拿给左边用的，l是拿给右边用的。我觉得需要再多练几遍吧啊
        //不过说实话如果你拿最后的当pivot的话，会更好理解，没有这么多要考虑的东西。
        if(l == r){
            l+=1;
            r-=1;
        }
        //向左递归
        if(left < r){
            quickSort(arr, left, r);
        }
        //向右递归
        if(right > l){
            quickSort(arr, l ,right);
        }
    }
}
```

## 4. 归并排序 √

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201206142149797.png" alt="image-20201206142149797" style="zoom:67%;" />

说实话我的确忘记了哈，然后现在用记起来了，他就是用的space 会多些，然后是这样一直分，分下去的。直到分成一个。

```java
package com.atguigu.sort;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;

public class MergeSort {
    public static void main(String[] args) {
        int length = 800000;
        int[] arr = new int[length];
        for (int i = 0; i < length; i++) {
            arr[i] = (int)(Math.random() * 8000000);
        }
        int[] temp = new int[length];
        Date date = new Date();
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String parse = sdf.format(date);
        System.out.println("排序前时间是=" + parse);

        mergeSort(arr,0,arr.length-1,temp);
//        System.out.println(Arrays.toString(arr));

        Date date1 = new Date();
        String date2Str = sdf.format(date1);
        System.out.println("排序后时间是=" + date2Str);
    }

    //分+合方法
    public static void mergeSort(int[] arr, int left, int right, int[] temp){
        //这里其实也不难理解的真的
        if(left < right){
            int mid = (left + right) / 2;
            mergeSort(arr,left,mid,temp);
            mergeSort(arr,mid+1,right,temp);
            merge(arr,left,mid,right,temp);
        }
    }

    /**
     * @param arr 排序的原始数组
     * @param left 左边有序序列的初始索引
     * @param mid 中间索引
     * @param right 右边索引
     * @param temp 做中转的数组
     //这里基本是合并数组很好理解的
     */
    public static void merge(int[] arr, int left, int mid, int right, int[] temp){
        int i = left;
        int j = mid + 1;
        int t = 0; // 指向temp数组的当前索引
        //先把左右两边(有序)的数据按照规则填充到temp数组
        //直到左右两边有序序列，有一边处理完毕为止
        while (i <= mid && j <= right){
            if(arr[i] <= arr[j]){
                temp[t] = arr[i];
                t++;
                i++;
            }else{
                temp[t] = arr[j];
                t++;
                j++;
            }
        }
        //把有剩余数据的一边的数据依次全部填充到temp
        while(i <= mid){
            temp[t] = arr[i];
            t++;
            i++;
        }
        while (j <= right){
            temp[t] = arr[j];
            t++;
            j++;
        }
        //将temp数组的元素拷贝到arr
        t = 0;
        int tempLeft = left;
        while (tempLeft <= right){
            arr[tempLeft] = temp[t];
            t++;
            tempLeft++;
        }
    }
}

```

time complexity 的话看看这个

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201206162930125.png" alt="image-20201206162930125" style="zoom:67%;" />![image-20201206162945600](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201206162945600.png)

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201206162930125.png" alt="image-20201206162930125" style="zoom:67%;" />![image-20201206162945600](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201206162945600.png)

## 5. 基数排序

**稳定的排序**

![image-20201207153807433](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201207153807433.png)

![image-20201207154605688](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201207154605688.png)

难理解吗，也不会吧，基数排序是以桶排序为基础的，然后呢他是把数组按一定规则放到每个桶里，然后再依照顺序放回数组里的，kind of tricky

![image-20201207155621287](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201207155621287.png)

然后这里需要说一句的是你的前面一轮的值还在里面，进去的话只是覆盖了，那我好奇怎么判断呢，用一个数组去存size

```java
package com.atguigu.stack;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;

public class RadixSort {
    public static void main(String[] args) {
        int length = 8;
        int[] arr = new int[length];
        for (int i = 0; i < length; i++) {
            arr[i] = (int)(Math.random() * 8000000);
        }
//        System.out.println("排序前");
        Date date = new Date();
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String parse = sdf.format(date);
        System.out.println("排序前时间是=" + parse);
        radixSort(arr);
        System.out.println(Arrays.toString(arr));

        Date date1 = new Date();

        String date2Str = sdf.format(date1);
        System.out.println("排序后时间是=" + date2Str);
    }
    public static  void radixSort(int[] arr){

        //1.得到数组中最大的数的位数
        int max = arr[0];
        for (int i = 0; i < arr.length; i++) {
            if(arr[i] > max){
                max = arr[i];
            }
        }
        //得到最大数是几位数
        int maxLength = (max + "").length();

        //定义一个二维数组，表示10个桶，每个桶就是一个一维数组
        //说明
        //1. 二维数组包含10个一维数组
        //2. 为了防止在放入数的时候，数据溢出，则每个一维数组(桶)，大小定为arr。length
        //3. 名明确，基数排序是使用空间换时间的经典算法
        int[][] bucket = new int[10][arr.length];

        //为看记录每个桶中，实际存放了多少个数据，我们定义一个一维数组来记录各个桶每次放入数据的个数
        //可以这样理解
        //bucketElementCounts[0],记录的就是bucket[0]桶放入数据个数
        int[] bucketElementCounts = new int[10];

        //这里我们使用循环将代码处理
        for (int i = 0, n = 1; i <maxLength ; i++,n *= 10) {
            for (int j = 0; j < arr.length; j++) {
                //取出每个元素的对应位的值
                int digitOfElement = arr[j] / n % 10;
                //放入到对应的桶中
                bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];
                bucketElementCounts[digitOfElement]++;
            }

            //按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数里)
            int index = 0;
            //遍历每一个桶，并将桶中数据放入原数组
            for (int k = 0; k < bucketElementCounts.length; k++) {
                //如果桶中有数据，我们才放入原数组
                if(bucketElementCounts[k] != 0){
                    //循环该桶
                    for(int l = 0; l < bucketElementCounts[k]; l++){
                        //取出元素放入到arr
                        arr[index++] = bucket[k][l];
                    }
                }
                bucketElementCounts[k] = 0;
            }
//            System.out.println("第" + (i+1) + "轮，对个位的排序处理arr=" + Arrays.toString(arr));
        }
    }
}
```

非常快啊，也简单的，只是也需要经常复习罢了

![image-20201207190731864](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201207190731864.png)

## 总结

![image-20201207192206240](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201207192206240.png)

就目前分为三个级别把，基数就是最牛逼的，但实际情况的话还要看n的规模。

稳定性的理解：

当一个算法是稳定的，这说明排序前和排序后两个数之间的相对位置不会改变，比如说[1,4,6,1];前面那个1还是在前面，后面那个1还是在后面，那怎么才能达到不稳定呢？ 我个人的理解为能swap的，而且是跨界度的swap，就直接农民翻身的那种。

像这里的选择排序，找到最小值之后和前面的进行交换。希尔排序也是可以直接跨界度交换，快速也是哈，直接最后面的放前面去了，堆排序就更不用说了，直接第一个和最后一个交换。

# 8. 查找算法

## 1. 二分查找

**注意：需要是有序的数组**

注意哈，满足条件的值不只一个呢？

```java
package com.atguigu.search;

import java.util.ArrayList;
import java.util.List;

//注意:使用二分查找的前提是该数组是有序的
public class BinarySearch {
    public static void main(String[] args) {
        int[] arr = {1,8,10,1000,1000,1234};
//        int resIndex = binarySearch(arr, 0, arr.length - 1, 2);
//        System.out.println(resIndex);
        List<Integer> list = binarySearch2(arr, 0, arr.length - 1, 1000);
        System.out.println(list);
    }
    public static int binarySearch(int[] arr, int left, int right, int findVal){
        if(left > right){
            return -1;
        }
        int mid = (left + right) / 2;
        int midVal = arr[mid];

        if(findVal > midVal){
            return binarySearch(arr, mid + 1, right, findVal);
        }else if(findVal < midVal){
            return binarySearch(arr, left, mid-1, findVal);
        }else{
            return mid;
        }
    }

    //完成一个课后思考题
    //{1,8,10,89,1000,1000,1234}当一个有序数组中有多个相同的数值时，如何将所有的数值都查找到，比如这里的的1000
    /*
    思路分析
    1. 在找到mid索引值，不要马上返回
    2. 向mid索引值的左边扫描，将所有满足1000的元素下标加入到集合中
    3. 向右边扫描

     */

    public static List<Integer> binarySearch2(int[] arr, int left, int right, int findVal){
        if(left > right){
            return new ArrayList<Integer>();
        }
        int mid = (left + right) / 2;
        int midVal = arr[mid];

        if(findVal > midVal){
            return binarySearch2(arr, mid + 1, right, findVal);
        }else if(findVal < midVal){
            return binarySearch2(arr, left, mid-1, findVal);
        }else{
            List<Integer> resIndexList = new ArrayList<>();
            int temp = mid - 1;
            while (true){
                if(temp < 0 || arr[temp] != findVal){
                    break;
                }
                //否则,就把temp放入到集合中
                resIndexList.add(temp);
                temp -= 1;
            }
            resIndexList.add(mid);

            temp = mid + 1;
            while (true){
                if(temp > arr.length - 1 || arr[temp] != findVal){
                    break;
                }
                resIndexList.add(temp);
                temp++;
            }
            return resIndexList;
        }
    }
}
```

## 2. 插值查找 算法

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201208110019478.png" alt="image-20201208110019478" style="zoom:67%;" />

这个实际上就是比例了

![image-20201208110901707](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201208110901707.png)

![image-20201208112212016](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201208112212016.png)



这个的确需要注意一下哈，分布均匀是最好的。

```java
package com.atguigu.search;

public class InsertValueSearch {

    public static void main(String[] args) {

        int[] arr = new int[100];
        for (int i = 0; i < 100; i++) {
            arr[i] = i + 1;
        }
        int i = insertValueSearch(arr, 0, arr.length - 1, 100);
        System.out.println(i);

    }

    public static int insertValueSearch(int[] arr, int left, int right, int findVal){
        //注意： 后面判断是否比最小的小比最大的大是需要的
        //否则我们得到的mid可能越界
        if(left > right || findVal < arr[0] || findVal > arr[arr.length - 1]){
            return -1;
        }
        int mid = left +(right - left) * (findVal - arr[left]) / (arr[right] - arr[left]);
        int midVal = arr[mid];
        if(findVal > midVal){
            return insertValueSearch(arr, mid + 1, right, findVal );
        }else if(findVal < midVal){
            return insertValueSearch(arr, left, mid - 1, findVal);
        }else{
             return mid;
        }
    }
}
```

## 3. 斐波那契查找

噢，我一直知道的是斐波那契求和，但查找的话我还真没有试过

![image-20201208113508420](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201208113508420.png)

其实不难理解，这个就是变着搞mid，之前不是有1/2 (high + low)吗，然后又有个比例的，这里就又有一个黄金分割的。

```java
package com.atguigu.search;

import java.util.Arrays;

public class FibonacciSearch {
    public static int maxSize = 20;
    public static void main(String[] args) {
        int[] arr = {1,8,10,89,1000,1234};
        System.out.println(fibSearch(arr,13));
    }

    //因为后面我们mid=low+F(k-1)-1,需要使用到斐波那契数列，因此我们需要先获取 到一个斐波那契数列
    //非递归方式得到一个斐波那契数列
    public static int[] fib(){
        int[] f = new int[maxSize];
        f[0] = 1;
        f[1] = 1;
        for (int i = 2; i < maxSize; i++) {
            f[i] = f[i-1] + f[i-2];
        }
        return f;
    }

    /**
     * @param a 数组
     * @param key 我们需要查找的关键码(值)
     * @return 返回对应的下标，如果没有就-1
     */
    //编写斐波那契查找算法
    public static int fibSearch(int[] a, int key){
        int low = 0;
        int high = a.length - 1;
        //表示斐波那契分割的下标
        int k = 0;
        int mid = 0;
        int f[] = fib();
        //获取到斐波那契分割的下标
        while (high > f[k] - 1){
            k++;
        }
        //因为f[k]值可能大于a的长度，因此我们需要使用Arrays类，构造一个新的数组，并指向a[]
        //不足的部分会使用0填充
        int[] temp = Arrays.copyOf(a,f[k]);
        //实际上需要使用a数组填充temp
        for (int i = high + 1; i < temp.length; i++) {
            temp[i] = a[high];
        }

        while (low <= high){
            mid = low + f[k-1] - 1;
            if(key < temp[mid]){
                high = mid - 1;
                //说明
                //1. 全部元素= 前面的元素 + 后面的元素
                //2. f[k] = f[k - 1] + f[k - 2]
                //因为前面有f[k -  1]个元素，所以可以继续拆分
                //即在f[k - 1]前面继续查找 k--
                //即下次循环mid = f[k - 1 - 1] - 1
                k--;
            }else if(key > temp[mid]){
                low = mid + 1;
                //为什么是k-2
                //说明
                //1. 全部元素= 前面元素 + 后边元素
                //2. f[k] = f[k - 1] + f[k - 2]
                //3. 因为后面我们有 f[k - 2] 所以我们可以继续拆分 f[k-1] = f[k-3] + f[k-4]
                //4. 即在f[k=2] 的前面进行查找k-=2
                //5. 即下次循环 mid = f[k - 1 - 2] - 1
                k -= 2;
            }else{
                //md,终于懂了哈无语,因为这个是扩容的数组，扩容后的index变了，但数值还是最后一个数的，所以呢，刚好跑到扩容那里的话就要等于high哈
                if(mid <= high){
                    return mid;
                }else{
                    return high;
                }
            }
        }
        return -1;
    }
}
```

# 9. 哈希

## 1.哈希表

![image-20201208150843276](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201208150843276.png)

![image-20201208151153807](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201208151153807.png)

![image-20201208152053450](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201208152053450.png)

# 10. 树

## 1. 前序中序后序

### 1.遍历

```java
package com.atguigu.tree;

/**
 * 我之前学的BST 的先中后，不过不是BST也是可以的
 */
public class BinaryTreeDemo {
    public static void main(String[] args) {

        //先需要创建一颗二叉树
        BinaryTree binaryTree = new BinaryTree();

        HeroNode node1 = new HeroNode(1, "宋江");
        HeroNode node2 = new HeroNode(2, "吴用");
        HeroNode node3 = new HeroNode(3, "卢俊义");
        HeroNode node4 = new HeroNode(4, "林冲");
        HeroNode node5 = new HeroNode(5, "关胜");

        //说明，我们先手动创建该二叉树，后面我们学习递归方式创建二叉树
        node1.setLeft(node2);
        node1.setRight(node3);
        node3.setRight(node4);
        node3.setLeft(node5);

        System.out.println("前序遍历");
        binaryTree.setRoot(node1);
        binaryTree.preOrder();


        System.out.println("中序遍历");
        binaryTree.infixOrder();

        System.out.println("后序遍历");
        binaryTree.postOrder();

    }
}
class BinaryTree{
    private HeroNode root;

    public void setRoot(HeroNode root){
        this.root = root;

    }

    //怎么说呢，这里我有种奇怪的感觉，因为我之前学的是一个方法单独拿出来的，而不是放在结点的方法里，不过也可以把
    public void preOrder(){
        if(this.root != null){
            this.root.preOrder();
        }else{
            System.out.println("二叉树无法遍历");
        }
    }

    public void infixOrder(){
        if(this.root != null){
            this.root.infixOrder();
        }else{
            System.out.println("二叉树无法遍历");
        }
    }

    public void postOrder(){
        if(this.root != null){
            this.root.postOrder();
        }else{
            System.out.println("二叉树无法遍历");
        }
    }
}
class HeroNode{
    private int no;
    private String name;
    private HeroNode left;
    private HeroNode right;

    public HeroNode(int no, String name) {
        this.no = no;
        this.name = name;
    }

    public int getNo() {
        return no;
    }

    public void setNo(int no) {
        this.no = no;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public HeroNode getLeft() {
        return left;
    }

    public void setLeft(HeroNode left) {
        this.left = left;
    }

    public HeroNode getRight() {
        return right;
    }

    public void setRight(HeroNode right) {
        this.right = right;
    }

    @Override
    public String toString() {
        return "HeroNode{" +
                "no=" + no +
                ", name='" + name + '\'' +
                '}';
    }

    //编写前序遍历
    public void preOrder(){
        System.out.println(this);

        if(this.left != null){
            this.left.preOrder();
        }
        if(this.right != null){
            this.right.preOrder();
        }
    }

    public void infixOrder(){
        if(this.left != null){
            this.left.infixOrder();
        }
        System.out.println(this);
        if(this.right != null){
            this.right.infixOrder();
        }
    }

    public void postOrder(){
        if(this.left != null){
            this.left.postOrder();
        }
        if(this.right != null){
            this.right.postOrder();
        }
        System.out.println(this);
    }
}

```

### 后序遍历非递归方法(c) √

```c
/**********
【题目】试利用栈及其基本操作写出二叉树T的非递归
的后序遍历算法(提示：为分辨后序遍历时两次进栈的
不同返回点，需在指针进栈时同时将一个标志进栈）。
二叉链表类型定义：
typedef struct BiTNode {
  TElemType  data;
  struct BiTNode  *lchild,*rchild;
} BiTNode, *BiTree;
可用栈类型Stack的相关定义：
typedef struct {
  struct BiTNode *ptr; // 二叉树结点的指针类型
  int      tag; // 0..1
} SElemType;    // 栈的元素类型
Status InitStack(Stack &S); 
Status StackEmpty(Stack S); 
Status Push(Stack &S, SElemType e);
Status Pop(Stack &S, SElemType &e); 
Status GetTop(Stack S, SElemType &e); 
**********/
void PostOrder(BiTree T, void (*visit)(TElemType))
/* 使用栈，非递归后序遍历二叉树T，     */
/* 对每个结点的元素域data调用函数visit */
{
   if(!T){
    return;
   }
   Stack S;
   InitStack(S);
   SElemType now;
   now.ptr = T;
   now.tag = 1;
   Push(S,now);
   while(!StackEmpty(S)){
       //每轮都pop是为了看看最顶上是啥子，其实也可以直接getTop的
        Pop(S,now);
       //表示这是第一次遇到哦
        if(now.tag == 1){
            now.tag = 2;
            Push(S,now);
            //如果左边有的话就要把左边的加进去，并设为1
            if(now.ptr->lchild){
                now.ptr = now.ptr->lchild;
                now.tag = 1;
                Push(S,now);
            }
        }
       //第二次遇到拉，意味着左边已经全部搞完拉，搞完右边就可以继续了
        else if(now.tag == 2){
            now.tag = 3;
            Push(S,now);
            //有右子树的话就要继续这个操作拉
            if(now.ptr->rchild){
                now.ptr = now.ptr->rchild;
                now.tag = 1;
                Push(S,now);
            }
        }
       //现在就是没搞的给我搞出来了
        else
            visit(now.ptr->data);   
   }
}
```

有点没接触过这种的就是可以用tag的方式去标记

### 2. 查找节点

![image-20201209104053111](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201209104053111.png)

```java
class BinaryTree{
    private HeroNode root;

    public void setRoot(HeroNode root){
        this.root = root;

    }

    public HeroNode preOrderSearch(int no){
        if(root != null){
            return root.preOrderSearch(no);
        }else{
            return  null;
        }
    }

    public HeroNode infixOrderSearch(int no){
        if(root !=null){
            return root.infixOrderSearch(no);
        }else{
            return null;
        }
    }

    public HeroNode postOrderSearch(int no){
        if(root != null){
            return root.postOrderSearch(no);
        }else{
            return null;
        }
    }


}
class HeroNode{
    private int no;
    private String name;
    private HeroNode left;
    private HeroNode right;

    public HeroNode(int no, String name) {
        this.no = no;
        this.name = name;
    }


    //前序遍历查找
    public HeroNode preOrderSearch(int no){
        if(this.no == no){
            return this;
        }
        HeroNode resNode = null;
        if(this.left != null){
            resNode = this.left.preOrderSearch(no);
        }
        if(resNode != null){
            return resNode;
        }
        if(this.right != null){
            resNode = this.right.preOrderSearch(no);
        }
        return resNode;
    }

    //有一个问题是如果有多个节点的话怎么办
    public HeroNode infixOrderSearch(int no){
        HeroNode resNode = null;
        if(this.left != null){
             resNode = this.left.preOrderSearch(no);
        }
        if(resNode != null){
            return resNode;
        }
        if(this.no == no){
            return this;
        }
        if(this.right != null){
            resNode = this.right.preOrderSearch(no);
        }
        return resNode;
    }
    public HeroNode postOrderSearch(int no){
        HeroNode resNode = null;
        if(this.left != null){
            resNode = this.left.preOrderSearch(no);
        }
        if(resNode != null){
            return resNode;
        }
        if(this.right != null){
            resNode = this.right.preOrderSearch(no);
        }
        if(resNode != null){
            return  resNode;
        }
        if(this.no == no){
            return this;
        }
        return resNode;
    }
}

```

### 3.删除节点

我就不写了，他这各直接是最普通的二叉树的删除，没什么规律可言

## 2. 顺序二叉树

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201211120639099.png" alt="image-20201211120639099" style="zoom: 67%;" />

- [x] 我老记不住 complete tree 是啥，你就想一个数组，就是图里面的数组，他是complete的，也就是说它是按顺序添加的，不能有漏掉的，数组是complete的

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201211121527041.png" alt="image-20201211121527041" style="zoom:67%;" />

- [ ] 这个图可以anki一下

### 1. 顺序存储二叉树的实现

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201211201547594.png" alt="image-20201211201547594" style="zoom:67%;" />

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201211202552958.png" alt="image-20201211202552958" style="zoom:50%;" />

果然，一看到这个我就想到堆了

## 3. 线索化二叉树 (Threaded Binary Tree)

![image-20201211205042253](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201211205042253.png)

看来是我不行，我还没有接触过这种的二叉树

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201211212035551.png" alt="image-20201211212035551" style="zoom:67%;" />

没错哈，的确是这样子的，这个公式，你拿纸画一下就直到了

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201211212851888.png" alt="image-20201211212851888" style="zoom:80%;" />

这个就实际上对链表二叉树的重新的利用，利用起空指针域，已经有指向的就不需要改变，没有的就要分别指向前驱和后继

### 1. 中序线索化二叉树的应用

这里就是怎么变为中序，怎么进行中序遍历的.

```java
package com.atguigu.tree.threadedbinarytree;

public class ThreadedBinaryTreeDemo {
    public static void main(String[] args) {
        //测试一把中序线索二叉树的功能是否正确
        HeroNode root = new HeroNode(1, "tom");
        HeroNode node2 = new HeroNode(3, "jack");
        HeroNode node3 = new HeroNode(6, "smith");
        HeroNode node4 = new HeroNode(8, "mary");
        HeroNode node5 = new HeroNode(10, "king");
        HeroNode node6 = new HeroNode(14, "dim");

        //二叉树后面我们要递归 创建,现在简单处理手动创建
        root.setLeft(node2);
        root.setRight(node3);
        node2.setLeft(node4);
        node2.setRight(node5);
        node3.setLeft(node6);

        ThreadedBinaryTree threadedBinaryTree = new ThreadedBinaryTree();
        threadedBinaryTree.setRoot(root);
        threadedBinaryTree.threadNotes();

        //以10号节点测试
        HeroNode leftNode = node5.getLeft();
        System.out.println(leftNode);
        System.out.println(node5.getRight());

        //当线索化二叉树后，不能再使用原来的遍历方法
        System.out.println("使用线索化的方式遍历线索化二叉树");
        threadedBinaryTree.threadList();
    }
}
//定义 ThreadedBinaryTree 实现了线索化功能的二叉树
class ThreadedBinaryTree{
    private HeroNode root;

    //为了实现线索化，需要创建要给指向当前节点的前驱节点的指针
    //在递归进行线索化时，pre总是保留前一个节点
    private HeroNode pre = null;

    public void setRoot(HeroNode root){
        this.root = root;

    }

    public void threadNotes(){
        this.threadedNotes(root);
    }

    //遍历线索化二叉树的方法,目前我的感受是这个过程是由leftType or rightType =1的节点去推动的，只有他们知道下一步往哪里走，所以相当于再找这种节点
    //这样子说的话就有些思路了
    public void threadList(){
        //定义一个变量，存储当前遍历的节点，从root开始
        HeroNode node = root;
        while (node != null){
            //循环找到leftType == 1的节点，第一个找到的时8这个节点
            //后面随着遍历而变化，因为当leftType==1时，说明该节点还是按照线索化
            //处理后的有效节点
            while (node.getLeftType() == 0){
                node = node.getLeft();
            }
            //打印当前节点
            System.out.println(node);
            //如果当前节点的右指针指向的时后继节点
            //怎么说呢，我觉得这里有些tricky,while是有必要的，因为有后继节点的话就代表一个结束，因为这里是中序遍历，所以你要把结束的赶快循环掉，
            //不然你这里改成if的话会造成循环出问题
            while (node.getRightType() == 1){
                node = node.getRight();
                System.out.println(node);
            }

            //替换遍历的节点
            node = node.getRight();
        }
    }
    //编写对二叉树进行中序线索化的方法
    public void threadedNotes(HeroNode node){
        //如果 node = null 就不能线索化
        if(node == null){
            return;
        }
        //1. 先线索化左子树
        threadedNotes(node.getLeft());
        //2.线索化当前节点[有点难度]
        //处理当前节点的前驱节点
        //8节点的.left = null，8节点的.leftType = 1
        if(node.getLeft() == null){
            //让当前节点的左指针指向前驱节点
            node.setLeft(pre);
            //修改当前节点的左指针类型,指向前驱节点
            node.setLeftType(1);
        }
        //处理后继节点
        if(pre != null && pre.getRight() == null){
            //让前驱节点的右指针指向当前节点
            pre.setRight(node);
            //修改前驱节点的右指针类型
            pre.setRightType(1);
        }
        //!!! 每处理一个节点后，让当前节点时下一个节点的前驱节点
        pre = node;
        //3.线索化右子树
        threadedNotes(node.getRight());
    }
    //递归删除节点
    //1.如果删除的节点是叶子节点，则删除该节点
    //2.如果删除的节点是非叶子节点，则删除该子树
    //这个删除不是很一样，就没那么好，是直接删除节点的
    public void delNode(int no){
        if(root != null){
            //如果只有一个root节点，立即判断
            if(root.getNo() == no){
                root = null;
            }else{
                root.delNode(no);
            }
        }else{
            System.out.println("空树不能删除");
        }
    }
    //怎么说呢，这里我有种奇怪的感觉，因为我之前学的是一个方法单独拿出来的，而不是放在结点的方法里，不过也可以把
    public void preOrder(){
        if(this.root != null){
            this.root.preOrder();
        }else{
            System.out.println("二叉树无法遍历");
        }
    }

    public void infixOrder(){
        if(this.root != null){
            this.root.infixOrder();
        }else{
            System.out.println("二叉树无法遍历");
        }
    }

    public void postOrder(){
        if(this.root != null){
            this.root.postOrder();
        }else{
            System.out.println("二叉树无法遍历");
        }
    }

    public HeroNode preOrderSearch(int no){
        if(root != null){
            return root.preOrderSearch(no);
        }else{
            return  null;
        }
    }

    public HeroNode infixOrderSearch(int no){
        if(root !=null){
            return root.infixOrderSearch(no);
        }else{
            return null;
        }
    }

    public HeroNode postOrderSearch(int no){
        if(root != null){
            return root.postOrderSearch(no);
        }else{
            return null;
        }
    }


}
class HeroNode{
    private int no;
    private String name;
    private HeroNode left;
    private HeroNode right;

    //说明:
    //1. 如果leftType == 0 表示指向的是左子树，如果 1 则表示指向前驱节点
    //2. 如果rightType == 0 表示指向的是右子树，如果1 则表示指向后继节点


    public int getLeftType() {
        return leftType;
    }

    public void setLeftType(int leftType) {
        this.leftType = leftType;
    }

    public int getRightType() {
        return rightType;
    }

    public void setRightType(int rightType) {
        this.rightType = rightType;
    }

    private int leftType;
    private int rightType;

    public HeroNode(int no, String name) {
        this.no = no;
        this.name = name;
    }

    public int getNo() {
        return no;
    }

    public void setNo(int no) {
        this.no = no;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public HeroNode getLeft() {
        return left;
    }

    public void setLeft(HeroNode left) {
        this.left = left;
    }

    public HeroNode getRight() {
        return right;
    }

    public void setRight(HeroNode right) {
        this.right = right;
    }

    @Override
    public String toString() {
        return "HeroNode{" +
                "no=" + no +
                ", name='" + name + '\'' +
                '}';
    }
    //递归删除节点
    public void delNode(int no){
        if(this.left != null && this.left.no == no){
            this.left = null;
            return;
        }
        if(this.right != null && this.right.no == no){
            this.right = null;
            return;
        }
        if(this.left != null){
            this.left.delNode(no);
        }
        if(this.right != null){
            this.right.delNode(no);
        }
    }
    //编写前序遍历
    public void preOrder(){
        System.out.println(this);

        if(this.left != null){
            this.left.preOrder();
        }
        if(this.right != null){
            this.right.preOrder();
        }
    }

    public void infixOrder(){
        if(this.left != null){
            this.left.infixOrder();
        }
        System.out.println(this);
        if(this.right != null){
            this.right.infixOrder();
        }
    }

    public void postOrder(){
        if(this.left != null){
            this.left.postOrder();
        }
        if(this.right != null){
            this.right.postOrder();
        }
        System.out.println(this);
    }

    //前序遍历查找
    public HeroNode preOrderSearch(int no){
        if(this.no == no){
            return this;
        }
        HeroNode resNode = null;
        if(this.left != null){
            resNode = this.left.preOrderSearch(no);
        }
        if(resNode != null){
            return resNode;
        }
        if(this.right != null){
            resNode = this.right.preOrderSearch(no);
        }
        return resNode;
    }

    //有一个问题是如果有多个节点的话怎么办
    public HeroNode infixOrderSearch(int no){
        HeroNode resNode = null;
        if(this.left != null){
            resNode = this.left.preOrderSearch(no);
        }
        if(resNode != null){
            return resNode;
        }
        if(this.no == no){
            return this;
        }
        if(this.right != null){
            resNode = this.right.preOrderSearch(no);
        }
        return resNode;
    }
    public HeroNode postOrderSearch(int no){
       HeroNode resNode = null;
        if(this.left != null){
            resNode = this.left.preOrderSearch(no);
        }
        if(resNode != null){
            return resNode;
        }
        if(this.right != null){
            resNode = this.right.preOrderSearch(no);
        }
        if(resNode != null){
            return  resNode;
        }
        if(this.no == no){
            return this;
        }
        return resNode;
    }
}
```

## 4. 堆排序 √

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201212211842726.png" alt="image-20201212211842726" style="zoom:67%;" />

其实这玩意我已经很熟了，而且这里我明白了为什么要用到数组，我觉得 是因为要频繁的交换node，所以不适合用链表就用起数组来了

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201212212332873.png" alt="image-20201212212332873" style="zoom:67%;" />

有趣的是它直接跳到了堆排序，而且和建堆混杂在一起，就很乱。

```java
package com.atguigu.tree;
import java.util.Arrays;
public class HeapSort {
    public static void main(String[] args) {
        //因为排完之后顺序是反的，所以的话要升序排就要大顶堆
        int[] arr = {4, 6, 8, 5, 9, -1, 90, 89, 56, -999};
        heapSort(arr);
    }

    //编写一个堆排序的方法
    public static void heapSort(int[] arr) {
        int temp = 0;
        adjustHeap(arr, 1, arr.length);
        //这里还有待理解，我觉得这样写不好，混在一起了
        //这个的确了，的确是拿到了最后一个非叶子节点，很棒了
        for (int i =  arr.length / 2 - 1; i >= 0 ; i--) {
            adjustHeap(arr, i, arr.length);
        }

        for (int i = arr.length - 1; i > 0 ; i--){
            //交换
            temp = arr[i];
            arr[i] = arr[0];
            arr[0] = temp;
            adjustHeap(arr,0 , i);
        }
        System.out.println(Arrays.toString(arr));
    }

    //将一个数组(二叉树),调整成一个大顶堆,heapify过程

    /**
     * @param arr    待调整的数组
     * @param i      非叶子节点在数组中的索引
     * @param length 表示对多少各元素继续调整，length 是在逐渐减少
     */
    public static void adjustHeap(int[] arr, int i, int length) {


        int temp = arr[i];//先取出当前元素的值，保存在临时变量
        //开始调整
        for (int k = i * 2 + 1; k < length; k = k * 2 + 1) {
            {
                if (k + 1 < length && arr[k] < arr[k + 1]) {
                    k++; //k指向右子节点
                }
                if (arr[k] > temp) {
                    //如果子节点大于父节点
                    //把较大的值赋给当前节点
                    arr[i] = arr[k];
                    i = k;//!!! i 指向k，继续循环比较
                } else {
                    break;//!
                }
            }
            //当for循环结束后，我们已经将以 i为父节点的树的最大值，放在了最顶(局部)
            arr[i] = temp;//将temp赋值放到调整后的位置
        }
    }
}
```

## 5. huffman tree (欠!!!)(121-126没看)没时间了

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201213194641323.png" alt="image-20201213194641323" style="zoom:67%;" />

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201213201610420.png" alt="image-20201213201610420" style="zoom:67%;" />

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201213202146665.png" alt="image-20201213202146665" style="zoom:67%;" />

噢。终于懂他是为什么这么排的了，就你需要前两个去凑成一个节点而已，没有什么的

### 代码实现

```java
package com.atguigu.huffmantree;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class HuffmanTree {
    public static void main(String[] args) {
        int[] arr = {13, 7, 8, 3, 29, 6, 1};
        Node huffmanTree = createHuffmanTree(arr);
        preOrder(huffmanTree);
    }

    public static void preOrder(Node root){
        if(root != null) {
            root.preOrder();
        }else {
            System.out.println("是空树，不能遍历");
        }
    }
    public static Node createHuffmanTree(int[] arr){
        //第一步为了方便
        //1. 遍历arr数组
        //2. 将arr的每个元素构成成一个Node
        //3. 将Node放入到ArrayList中
        List<Node> nodeList = new ArrayList<>();
        for (int value : arr){
            nodeList.add(new Node(value));
        }
        Collections.sort(nodeList);
        System.out.println(nodeList);

        //我们处理的过程时一个循环过程
        while (nodeList.size() > 1){
            Collections.sort(nodeList);
            //取出根节点权值最小的两颗二叉树
            //1.取出权值最小的节点(二叉树)
            Node left = nodeList.get(0);
            //2.取出第二小的节点
            Node right = nodeList.get(1);

            //3.构建一颗新的二叉树
            Node parent = new Node(left.value + right.value);
            parent.left = left;
            parent.right = right;

            //4.从ArrayList删除处理过的二叉树
            nodeList.remove(left);
            nodeList.remove(right);
            //将parent加入到nodes
            nodeList.add(parent);
        }

        //返回哈夫曼树的root节点
        return nodeList.get(0);
    }

}
//为了让Node 对象支持排序Collections集合排序
//让 Node实现Comparable接口
class Node implements Comparable<Node>{
    int value;//节点权值
    Node left;//指向左子节点
    Node right;//指向右子节点

    public void preOrder(){
        System.out.println(this);

        if(this.left != null){
            this.left.preOrder();
        }
        if(this.right != null){
            this.right.preOrder();
        }
    }

    public Node(int value){
        this.value = value;
    }

    @Override
    public String toString() {
        return "Node{" +
                "value=" + value +
                '}';
    }

    @Override
    public int compareTo(Node o) {
        //表示从小到大排
        return this.value - o.value;
    }
}
```

### 哈夫曼编码

是无损压缩,无精度损失

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201213211132398.png" alt="image-20201213211132398" style="zoom:67%;" />

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201213213606747.png" alt="image-20201213213606747" style="zoom:67%;" />

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201213213745338.png" alt="image-20201213213745338" style="zoom:67%;" />

```java
package com.atguigu.huffmancode;

import java.util.*;
//我觉得我对编码byte那里还是有些confused，后面再厘清一下吧
public class HuffmanCode {
    public static void main(String[] args) {
        String str = "i like like like java do you like a java";
        byte[] bytes = str.getBytes();
        System.out.println(Arrays.toString(bytes));
        List<Node> nodes = getNodes(bytes);
        System.out.println(nodes);
        Node huffmanTree = createHuffmanTree(nodes);
        huffmanTree.preOrder();

        //测试一把是否生成了对应的哈夫曼编码
        getCodes(huffmanTree);
        System.out.println(huffmanCodes);
        byte[] huffmanCodeBytes = zip(bytes, huffmanCodes);
        System.out.println(Arrays.toString(huffmanCodeBytes));

    }
    //编写一个方法，将字符串对应的byte[] 数组，通过生成的赫夫曼编码表，返回一个赫夫曼编码压缩后的byte[]

    /**
     * @param bytes 原始字符串对应的byte[]
     * @param huffmanCodes 生成的赫夫曼编码map
     * @return 返回赫夫曼编码处理后的byte[]
     * 返回的是字符串对应的byte[]数组,即8位一个byte，放入到huffmanCodeBytes
     * 他这里演示了一通，我大概是明白了？说实话我有认真学额，但是好像那里没有讲到的感觉
     * String strByte = "101010000";
     * System.out.println((byte)Integer.parseInt(strByte, 2));//-88
     * 我觉得意思就是你给byte的东西他会视为这不是你原来的码，而是你的补码，所以你输出的时候他会帮你转过去
     */
    private static byte[] zip(byte[] bytes, Map<Byte, String> huffmanCodes){

        //1. 利用huffmanCodes将bytes 转成赫夫曼编码对应的字符串
        StringBuilder stringBuilder = new StringBuilder();
        //遍历bytes 数组
        for (byte b : bytes){
            stringBuilder.append(huffmanCodes.get(b));
        }
        //我觉得还没完
        System.out.println("测试：" + stringBuilder.toString());
        //nb哈
       int len = (stringBuilder.length() + 7 ) / 8;
        //创建存储压缩后的byte数据
        byte[] huffmanCodeBytes = new byte[len];
        int index = 0;
        for (int i = 0; i < stringBuilder.length(); i += 8) {
            //因为是每8位对应一个byte，所以步长+8
            String strByte;
            if(i + 8 > stringBuilder.length()) {
                strByte = stringBuilder.substring(i);
            }else {
                strByte = stringBuilder.substring(i, i + 8);
            }
            //将strByte 转成一个byte,放入到huffmanCodeBytes
            huffmanCodeBytes[index] = (byte)Integer.parseInt(strByte, 2);
            index++;
        }

        return huffmanCodeBytes;
    }
    //生成赫夫曼树对应的赫夫曼编码
    //思路：
    //1. 将赫夫曼编码表存放在Map<yte,String> 形式
    static Map<Byte, String> huffmanCodes = new HashMap<>();
    //2. 在生成赫夫曼编码表时，需要去拼接路径，定义一个StringBuilder，存储某个叶子结点的路径
    static StringBuilder stringBuilder = new StringBuilder();

    //为了调用方便，我们重载getCodes
    private static Map<Byte, String> getCodes(Node root){
        if(root == null){
            return null;
        }
        getCodes(root.left, "0", stringBuilder);
        getCodes(root.right, "1", stringBuilder);
        return huffmanCodes;
    }

    /**
     * 功能：将传入 的node结点的所有叶子结点的赫夫曼编码得到，并放入到huffmanCodes集合
     * @param node 传入节点
     * @param code 路径:左子节点是0，右子结点1
     * @param builder 用于拼接路径
     */
    private static void getCodes(Node node, String code, StringBuilder builder){
        StringBuilder stringBuilder2 = new StringBuilder(builder);
        stringBuilder2.append(code);
        if(node != null){
            //不处理
            //判断当前node是叶子结点还是非叶子结点
            if(node.data == null){
                getCodes(node.left, "0", stringBuilder2);
                //向右递归
                getCodes(node.right, "1", stringBuilder2);
            }else{
                //表示找到某个叶子结点最后
                huffmanCodes.put(node.data, stringBuilder2.toString());
            }
        }
    }
    public static void preOrder(Node root){
        if(root != null){
            root.preOrder();
        }else{
            System.out.println("哈夫曼树为空");
        }
    }

    private static List<Node> getNodes(byte[] bytes){
        ArrayList<Node> nodes = new ArrayList<>();
        HashMap<Byte, Integer> counts = new HashMap<>();
        for (byte b: bytes){
            Integer count = counts.get(b);
            if(count == null){
                //Map还没有这个字符数据
                counts.put(b, 1);
            }else{
                counts.put(b, count + 1);
            }
        }
        //把每个键值对转成一个Node对象，并加入到nodes集合
        //遍历map
        for (Map.Entry<Byte, Integer> entry: counts.entrySet()){
            nodes.add(new Node(entry.getKey(), entry.getValue()));
        }
        return nodes;
    }

    private static Node createHuffmanTree(List<Node> nodes){
        while (nodes.size() > 1){
            Collections.sort(nodes);
            Node leftNode = nodes.get(0);
            Node rightNode = nodes.get(1);

            Node parent = new Node(null, leftNode.weight + rightNode.weight);
            parent.left = leftNode;
            parent.right = rightNode;

            nodes.remove(leftNode);
            nodes.remove(rightNode);
            nodes.add(parent);

        }
        //nodes 最后的结点，就是根结点
        return nodes.get(0);
    }
}

class Node implements Comparable<Node>{
    Byte data;//存放数据本身，比如 'a' => 97 ' ' => 32
    int weight;
    Node left;
    Node right;

    public Node(Byte data, int weight) {
        this.data = data;
        this.weight = weight;
    }

    @Override
    public int compareTo(Node o) {
        return this.weight - o.weight;
    }

    @Override
    public String toString() {
        return "Node{" +
                "data=" + data +
                ", weight=" + weight +
                '}';
    }

    //前序遍历
    public void preOrder(){
        System.out.println(this);
        if(this.left != null){
            this.left.preOrder();
        }
        if(this.right != null){
            this.right.preOrder();
        }
    }
}
```

## 6. BST

![image-20201215093506276](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201215093506276.png)

记住，我们不insert相同的值在BST中，这个用于查找的话会很快哈

```java
package com.atguigu.binarysorttree;

public class BinarySortTreeDemo {
    public static void main(String[] args) {
        int[] arr = {7, 3, 10, 12, 5, 1, 9};
        BinarySortTree binarySortTree = new BinarySortTree();
        for (int i = 0; i < arr.length ; i++) {
            binarySortTree.add(new Node(arr[i]));
        }
        System.out.println("中序遍历二叉排序树");
        binarySortTree.infixOrder();
       binarySortTree.delNode(2);
       binarySortTree.delNode(5);
       binarySortTree.delNode(9);
       binarySortTree.delNode(12);
       binarySortTree.delNode(7);
       binarySortTree.delNode(3);
        System.out.println();
        binarySortTree.infixOrder();
        binarySortTree.delNode(10);
        System.out.println(binarySortTree.getRoot());;
    }
}
//创建二叉排序树
class BinarySortTree{
    private Node root;

    public Node getRoot() {
        return root;
    }

    public Node search(int value){
        if(root == null){
            return null;
        } else{
            return root.search(value);
        }
    }

    public Node searchParent(int value){
        if(root == null){
            return null;
        } else{
            return root.searchParent(value);
        }
    }

    /**
     * @param node 传入的结点(当做二叉排序树的根节点)
     * @return 返回以node 为根节点的二叉排序树的最小结点值
     */
    public int delRightTreeMin(Node node){
        Node target = node;
        //循环的查找左节点，就
        while (target.left != null){
            target = target.left;
        }
        delNode(target.value);
        return target.value;

    }
    public void delNode(int value){
        if(root == null){
            return;
        }else{
            Node targetNode = search(value);
            if(targetNode == null){
                return;
            }
            //如果我们发现targetNode 没有父结点
            if(root.left == null && root.right == null){
                root = null;
                return;
            }
            //去找到targetNode的父节点
            Node parent = searchParent(value);
            //如果要删除的结点时叶子结点
            if(targetNode.left == null && targetNode.right == null) {
                if (parent.left != null && parent.left.value == value) {
                    parent.left = null;
                } else if(parent.right != null && parent.right.value == value){
                    parent.right = null;
                }
            } else if(targetNode.left != null && targetNode.right != null){
                int minVal = delRightTreeMin(targetNode.right);
                targetNode.value = minVal;
            } else{
               //删除只有一颗子树的结点
               //如果要删除的结点有左子节点
               if(targetNode.left != null){
                   if(parent != null) {
                       if (parent.left.value == value) {
                           parent.left = targetNode.left;
                       } else {
                           parent.right = targetNode.left;
                       }
                   } else{
                       root = targetNode.left;
                   }
               } else{
                   if(parent != null) {
                       if (parent.left.value == value) {
                           parent.left = targetNode.right;
                       } else {
                           parent.right = targetNode.right;
                       }
                   } else{
                       root = targetNode.right;
                   }
               }
            }
        }
    }
    public void add(Node node){
        if(root == null){
            root = node;
        }else{
            root.add(node);
        }
    }

    public void infixOrder(){
        if(root != null){
            root.infixOrder();
        }else{
            System.out.println("二叉排序树不能遍历，为空");
        }
    }
}
class Node{
    int value;
    Node left;
    Node right;

    /**
     * @param value 希望删除的节点的值
     * @return 如果找到返回该节点，否则返回null
     */
    //查找要删除的节点
    public Node search(int value){
        if(value == this.value){
            return this;
        } else if(value < this.value){
            if(this.left == null){
                return null;
            }
            return this.left.search(value);
        } else {
            if(this.right == null){
                return null;
            }
            return this.right.search(value);
        }
    }

    /**
     * @param value 要找到的结点的值
     * @return 返回的是要删除的节点的父节点，如果没有就返回null
     */
    //查找要删除节点的父节点
    public Node searchParent(int value){
        if((this.left != null && this.left.value == value) ||
                (this.right != null && this.right.value == value)){
            return this;
        } else{
            //如果查找的值雄安与当前节点的值，并且当前节点的左子结点不为空
            if(value < this.value && this.left != null){
                return this.left.searchParent(value);
            }else if( value >= this.value && this.right != null){
                return this.right.searchParent(value);
            }else{
                //没有父节点
                return null;
            }
        }
    }

    @Override
    public String toString() {
        return "Node{" +
                "value=" + value +
                '}';
    }

    public Node(int value) {
        this.value = value;
    }

    public void add(Node node){
        if(node == null){
            return;
        }
        if(node.value < this.value){
            if(this.left == null){
                this.left = node;
            }else{
                this.left.add(node);
            }
        } else{
            if(this.right == null){
                this.right = node;
            }else{
                this.right.add(node);
            }
        }
    }

    public void infixOrder(){
        if(this.left != null){
            this.left.infixOrder();
        }
        System.out.println(this);
        if(this.right != null){
            this.right.infixOrder();
        }
    }
}
```

## 7. AVL 平衡二叉树

引入这个的是用BST引入的，就有些缺点

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201215205115902.png" alt="image-20201215205115902" style="zoom:67%;" />

你寻找用的时间是根据你如何insert的，你左右边两种insert的方法就depends，不稳定，有时候块有时候慢

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201215210043434.png" alt="image-20201215210043434" style="zoom:67%;" />

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201215210432911.png" alt="image-20201215210432911" style="zoom:67%;" />

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201215210721986.png" alt="image-20201215210721986" style="zoom:67%;" />

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201215211030410.png" alt="image-20201215211030410" style="zoom:67%;" />

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201215211708381.png" alt="image-20201215211708381" style="zoom:67%;" />

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201215212237175.png" alt="image-20201215212237175" style="zoom:67%;" />

最后一个是真的牛逼哈，非常直观了

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201215212453861.png" alt="image-20201215212453861" style="zoom:67%;" />

这个非常nb了，本来是要两步的，这里直接化为一步了把C变成root结点，然后把原来的root放到C右边

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201215213040258.png" alt="image-20201215213040258" style="zoom:67%;" />

这个呢就告诉了你一个formula，把C移上去之后他的子树是需要解决的，那么左子树仍然在左子树这边，但是就变成了右子树，另外一个同理

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201215214352298.png" alt="image-20201215214352298" style="zoom:67%;" />

这里又是一个nb的例子哈，就当你插入22的时候你会想欸，这不是RLL吗，有三个了，但我们不取三个数字哈，只取两个，所以最后一个L被划掉了，所以他就按照RL来转，然后22这个的话就还是老规矩

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201215215423724.png" alt="image-20201215215423724" style="zoom:67%;" />

great！

### 尚硅谷的

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201215221839687.png" alt="image-20201215221839687" style="zoom:67%;" />

老听红黑树红黑树，原来就是这里

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201215222448635.png" alt="image-20201215222448635" style="zoom:67%;" />

果然应该先听一会油管的，不然按他这样听不懂哈

#### 双向旋转

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201216104754486.png" alt="image-20201216104754486" style="zoom:67%;" />

## 8. B 树 √

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201216115440358.png" alt="image-20201216115440358" style="zoom:67%;" />

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201216160720318.png" alt="image-20201216160720318" style="zoom:67%;" />

他说的是如何读取数据，数据的话要被加载到memory里面，program才能读，读完之后再写回去

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201216161422092.png" alt="image-20201216161422092" style="zoom:67%;" />

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201216161837866.png" alt="image-20201216161837866" style="zoom:67%;" />

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201216162530410.png" alt="image-20201216162530410" style="zoom:67%;" />

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201216175757627.png" alt="image-20201216175757627" style="zoom:67%;" />

we want self-managing ,可以自动增加和扩容的，你这个就像一个tree了

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201216180219198.png" alt="image-20201216180219198" style="zoom:67%;" />



<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201216181320534.png" alt="image-20201216181320534" style="zoom:67%;" />

B Tree就是M way search tree with some nodes

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201216190729434.png" alt="image-20201216190729434" style="zoom:67%;" />

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201216191644196.png" alt="image-20201216191644196" style="zoom:67%;" />

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201216191625521.png" alt="image-20201216191625521" style="zoom:67%;" />

split后的基本是按照这个流程把

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201216192057547.png" alt="image-20201216192057547" style="zoom:67%;" />

这个是split，现在发现的共同点就是split后的第二个只有一个元素，倒数第二个成为root，前两个到新的里面去，其实你也不一定是倒数第二个，第二个也是可以的，就是bias不同，用现在的倒数第二个的话就更多结点会在两边。

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201216192337024.png" alt="image-20201216192337024" style="zoom:67%;" />

split完之后的结果

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201216192903479.png" alt="image-20201216192903479" style="zoom:67%;" />

现在好像要move一个结点到根节点这里，但是根节点好像不够了怎么办。

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201216193051766.png" alt="image-20201216193051766" style="zoom:67%;" />

那就再分，终于懂为什么是bottom up 了

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201216193500221.png" alt="image-20201216193500221" style="zoom:67%;" />

这里的箭头指向的是record pointer，你对应指向的谁，所以每个结点的话真的可以有很多的值

### B+ ?

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201216194907853.png" alt="image-20201216194907853" style="zoom:67%;" />

不像B树，这个不会每个都会指向一个record pointer，而是leaf node去指，那其他的怎么办呢？那就每个都copy一份到叶子结点这里，然后最后形成一个链表像这样，而且他说这个更像一个multi indexing，但为啥我不懂啊，我不懂的原因是我不知道他这个record pointer到底指的是什么东西啊，他的指向和子节点的指向有啥区别？我觉得晚上我需要再看一遍哈

--------------------------------------------------------------------------------------------------------------------------------------------------------------

我好像懂了，因为重新看了视频，说一下，这个怎么对应到multi-index的，最开始画的index表地址指向的的确是每列的数据，但是这样可以少访问block，因为数据变少了，每轮可以存的数据就变多了，原先一个block存了4条数据，所以100行数据要25个block，用了index表之后，一个block可以存32行数据，所以你要去找每条数据的时候，只用最多访问4个block把好像，index那里有三个block，然后table那里就一个block，这时候提出疑问，如果你的数据不是100，而是1000呢，那你的index表数据还是很多，那怎么减少呢？你就可以再做一个index表去指向原先的index表，这时候你新增的index表时指向的内容不同了，具体为每个block，而不是具体的数据了。具体的数据应该是最后一个index表才有的。

接下来解决的是record pointer和子父类这些指向的是什么？ 每个node都有value，所以对应的是一个个id号，还有对应的record pointer，指向的是等会，我觉得是像最后一个index一样去指向那个表，就像上图中的15表示就是15序号的employ的数据，没错！这就是为什么说B+树更像是multi-indexing，这个是要搞到最后的，而且每个值在最后都有，最后形成一个链表的样子刚好对应的是每个block。而B树的话我觉得是直接跳过去把？拿到地址就跑。感觉效率的话会更高点？

## 插播 中序遍历非递归

6-27

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201216134837111.png" alt="image-20201216134837111" style="zoom:67%;" />

```c
void InOrder(TriTree PT, void (*visit)(TElemType))
/* 不使用栈，非递归中序遍历二叉树PT，  */
/* 对每个结点的元素域data调用函数visit */
{
       TriTree p = PT;
      while(p){
        if(p->lchild){
            p = p->lchild;
            continue;
        }
        visit(p->data);
        if(p->rchild){
            p = p->rchild;
            continue;
        }
        TriTree pTemp;
        while(p->parent){
            pTemp = p->parent;
            if(pTemp->rchild){
                if(pTemp->rchild == p){
                  p = pTemp;
                  continue;
               }else{
                visit(pTemp->data);
                p = pTemp->rchild;
                break;
               }               
            }else{
               visit(pTemp->data);
               p = pTemp;
               continue;
            }
        }
        if(!p->parent){
            break;
        }
      }
}
```

## 9. 多叉树

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201217212833117.png" alt="image-20201217212833117" style="zoom:67%;" />

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201217213219865.png" alt="image-20201217213219865" style="zoom:67%;" />

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201217213526438.png" alt="image-20201217213526438" style="zoom:67%;" />

我看了下~~，这里的规则好像和上面讲的不是很一样，主要体现在结点这里，他们没有限制，只要大于M/2就可以了，M指的是最多children的个数，但是这里有限制~~

并不，其实还是和上面的一样，只不过这里把规则给你说出来了而已，上面是自然而然地这样做出来的

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201217214114028.png" alt="image-20201217214114028" style="zoom:80%;" />

我自己推了一遍，写出来啦，哈哈，印度人，，永远的神！！

## B树(尚硅谷版)

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201217220415557.png" alt="image-20201217220415557" style="zoom:80%;" />

这里就是有些名词要去记住,比如说这个阶，就是最多的结点数啦，其他的我感觉我就已经知道了，但是感觉这里前面还是少了一些东西，record pointer他没有，我觉得他应该有的，不然讲到B+树的话就会有些懵逼

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201217221019059.png" alt="image-20201217221019059" style="zoom: 80%;" />

没错啦！所有的都放在最后来！最后的才是真正的数据，但是B树的话最后不是真正的数据

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201217221702932.png" alt="image-20201217221702932" style="zoom:80%;" />

没想到还有B*这种东西，我就是冲着代码来的，然后他跟我说无代码 

# 11. 图

图的表示方法分为两种：二维数组表示(邻接矩阵)；链表表示(领接表)

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201227154656795.png" alt="image-20201227154656795" style="zoom:67%;" />

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201227154833048.png" alt="image-20201227154833048" style="zoom:67%;" />

的确是哈

![image-20201227164028206](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201227164028206.png)

不如看这个图吧

![image-20201227164152190](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201227164152190.png)

的确是，我也有这个感觉哈

![image-20201227164822273](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201227164822273.png)

其实dfs是应该用栈的，我个人觉得会比递归好，而且感觉蛮多时候都不会去用递归，因为太占空间啦

## 1. DFS

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201227161425038.png" alt="image-20201227161425038" style="zoom:67%;" />

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201227161946552.png" alt="image-20201227161946552" style="zoom:67%;" />

老师这里是用递归做的，但我觉得还可以用栈做的话会比较好一点



## 2. BFS

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20201227190708532.png" alt="image-20201227190708532" style="zoom:67%;" />

这个挺好理解的把

## 3. 代码实现

```java
package com.atguigu.graph;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;

public class Graph {

    private ArrayList<String> vertexList; //存储顶点的集合
    private int[][] edges;// 存储图对应的邻接矩阵
    private int numOfEdges; //表示边的数目
    //定义一个数组boolean[],记录某个结点是否被访问过
    private boolean[] isVisited;
    public static void main(String[] args) {

        //测试一把图是否创建ok
        int n = 8;
//        String[] vertexValue = {"A", "B", "C", "D", "E"};
        String[] vertexValue = {"1", "2", "3", "4", "5", "6", "7", "8"};
        Graph graph = new Graph(n);
        //循环添加顶点
        for (String value : vertexValue){
            graph.insertVertex(value);
        }
        //添加边
        //A-B B-C B-D B-E
//        graph.insertEdge(0 , 1, 1);
//        graph.insertEdge(0 , 2, 1);
//        graph.insertEdge(1 , 2, 1);
//        graph.insertEdge(1 , 3, 1);
//        graph.insertEdge(1 , 4, 1);
        graph.insertEdge(0, 1, 1);
        graph.insertEdge(0, 2, 1);
        graph.insertEdge(1, 3, 1);
        graph.insertEdge(1, 4, 1);
        graph.insertEdge(3, 7, 1);
        graph.insertEdge(4, 7, 1);
        graph.insertEdge(2, 5, 1);
        graph.insertEdge(2, 6, 1);
        graph.insertEdge(5, 6, 1);

        graph.showGraph();

        System.out.println("深度遍历");
//        graph.dfs();
        graph.bfs();
    }

    //构造器
    public  Graph(int n){
        //初始化矩阵和vertexList
        edges = new int[n][n];
        vertexList = new ArrayList<>(n);
        numOfEdges = 0;
        isVisited = new boolean[n];
    }

    /**
     * @param index
     * @return 如果存在就返回对应的下标，否则返回-1
     */
    //得到第一个邻接结点的下标w
    public int getFirstNeighbor(int index){
        for (int j = 0; j < vertexList.size(); j++){
            if(edges[index][j] > 0){
                return j;
            }
        }
        return -1;
    }
    //深度优先遍历算法
    private void dfs(boolean[] isVisited, int i){
        System.out.print(getValueByIndex(i) + "->");
        //将该结点设置为已经访问
        isVisited[i] = true;
        int w = getFirstNeighbor(i);
        while (w != -1){
            if(!isVisited[w]){
                dfs(isVisited, w);
            }
            //如果w结点已经被访问过
             w = getNextNeighbor(i, w);
        }
    }
    //对dfs，进行一个重载,遍历我们所有的结点，并进行dfs
    public void dfs(){
        //遍历所有的结点，进行dfs[回溯]
        for (int i = 0; i < getNumOfVertex(); i++){
            if(!isVisited[i]){
                dfs(isVisited, i);
            }
        }
    }

    //根据前一个邻接结点的下标来获取下一个邻接结点
    public int getNextNeighbor(int v1, int v2){
        for (int j = v2 + 1; j < vertexList.size(); j++){
            if(edges[v1][j] > 0){
                return j;
            }
        }
        return -1;
    }
    //对一个结点进行广度优先遍历的方法
    private void bfs(boolean[] isVisited, int i){
        int u; // 队列的头结点对应的下标
        int w; //邻接结点w
        //队列,记录结点的访问顺序
        LinkedList<Object> queue = new LinkedList<>();
        //访问结点，输出结点的信息
        System.out.println(getValueByIndex(i) + "=>");
        //标记已访问
        isVisited[i] = true;
        queue.addLast(i);
        while(!queue.isEmpty()){
            //取出队列的头结点下标
             u = (Integer) queue.removeFirst();

             w = getFirstNeighbor(u);
             while (w != -1){
                 if(!isVisited[w]){
                     System.out.print(getValueByIndex(w) + "=>");
                     isVisited[w] = true;
                     //入队
                     queue.addLast(w);
                 }
                 //以u为前驱点，找w后面的下一个邻结点
                 w = getNextNeighbor(u, w);
             }
        }
    }
    //遍历所有的结点，都进行广度优先搜索
    public void bfs(){
        for (int i = 0; i< getNumOfVertex(); i++){
            if(!isVisited[i]){
                bfs(isVisited,i);
            }
        }
    }
    //图中常用单方法
    //返回结点的个数
    public int getNumOfVertex(){
        return vertexList.size();
    }
    //显示图对应的矩阵
    public void showGraph(){
        for (int[] link: edges){
            System.out.println(Arrays.toString(link));
        }
    }
    //得到边的数目
    public int getNumOfEdges(){
        return numOfEdges;
    }
    //返回结点i(下标)对应的数据
    public String getValueByIndex(int i){
        return vertexList.get(i);
    }
    public int getWeight(int v1, int v2){
        return edges[v1][v2];
    }
    //插入结点
    public void insertVertex(String vertex){
        vertexList.add(vertex);
    }

    /**
     * @param v1 表示点的下标即第几个顶点 "A"-"B" "A"->0 "B"->1
     * @param v2 第二个顶点对应的下标
     * @param weight
     */
    //添加边
    public void insertEdge(int v1, int v2, int weight){
        edges[v1][v2] = weight;
        edges[v2][v1] = weight;
        numOfEdges++;
    }

}
```

## 4. Dijkstra 算法

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20210111203254061.png" alt="image-20210111203254061" style="zoom:67%;" />

找最短路径把，不过是点对点找的，如果某条路径大于直接的话就可以更新哈，所以和Prime 等等的区别就是他们是直接找全程最短，但是你这个是找某个点到别的点距离最短，并且会全程更新的

之后就是再挑一个点下去，挑权重小的，接着便是再更新周围的路径

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20210111203804965.png" alt="image-20210111203804965" style="zoom:67%;" />

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20210111203922825.png" alt="image-20210111203922825" style="zoom:67%;" />



学这个很有趣就是我老忘记啊

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20210111204133183.png" alt="image-20210111204133183" style="zoom:67%;" />

time complexity 是n^n啊，这个就像是高德地图一样，实时定位你在那个点，然后用算法马上算出来

## 5. topo sort

你可以想象一个场景，就是引包的时候，一个包依赖另外一个包，那你就不知道引哪个包好，反正你要最后能引出来某个包，而不是引这个包需要那个包，那个包需要这个包的情况，这样的话有环，意味着你这个排序方法就不对了

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20210111205825302.png" alt="image-20210111205825302" style="zoom: 67%;" />

他这个就是随机选一个点，然后往下找，当一个包没有别的依赖的时候就可以引进来了，这个找其实就是看你要引E包，你还需要引的包的顺序哈，然后可以搞一个最终的顺序，就是把A拿出来