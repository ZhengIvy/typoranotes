## 多线程

## 1. 单核CPU和多核CPU的理解

> 单核CPU，就是一种假的多线程，因为在一个时间单元内，也只能执行一个线程的任务。也就是时间片，把一分钟分为6片，10s给一个，10s再给另外一个，10s再给别的，所以看起来像是同一时间在做多个任务罢了。
>
> **一个Java应用程序java.exe，其实至少三个线程，main()主线程，gc()垃圾回收线程，异常处理线程。当然如果发生异常，会影响主线程**
>
> **并行**：多个CPU同时执行多个任务。真正的多线程
>
> **并发**： 一个CPU执行（采用时间片）同时执行多个任务，比如：秒杀，多人同时做一件事，实际上是上面的单核把。

## 2.多线程的优点

> 以单核CPU为例，只使用单个线程先后完成多个任务（调用多个方法），肯定比用多个线程来完成用的时间更短（注意是单核CPU，所以是假的多线程，切换是需要时间的）
>
> 多核CPU那可能就不一样了，不需要进行切换，增加时间（可能我们经常遇到的是单核？）

多线程的优点：

1. 提高应用程序的响应。对图形化界面更有意义，可增强用户体验。
2. 提高计算机系统CPU的利用率。
3. 改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解与修改。（独立起来）

何时需要多线程：

1. 程序同时执行两个或多个任务时候（个人觉得这个是本质，可以解释后面的）
2. 程序需要实现一些需要等待的任务时，如用户输入，文件读写，网络操作等。

> 这个拿美团外卖举个例子，你往下滑商品的时候，有加载文本的也有加载图片的，这两个是不同的线程，如果是单线程的话，就容易造成你加载完文本了，你图片还没加载完，就很慢，但有时候网卡的时候也会出现这种现象。

3. 需要一些后台运行的程序时

## 3. 创建多线程方式1

> 多线程的创建，方式一：继承Thread类
>
> 1. 创建一个继承于Thread类的子类
> 2. 重写Thread类的run（）
> 3. 创建Thread类的子类的对象
> 4. 通过此对象调用start（）
>
> （感觉有一些印象了。。。）

```java
class ThreadTest extends Thread{
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            if(i % 2 == 0){
                System.out.println(i);
            }
        }
    }
}
public class Thread1 {
    public static void main(String[] args){
        ThreadTest threadTest = new ThreadTest();//pvsm的主线程搞的
        
        threadTest.start();//进入到了另外一个线程当中去
        
        System.out.println("hello");

    }
}

```

> 有一个点，为什么调用start()这里就是多线程了呢？，直接调用run()会出现什么结果？直接调用run() 的话其实就相当于单线程了，相当只是调用 了一个放法而已，如果是start的话，感觉开辟了一个新的线程了，开始干别的活了
>
> start（）：1. 启动当前线程 2.调用当前线程的run（）
>
> 而且，start()只能执行一次

**更加简洁的一种方式：匿名子类噢**（话说和匿名内部类有什么区别来着？/???明天看看）

```java
//创建Thread类的匿名子类的方式
public class Thread1 {
    public static void main(String[] args){

        new ThreadTest(){
            @Override
            public void run() {
                for (int i = 0; i < 100; i++) {
                    if(i % 2 == 0){
                        System.out.println(Thread.currentThread().getName()+"--->"+i);
                    }
                }
            }
        }.start();
        System.out.println("hello");
        for (int i = 0; i < 100; i++) {
            if(i % 2 == 0){
                System.out.println(i+"************main()*********");
            }
        }
    }
```

 测试Thread中常用的方法：

1. `start（）`：启动当前线程；调用当前线程的run（）
2. `run（）`：通过需要重写的Thread类中的此方法，将创建的线程要执行的操作声明在此方法中
3. `currentThread()`: 静态方法，返回执行当前代码的线程
4. `getName()`:获取当前线程的名字
5. `setName()`:设置当前线程的名字
6. `yield()`:释放当前CPU执行权
7.  `join()`：在线程a中调用线程b的join（），此时线程a就进入阻塞状态，直到线程b完全执行完以后，线程a才结束阻塞状态
8. `stop()`：已过时，当执行此方法，强制结束当前线程
9. `sleep(long millitime)`:
10. `isAlive()`:判断当前线程是否存活

#### a. 命名的另外一种方法，通过构造器传参进行

```java
class ThreadTest extends Thread{
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            if(i % 2 == 0){
                System.out.println(i);
            }
        }
    }
    public ThreadTest(String name){
        super(name);
    }
}
```

![image-20200723111426290](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200723111426290.png)

#### b. 不应该他通过类实例访问静态成员？ 这什么意思呀

这是在哪里发生的？因为在视频中用到了`this.yield()`，但idea显示了![image-20200723113642065](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200723113642065.png)

所以。。。 待解决

```java
 @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            if (i % 2 == 0) {
                System.out.println(ThreadTest.currentThread().getName()+""+i);
            }
            if (i % 20 == 0) {
                yield();//作用是释放当前CPU执行权，意思是到这我就不执行了，先让别的来吧，但是有可能还是自己，因为我放弃了另外的线程还是抢不过
            }
        }
    }
    public ThreadTest(String name){
        super(name);
    }
```

#### c. join 与yield 的区别

> join是我放弃了，然后你上，等你做完了，我再上
>
> yield是我放弃了，但是我不给你，我们再公平竞争

在使用的地点不同，join在别的线程里面使用，yield在自己，因为yield是已经拿到机会，但是放弃了，然后重新竞争

## 4. 线程的调度

调度策略：时间片

抢占式：高优先级线程抢占CPU

Java的调度方法

- 同优先级线程组先进先出队列（先到先服务），使用时间片策略
- 对高优先级，使用游戏那调度的抢占式策略

> 线程的优先级
>
> `MAX_PRIORITY`:10
>
> `MIN_PRIORITY`:1
>
> `NORMAL_PRIORITY`:5 默认值

#### b. 如何获取和设置当前线程的优先级

`getPriority():获取线程的优先级`

`setPriority(int p):设置线程的优先级`

说明：高优先级的线程要抢占优先级线程cpu的执行权、但只是从概率上讲，高优先级的线程高概率的情况下被执行，并不意味着只有当高优先级的线程执行完后，低优先级的线程才执行。

```java
class ThreadTest extends Thread{
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            if (i % 2 == 0) {
                System.out.println(ThreadTest.currentThread().getName()+":"+ThreadTest.currentThread().getPriority()+":"+i);
            }
            if (i % 20 == 0) {
                yield();
            }
        }
    }

    public ThreadTest(String name){
        super(name);
        this.setPriority(Thread.MAX_PRIORITY);//你可以在这里设置优先级，也可以在下面设置优先级
    }
}

/**
 *
 */
//创建Thread类的匿名子类的方式
public class Thread1 {
    public static void main(String[] args){
        ThreadTest threadTest = new ThreadTest("Thread-1");
//       threadTest.setPriority(Thread.MAX_PRIORITY); 这里也是可以 的
        threadTest.start();

        System.out.println("hello");



        for (int i = 0; i < 100; i++) {
            if(i % 2 == 0){
                System.out.println(ThreadTest.currentThread().getName()+":"+ThreadTest.currentThread().getPriority()+":"+i);
            }
            if(i == 20){
                try {
                    threadTest.join();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}

```

#### 例题：窗口卖票

> 首先有三个窗口进行卖票，~~他说到票数那里用static，不然的话变成三个窗口都卖一百张票了，这样就不是很好，但问题是static的共享也不是这样的把，反正我试了照样三个窗口都卖一百张~~，不不不，还是有改进的，之前是三张窗口相当于各卖各的，数字会重复出现。
>
> 加上static之后的确是有共享的，所以我对static还是了解不够吧，**加深一下，不然之前说的一个公司同个boss不用static也可以显示出来，那static就完全没那么必要了，所以还是可以在不同对象之间共享数据的**

![image-20200723205525680](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200723205525680.png)

```java
class Window extends Thread{
    private  int ticket = 100;//正确操作 private static int ticket = 100;

    @Override
    public void run() {
        while(true){
            if(ticket > 0){
                System.out.println(getName() + ":卖票，票号为： " + ticket);
                ticket--;
            }else{
                break;
            }
        }
    }
}
public class WindowTest {
    public static void main(String[] args) {
        Window t1 = new Window();
        Window t2 = new Window();
        Window t3 = new Window();


        t1.setName("窗口1");
        t2.setName("窗口2");
        t3.setName("窗口3");

        t1.start();
        t2.start();
        t3.start();
    }
}

```

> 加上static之后，基本不出现重复卖票的情况，但还是有线程不安全的问题

![image-20200723211008360](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200723211008360.png)

看三个一百，这个后面讲到再解决,还有关于98 99 这种错位的情况不用太担心，还是99先，只不过是输出快慢的问题，输出了慢点

## 5.创造多线程的方式2

实现Runnable接口

1. 创建一个实现了Runnable接口的类
2. 实现类去实现Runnable中的抽象方法：run（）
3. 创建实现类的对象
4. 将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象
5. 通过Thread类的对象调用start（）

```java
//1. 创建一个实现了Runnable接口的类
//2. 实现类去实现Runnable中的抽象方法：run（）
//3. 创建实现类的对象
//4. 将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象
//5. 通过Thread类的对象调用start（）
class MThread implements Runnable{

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            if(i % 2 == 0){
                System.out.println(Thread.currentThread().getName()+":" + i);
            }
        }
    }
}

/**
 *
 */
public class ThreadTest1 {
    public static void main(String[] args) {
        MThread mThread = new MThread();
        Thread t1 = new Thread(mThread);
        t1.setName("线程1");
        t1.start();

        Thread t2 = new Thread(mThread);
        t2.setName("线程2");
        t2.start();
    }

}

```

难吗？其实不难，理解起来也蛮有趣的

首先要理解run到底是什么，runnable又是什么，看源码

![image-20200723220903644](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200723220903644.png)

![image-20200723220921846](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200723220921846.png)

![image-20200723221246749](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200723221246749.png)

> 从run（）来剖析，实际上是`target`执行的run，target又是什么？ 是`Runnable`，感觉差不多了吧，所以实际上起作用的是`Runnable`,所以你要么直接继承`Thread`类直接重写`Thread`里面的`Runnable`，要么就自己写一个`Runnable`放到Thread里面，看这个构造器是允许的，所以基本上就ok啦，挺有趣的

#### 为什么这里讲到Runnable？

在视频开始时，讲`Runnable`提到了一点，不用用到static去实现窗口卖票。

```java
class Window1 implements Runnable{
        private int ticket = 100;//没有static
    @Override
    public void run() {
        while(true){
            if(ticket > 0){
                System.out.println(Thread.currentThread().getName()+"：卖票，票号为: "+ticket);
                ticket--;
            }else{
                break;
            }
        }
    }
}
public class WindowTest1 {
    public static void main(String[] args) {
        Window1 window = new Window1();
        Thread t1 = new Thread(window,"窗口1");
        Thread t2 = new Thread(window,"窗口2");
        Thread t3 = new Thread(window,"窗口3");

        t1.start();
        t2.start();
        t3.start();
    }
}

```

> 为啥不需要，因为他们共用一个接口。所以这个很有趣把

## 两种创建多线程方式的比较

|                         继承                         | 实现接口Runnable |
| :--------------------------------------------------: | :--------------: |
| 单继承限制，如果使用的话就不能继承别的类，局限性太大 |   可以灵活使用   |
|                      需要static                      |   不需要static   |

总的来说，Runnable更好

![image-20200724120212880](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200724120212880.png)

## 6.线程的生命周期

> 新建：当一个Thread类或者其子类的对象被声明并创建时，新生的线程对象处于新建状态
>
> 就绪：处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时他已具备了运行的条件，只是没分配到CPU资源
>
> 运行：当就绪的线程被调度并获得CPU资源时，便进入运行状态，run()方法定义了线程的操作和功能
>
> 阻塞：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出CPU并临时停止自己的执行，进行阻塞状态
>
> 死亡：线程完成了他的全部工作或线程被提前强制性地终止或异常导致结束(最终状态)

## ![](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200724164306850.png)

## 7.线程的同步

问题的提出：

- 多个线程执行的不确定性引起执行结果的不稳定
- 多个线程对账本的共享会造成操作的不完整，会破坏数据

**本质在于共享**

> 比如去银行取钱，有人跟你共用一张卡，你卡里only 3000，但你们同时取了钱，在进行操作的时候由于账户上都是大于你要取的钱的，所以就允许你进入，但是同时取完后才发现诶，取了4000块，那这就不安全了。
>
> 为什么叫同步呢？也许解决的是同步的问题，使线程进行同步操作，观察对方实时状态，应该是这样子吧

还有窗口卖票，三个窗口都有100显示

而且`Thread,sleep(100)`可能会使线程不安全的概率增加，大大的那种

![image-20200724171130887](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200724171130887.png)

![image-20200724171803821](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200724171803821.png)

基本上是这个，因为呢你被阻塞了下，别人就更有几率进来了。

>例子：创建三个窗口卖票，总票数为100张，使用实现Runnable接口的方式
>
>1. 问题：卖票过程中，出现了重票、错票-->出现了线程的安全问题
>2. 问题出现的原因：当某个线程操作车票的过程中，尚未操作完成时，其他线程参与进来，也操作车票
>3. 如何解决：当一个线程a在操作ticket时，其他线程不能参与进来，直到线程a操作完成时，其他线程才可以操作ticket，这种情况即使线程a出现了阻塞，也不能被改变。
>
>就像你厕所安把锁呗

**解决方法**：

- 好处：同步的方式，解决了线程的安全问题
- 局限性：操作同步代码时，只能有一个线程参与，其他线程等待，相当于一个单线程的过程，效率低。

### **方式一**：同步代码块

> `synchronized(同步监视器){`

> //需要被同步的代码

> `}`
>
> 说明：1. 操作共享数据的代码，即为需要被同步的代码
>
> 2. 共享数据：多个线程共同操作的变量。比如：ticket就是共享数据
> 3. 同步监视器，俗称：锁。任何一个类的对象，都可以充当锁。
>
> 要求：多个线程需要共用同一把锁
>
> 补充：在实现Runnable接口创建多线程的方式中，我们可以考虑使用this充当同步监视器
>
> 在继承Thread类创建多线程的方式中，慎用this充当同步监视器，考虑使用当前类充当同步监视器。
>
> (其实要求同一把锁可当做厕所的灯，大家都看到绿灯无人，红灯有人，都是同一种标识，所以就是同一把锁)
>
> **注意：不能包少，包多，程序效果会有变化**

```java
class Window1 implements Runnable{
        private int ticket = 100;
        //Object object = new Object();
    @Override
    public void run() {
//     Object object = new Object();不可以这样子，不然的话就是三把锁了
        //②包多的情况，如果synchronized(this)在这里，那就完全单一窗口执行完了，只有一个窗口在卖票 了
        while(true) {
            synchronized(this){
                //①synchronized (object) { 其实直接用this就好了，相当于version2.0 this就是唯一的，指的是你 Window1 w1 = new Window(); 的w1
                //②注意，synchronized(object)只能在ticket条件判断 上面，不然就相当于大家一起进门之后再亮灯了，那就意义不大了，这是包少的情况
                if (ticket > 0) {
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println(Thread.currentThread().getName() + "：卖票，票号为: " + ticket);
                    ticket--;
                } else {
                    break;
                }
            }
        }
    }
}


```

![image-20200724212819478](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200724212819478.png)

继承类的话就这样就好啦

```java
class Window2 extends Thread{
    private  static int ticket = 100;
     private static Object object = new Object();//只有这里是修改的，需要锁相同就可以了

    @Override
    public void run() {
        while (true) {
            ----------version 1.0----------------------------------------
            //synchronized(this){ 错误，因为不止一个对象 this 代表 t1,t2,t3三个对象
            -----------version 2.0---------------------------------------
                //synchronized(Window2.class){ Class clazz = Window2.class，Window2.class为对象，只会加载一次，也只有一个
            synchronized (object) {
                if (ticket > 0) {
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println(getName() + ":卖票，票号为： " + ticket);
                    ticket--;
                } else {
                    break;
                }
            }
        }
    }
}

```

### 方式二：同步方法

> 操作共享数据的代码完整地声明在一个方法中， 我们不妨将此方法声明同步的。

#### 实现接口的：

```java
class Window3 implements Runnable{
    private int ticket = 100;
    @Override
    public void run() {

        while(true) {
            show();

            }
        }
        private synchronized void show() {//②在这里换了种，相当于 锁是this
        //①这里还是和同步代码块差不多，可以换种
//            synchronized (this) {
                if (ticket > 0) {

                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println(Thread.currentThread().getName() + "：卖票，票号为: " + ticket);
                    ticket--;
                }
            }
        }
//    }  这个是死循环，没有写出来，就这样吧
```

#### 继承Thread类的：

```java
class Window4 extends Thread{
    private  static int ticket = 100;


    @Override
    public void run() {
        while (true) {

            show();
            }
        }

        private static synchronized void show(){//这时候的同步监视器是class了，只加载一次，Window4.class
        // private synchronized void show(){    //同步监视器t1,t2,t3，此种方法是错误的
        if (ticket > 0) {
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + ":卖票，票号为： " + ticket);
                ticket--;
            }
        }
    }
```

> 关于同步方法的总结：
>
> 1. 同步方法仍然涉及到同步监视器，只是不需要我们显式的声明。
> 2. 非静态同步方法，同步监视器是：this
> 3. 静态的同步方法，同步监视器：当前类本身

### 线程安全的单例模式的懒汉式

![image-20200725123059383](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200725123059383.png)

![image-20200725123230352](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200725123230352.png)

> 为什么改成了方式2呢，因为如果是方式一，那么即使这个变量不是空，那也得在外面等着，所以就很不友好， 就比如说，卖一个限量的东西，明明买完了，但是非要你到外面等，然后亲自告诉你卖完了，这不是很让人生气吗？
>
> 所以就改了个方式2，先在外面判断一下

### 死锁问题

> 举例生活中的场景理解，有两人，但只有一双筷子，按理来说让一个人先吃完，再把筷子给别人这样就解决了 ，但是呢，大家互不相让，都拿了一根筷子，等待对方把另外一根筷子给自己，这个就僵持住了，陷入了无法解决的状态

**死锁：不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，形成了线程的死锁**

出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续

解决方法： 

1. 专门的算法、原则
2. 尽量减少同步资源的定义
3. 尽量避免嵌套同步

```java
public class ThreadTest {
    public static void main(String[] args) {
        StringBuffer s1 = new StringBuffer();
        StringBuffer s2 = new StringBuffer();
        new Thread(){
            @Override
            public void run() {
                synchronized (s1){//同步监视器 s1
                    s1.append("a");
                    s2.append("1");
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }

                    synchronized (s2){
                        s1.append("b");
                        s2.append("2");
                        System.out.println(s1);
                        System.out.println(s2);
                    }
                }
            }
        }.start();
        new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (s2){//同步监视器 s2
                    s1.append("c");
                    s2.append("3");
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    synchronized (s1){
                        s1.append("d");
                        s2.append("4");
                        System.out.println(s1);
                        System.out.println(s2);
                    }
                }
            }
        }).start();
    }
}

```

> 这里的本质就是我需要你，你需要我然后僵持住了，因为需要锁的时候感觉是可以使用个紧急召唤的。差不多就这样，而且死锁的情况还是按概率来的，睡眠程度加深的话概率是越大

### 解决线程安全问题方式三：

![image-20200725165416671](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200725165416671.png)

关于

` private ReentrantLock lock = new ReentrantLock(true);`中的true代表什么意思？

意思就是公平的，我们原来是三个线程竞争同步的资源，然后1抢到了，这时候是按照先后顺序来的，就接着2,3抢，1不能抢了，等着2,3完之后，才能让1去争夺（等会？那这个顺序还是很明显的啊，特别是当线程少的时候）

![image-20200725174233882](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200725174233882.png)

你看，是不是很有顺序

```java
import java.util.concurrent.locks.ReentrantLock;

/**
 * 解决线程安全问题的方式三：Lock锁 ----JDK5.0新增
 */
class Window5 implements Runnable{
    private int ticket = 100;//如果这里是继承Thread类的话就要求static哈
    //1. 实例化ReentrantLock
    private ReentrantLock lock = new ReentrantLock();//继承的话这里也需要
    @Override
    public void run() {
        while (true){
            try{
                lock.lock();
                //2.调用lock锁定方法,必须在try的第一行
                if(ticket>0){
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }

                    System.out.println(Thread.currentThread().getName()+": 售票，票号为： " + ticket);
                    ticket --;
                }else {
                    break;
                }
            }finally {
                //3.调用解锁方法：unlock
            lock.unlock();
            }

        }
    }
}
public class LockTest {
    public static void main(String[] args) {
        Window5 w = new Window5();
        Thread t1 = new Thread(w);
        Thread t2 = new Thread(w);
        Thread t3 = new Thread(w);

        t1.setName("窗口1");
        t2.setName("窗口2");
        t3.setName("窗口3");

        t1.start();
        t2.start();
        t3.start();
    }
}
```



### 面试题：synchronized 与 Lock 的异同

相同：二者都可以解决线程安全的问题

不同：1. synchronized机制在执行完相应的同步代码以后，自动的释放同步监视器

​			Lock需要手动的启动同步（lock（）），同时结束同步也需要手动的实现（unlock（））

			2. Lock只有代码块锁，synchronized有代码块锁和方法锁
   			3. 使用Lock锁，JVM将花费较少的时间来调度（线程，性能更好，并且有更好的扩展性（提供更多的子类）

**优先使用顺序：**

Lock->同步代码快（已经进入了方法体，分配了相应资源）->同步方法（方法体之外）

#### 练习题，存钱

![image-20200725180321876](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200725180321876.png)

```java
class Account{
    private double balance;

    public Account(double balance) {
        this.balance = balance;
    }

    //存钱,注意这里用了继承Thread类，但是没有用到static，为什么？因为这里用到的this是同一个，因为是同一个账户呀
    public synchronized void deposit(double amt){
        if(amt>0){
            balance+=amt;
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            System.out.println(Thread.currentThread().getName()+"存钱成功，余额为： "+ balance);
        }
    }

}
class Customer extends Thread{
    private Account acct;

    public Customer (Account acct) {
        this.acct = acct;
    }

    @Override
    public void run() {
        for (int i = 0; i < 3; i++) {
            acct.deposit(1000);
        }
    }
}
public class AccountTest {
    public static void main(String[] args) {
        Account account = new Account(0);
        Customer c1 = new Customer(account);
        Customer c2 = new Customer(account);

        c1.setName("甲");
        c2.setName("乙");

        c1.start();
        c2.start();
    }
}

```

![image-20200725231505719](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200725231505719.png)

### 8.线程的通信

本质是要交流，即你一个，我一个

两个线程打印100的时候，是线程1打个1，线程2打个2这样子，然后交替来的。一开始我想到的解决方法是公平锁，的确是可以实现，但视频里面讲一个用`wait`进行

```java
class Number implements Runnable{
    private int number = 1;
    //证明 wait()和notify 是属于object类中
    // Object obj =  new Object();
    @Override
    public void run() {
        while(true){
            synchronized (this) {
                //synchronized(obj)
                notify();//obj.notify();
                if(number <= 100){

                    System.out.println(Thread.currentThread().getName() + ":" +number);
                    number++;
                    try {
                        //使得调用如下wait（）方程进入阻塞状态
                        wait();//obj.wait();如果同步监视器不是this的话，一定加上，否则会有异常的
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }else {
                    break;
                }
            }
        }
    }
}
public class CommunicationTest {
    public static void main(String[] args) {
        Number number = new Number();
        Thread t1 = new Thread(number,"线程1");
        Thread t2 = new Thread(number,"线程2");

        t1.start();
        t2.start();
    }
}
```

> `wait()` 一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器（和sleep不一样，sleep不会释放，必须要有唤醒，不然大家就像死锁一样僵持不动了）
>
> `notify()`:一旦执行此方法，就会环形被wait的一个线程，如果有多个线程被wait，就唤醒优先级高的，另外一个等下一轮再被唤醒。（比如有两个线程，使用这个就好了，因为会有其中一个进来去唤醒另外一个的）
>
> `notifyAll()`:一旦执行此方法，就会唤醒所有被wait的线程。
>
> 说明：1. wait(),notify(),notifyAll() 三个方法必须使用在同步代码块或同步方法中。
>
> 2.  wait(),notify(),notifyAll() 三个方法的调用者必须是同步代码块或同步方法中的同步监视器否则，会出现`IllegalMonitorStateException异常`

> <img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200726102351216.png" alt="image-20200726102351216" style="zoom:67%;" />
>
> 说明，为什么用wait()和notify()可以达到这样的效果？
>
> 因为一个线程被wait之后，就会阻塞，开锁让另外一个人进来启用notify，这样循环循环，就有交替输出的效果 

#### 面试题：`sleep()`和`wait()`的异同

1. 相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态
2. 不同点：
   - 两个方法声明的位置不同：Thread类中声明`sleep()`，Object类中声明wait()
   - 调用的要求不同，sleep()可以在任何需要的场景下调用,wait()必须使用在同步代码块中或同步方法中
   - 关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁,wait会释放锁

#### **经典例题：生产者/消费者问题**

![image-20200726104552047](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200726104552047.png)

 ```java
/**
 * 线程通信的应用，涉及到了交流
 * 分析：是否有多线程问题？是，生产者线程，消费者线程
 * 2.是否有共享数据？是，店员（或产品）在哪共享的，synchronized就写哪，但我觉得在店员这里不够好，就感觉比较奇怪，感觉换成产品会比较好
 * 3.如何解决线程的安全问题？同步机制，有三种方法
 * 4.是否涉及线程的通信？是
 */
class Clerk{
    private int productCount = 0;
    //生产产品
    public synchronized void produceProduct() {
        if(productCount < 20){
            productCount ++;
            System.out.println(Thread.currentThread().getName()+":开始生产第" + productCount+"个产品");
            notify();
        }else{
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
    //消费产品
    public synchronized void consumeProduct() {
        if(productCount > 0){
            System.out.println(Thread.currentThread().getName()+"开始消费第"+productCount+"个产品");
            productCount--;
            notify();
        }else{
            //等待
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
class Producer extends Thread{//生产者
    private Clerk clerk;

    public Producer(Clerk clerk) {
        this.clerk = clerk;
    }

    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName()+":开始生产产品....");

        while (true){
            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            clerk.produceProduct();
        }
    }
}
class Consumer extends Thread{
    private Clerk clerk;

    public Consumer(Clerk clerk) {
        this.clerk = clerk;
    }

    @Override
    public void run() {
        while (true){
            try {
                Thread.sleep(20);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            clerk.consumeProduct();
        }
    }
}

public class ProductTest {

    public static void main(String[] args) {
        Clerk clerk = new Clerk();

        Producer p1 = new Producer(clerk);
        p1.setName("生产者1");

        Consumer c1 = new Consumer(clerk);
        c1.setName("消费者1");

        p1.start();
        c1.start();
    }
}

 ```

> 总的思路是把店员当成一个中间量，对于生产商来说，他请求生产的指令是要看店员的，店员看货有多少，如果不足就补，足的话就wait，直到有顾客来买，然后立即通知补货
>
> 对于消费者就是根据店员来告诉是否有货，有货就直接买，没货的话就wait一下，让生产商立即生产，然后马上补货让顾客买

## 9.线程的同步实现方式三（记住，这里没有涉及到安全的问题，所以前两种这是继承和实现接口哈，与synchronized无关）

**实现Callable接口**

> 与Runnable相比，Callable功能更强大些
>
> 1. 相比run()方法，可以有返回值
>
> 2. 方法可以抛出异常
>
> 3. 支持泛型的返回值
>
> 4. 需要借助`FutureTask`类，比如获取返回结果

![image-20200726163527554](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200726163527554.png)

```java
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

/**
 * 创建线程方式三：实现Callable接口。 ---JDK5.0新增
 * 如何理解实现Callable接口的方式创建多线程比实现Runnable接口创建多线程方式强大？
 * 1.call()可以有返回值的。
 * 2.call()可以抛出异常，被外面的操作捕获，获取异常的信息
 * 3.Callable是支持泛型的
 */
//1.创建一个实现Callable的实现类
class NumThread implements Callable {
//2.实现call方法，将此线程需要执行的操作声明在call()中
    @Override
    public Object call() throws Exception {
        int sum = 0;
        for (int i = 0; i < 100; i++) {
            if (i % 2 == 0) {
                System.out.println(i);
                sum += i;
            }
        }
        return sum;
    }

}
public class ThreadNew {
    public static void main(String[] args) {
        //3.创建Callable接口实现类的对象
        NumThread  numThread = new NumThread();
        //4.将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象
        FutureTask futureTask = new FutureTask(numThread);
        //5.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()
        new Thread(futureTask).start();
        try {
            //6.获取Callable中call方法的返回值
            //get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值
            Object sum = futureTask.get();
            System.out.println("总和为"+sum);

        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
    }
}

```

> 个人觉得不难理解，首先从多出的功能出发1. 有返回值2.支持泛型3.可以抛出异常
>
> 那这里看1，有返回值，普通的Runnable是实现不了的，所以呢，可以实现别的接口去完成这项工作。所以就绕了个弯` Callable` ->`FutureTask`->`Runnable,Future`(前者不必多说，后者在返回值中起了作用)，然后再把`FutureTask`放到Thread中就可以啦
>
> `FutureTask implements RunnableFuture extends Future,Runnable(其中的run()为抽象方法，所以必须重写哈)`

## 10.线程的同步实现方式四：线程池

> 背景：经常创建和销毁、使用量特别 大的资源，比如并发情况下的线程，对性能影响很大。
>
> 思路：提前创建多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁，重复利用。类似生活中的公共交通工具。（觉得共享单车更合适）
>
> 好处：
>
> - 提高响应速度(减少了创建新线程的时间)
> - 降低资源消耗(重复利用线程池中线程，不需要没次都创建)
> - 便于管理
>   1. `corePoolSize`：核心池大小
>   2. `maximumPoolSize`:最大线程数
>   3. `keepAliveTime`:线程没有任务时最多保持多长时间后会终止
>
> ![image-20200726172159610](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200726172159610.png)

> `Executors`就相当于人，可以不断造东西，可以有四种，想象一个预约酒店，人爆满时候，刚好哎呀就剩最后一间了，给了开一间把，早知道这样怎么不提前预约了，长记性了，把下次的给预约了吧，然后一直如此，这样的话你预约的也就固定了下来，但是还是有意外！不如人家直接来，整个酒店都是我的，我想怎么搞就怎么搞，这回我要全包起来，然后你就没得了。
>
> `ExecutorService`相当于酒店的操作，比如帮你订好房间，返回一些东西给你，再者就是关酒店

![image-20200726203002454](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200726203002454.png)

```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadPoolExecutor;

/**
 * 创建线程的方式四：
 */

class NumberThread implements Runnable{

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            if(i % 2 == 0){
                System.out.println(i);
            }
        }
    }
}
public class ThreadPool {
    public static void main(String[] args) {
        //1.提供指定线程数量的线程池
        ExecutorService service = Executors.newFixedThreadPool(10);
        ThreadPoolExecutor service1 = (ThreadPoolExecutor) service;

           //感觉这样看是不是更好理解一点，其实就像是后面的UserService user = (UserService)DaoFactory.getUserDao();之类的
        ThreadPoolExecutor s2 = (ThreadPoolExecutor) Executors.newFixedThreadPool(10);
        //设置线程池的属性
        service1.setCorePoolSize(15);
//        service1.setKeepAliveTime();
                //2.执行指定的线程的操作，需要提供实现Runnable接口或者Callable接口实现类的对象
        service.execute(new NumberThread());//适合使用于Runnable
//        service.submit();//适合使用于Callable
        //关闭连接池
        service.shutdown();
    }

}

```

![image-20200726211823466](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200726211823466.png)

![image-20200726211830126](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200726211830126.png)