## 三层架构

增强的jdbc，操作数据库的

- 界面层(User Interface layer):和用户打交道的，接受用户的请求参数，显示处理结果(jsp,html,servlet)
- 业务逻辑层(Business Logic Layer):接受了界面层传递的数据，计算逻辑，调用数据库，获取数据
- 数据访问层(Data access layer)：访问数据库，执行对数据的查询，修改，删除等等

三层对应的包

- 界面层： controller (servlet)
- 业务逻辑层： servlett包(XXXService类)
- 数据访问层：dao包(xxxDao类)

三层中类的交互

用户使用界面层-->业务逻辑层-->数据访问层(持久层)-->数据库(mysql)

三层对应的处理框架

​	界面层---servlet---springmvc(框架)

​	业务逻辑层---service类----spring（框架）

​	数据访问层---dao类---mybatis（框架）

![image-20200807150556713](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200807150556713.png)



## 2. 框架

![image-20200807152156375](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200807152156375.png)

> 框架是一个舞台，一个模板
>
> 模板：
>
> 1. 规定了好一些条款，内容。
> 2. 加入自己的东西
>
> 框架是一个模块
>
> 	1. 框架中定义好了一些功能，这些功能是可用的。
>
>    	2. 可以加入项目中自己的功能，这些功能可以利用框架中写好的功能。
>
> 框架是一个软件，半成品的软件，定义好了一些基础功能，需要加入你的功能就是完整的。基础功能是可重复利用的，可升级的
>
> 框架特点：
>
> 	1. 框架一般不是全能的，不能做所有事情
>
>       	2. 框架是针对某一个领域有效，特长在某一个方面，比如mybatis做数据库强，但是不能做其他的。
>       	3.  框架是个软件。

## 3. 为什么要使用mybatis？

### 1> JDBC的缺陷

![image-20200807152634474](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200807152634474.png)

### 2> mybatis 是什么？

> 一个框架，早期叫做`ibatis`，代码在`github`
>
> `mybatis是MyBatis SQL Framework for Java(sql映射框架)`
>
> 1. sql mapper : sql 映射
>
>    可以把数据库表中的一行数据把他映射为一个java对象。即一行数据可以看做一个java对象，操作这个对象，就相当于操作表中的数据
>
> 2. Data Access Objects(DAOs):数据访问，对数据库执行增删改查

​	

#### 		提供的功能：

		1. 提供创建`Connection,Statement,ResultSet的能力，不用开发人员创建了这些对象了`
	 	2. 提供了执行sql语句的能力，不用你执行sql
	    3. 提供了循环sql，把sql的结果转为java对象，List集合的能力
	    4. 提供了关闭资源的能力，不用你关闭`Connection,Statement,ResultSet`

**总结：mybatis是一个sql映射框架，提供了数据库的操作能力，增强的JDBC，使用mybatis让开发人员集中精神写sql就可以了，不必关心`Connection,Statement,ResultSet**

### 3>. 实现步骤

1. 新建的student表
2. 加入maven的mybatis坐标，mysql驱动坐标
3. 创建实体类，Student--保存表中的一行数据
4. 创建持久层的dao接口，定义操作数据库的方法
5. 创建一个mybatis使用的配置文件，叫做sql映射文件：写sql语句的，一般一个表一个sql映射文件，这个文件是xml文件
   1. 写在接口所在的目录中
   2. 文件的名称和接口保持一致
6. 创建mybatis的主配置文件：一个项目就一个主配置文件：一个项目就一个主配置文件，主配置文件提供了数据库的连接信息和sql映射文件的位置信息
7. 创建使用mybatis类，通过mybatis访问数据库

![image-20200807185041337](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200807185041337.png)

```java
//接口操作studet表
public interface StudentDao {

    //查询student表单的所有数据
    public List<Student> selectStudents();

    //插入方法
    //参数：student，表示要插入到数据库的数据
    //返回值：int，表示执行insert操作后影响数据库的行数
    public int insertStudents(Student student);
}




//推荐和表名一致。容易记忆
public class Student {
    //定义属性，目前要求是属性名和列名一致。
    private Integer id;
    private String name;
    private String email;
    private Integer age;

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "Student{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", email='" + email + '\'' +
                ", age=" + age +
                '}';
    }
}



public class MyApp {
    public static void main(String[] args) throws IOException {
        //访问mybatis读取student数据
        //1.定义mybatis主配置文件的名称,从类路径的根开始(target/classes)
        String config = "mybatis.xml";
        //2.读取这个config表示的文件
        InputStream is = Resources.getResourceAsStream(config);
        //3.创建了SqlSessionFactoryBuilder对象
        SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();
        //4.创建SqlSessionFactory对象
        SqlSessionFactory factory = builder.build(is);
        //5.[重要]获取SqlSession对象，从SqlSessionFactory中获取SqlSession
        SqlSession sqlSession = factory.openSession();
        //6.[重要]指定要执行sql语句的标识。sql映射文件中的namespace +"."+标签的id值
        String sqlId = "com.zbr.dao.StudentDao" + "." + "selectStudents";
        //7.执行sql语句，通过sqlId来执行，通过sqlId找到语句
        List<Student> studentList = sqlSession.selectList(sqlId);
        //8.输出结果
        studentList.forEach(stu -> System.out.println(stu));
        //9.关闭SqlSession对象
        sqlSession.close();
    }
}



public class TestMyBatis {
    //测试方法，测试功能
    @Test
    public void testInsert() throws IOException {
    //访问mybatis读取student数据
    //1.定义mybatis主配置文件的名称,从类路径的根开始(target/classes)
    String config = "mybatis.xml";
    //2.读取这个config表示的文件
    InputStream is = Resources.getResourceAsStream(config);
    //3.创建了SqlSessionFactoryBuilder对象
    SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();
    //4.创建SqlSessionFactory对象
    SqlSessionFactory factory = builder.build(is);
    //5.[重要]获取SqlSession对象，从SqlSessionFactory中获取SqlSession
    SqlSession sqlSession = factory.openSession();
    //6.[重要]指定要执行sql语句的标识。sql映射文件中的namespace +"."+标签的id值
    String sqlId = "com.zbr.dao.StudentDao" + "." + "insertStudents";
    //7.执行sql语句，通过sqlId来执行，通过sqlId找到语句
    Student student = new Student();
    student.setId(1003);
    student.setName("张飞");
    student.setEmail("zhangfei@360.com");
    student.setAge(20);
        int insert = sqlSession.insert(sqlId, student);
        //mybatis默认不是自动提交事务的，所以在insert，update，delete后要手动提交事务
        sqlSession.commit();

        //8.输出结果
        System.out.println(insert);
    //9.关闭SqlSession对象
        sqlSession.close();
    }
}

```

`StudentDao.xml`

```html
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.zbr.dao.StudentDao">
<!--    说实话这个namespace不强制，你直接写个a也行，但是按规范来讲就要写全类名-->

<!--
   select:表示查询操作
   id:你要执行的sql语法的唯一标识，mybatis会使用这个id的值来找到要执行的sql语句
        可以自定义，但是要求使用接口中的方法名称

    resultType:表示结果类型的，是sql语句执行后得到的ResultSet,遍历这个ResultSet得到的java对象的类型
    值写的类型的全限定名称
-->
    <select id="selectStudents" resultType="com.zbr.domain.Student">
        select id,name,email,age from student order by id
--             select id from student
    </select>
<!--    插入操作-->
    <insert id="insertStudents">
        insert into student values (#{id},#{name},#{email},#{age})
    </insert>
</mapper>
<!--
    sql映射文件：写sql语句的，mybatis会执行这些sql
    1.指定约束文件
        <!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

        mybatis-3-mapper.dtd是约束文件的名称，扩展名是dtd

     2.约束文件的作用：限制，检查在当前文件中出现的标签，属性必须符合mybatis的要求

     3.mapper是当前文件的根标签，必须的。
        namespace：叫做命名空间，唯一值的，可以是自定义的字符串。
                    要求你使用dao接口的全限定名称（报名+类名）。
     4.在当前文件中，可以使用特定标签，表示数据库的特定操作。
        <select>:表示执行查询
        <update>:表示更新数据库的操作，就是在<update>标签中写的是update的sql语句
        <insert>:表示插入，放的是insert语句
        <delete>:表示删除，放的是delete的语句
-->
```

mybatis.xml

```html
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
<!--    环境配置：数据库连接信息
        default:必须和某个environment的id值一样
        告诉mybatis使用哪个数据库的连接信息，也就是访问数据库

-->
<!--    settings:控制mybatis全局行为-->
    <settings>
<!--        设置mybatis输出日志-->
        <setting name="logImpl" value="STDOUT_LOGGING"/>
    </settings>
    <environments default="mydev">
<!--        environment :一个数据库信息的配置，环境
            id：一个唯一值，自定义，表示环境的名称
-->
        <environment id="mydev">
<!--
        transactionManager:mybatis的事务类型
            type:JDBC(表示使用jdbc中的Connection对象的commit，rollback做事务处理)
-->
            <transactionManager type="JDBC"/>
<!--
        dataSource:表示数据源，连接数据库的
        type：表示数据库的类型，POOLED表示使用连接池
-->
            <dataSource type="POOLED">
<!--
            driver,user,username,password,是固定的，不能自定义

-->
<!--                数据库的驱动类名-->
                <property name="driver" value="com.mysql.cj.jdbc.Driver"/>
<!--                连接数据库的url字符串-->
                <property name="url" value="jdbc:mysql://localhost:3306/ssm?serverTimezone=GMT%2B8"/>
                <property name="username" value="root"/>
                <property name="password" value="123456"/>
            </dataSource>
        </environment>
    </environments>
    <mappers>
<!--
    一个mapper标签指定一个文件的位置，
       从类路径开始的路径信息。 target/classes(类路径)
-->
        <mapper resource="com/zbr/dao/StudentDao.xml"/>
<!--        <mapper resource="com/zbr/dao/SchoolDao.xml"/>-->
    </mappers>
</configuration>
<!--
    mybatis的主配置文件：主要定义了数据库的配置信息，

    1.约束文件
    <!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">

        mybatis-3-config.dtd:约束文件的名称
    2. configuration
-->
```

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200808001144990.png" alt="image-20200808001144990" style="zoom: 67%;" />

## 编译之后的resources文件没有出现在target/classes中？

> 这个其实昨天就讲了，可以直接再build一个插件，但是呢，我今天就没遇到这个问题，不过应该还是比较常见的。
>
> 有三种解决方法
>
> 1. `clean后再compile`
> 2. `菜单中Build->rebuild project后重新运行一遍`
> 3. 在File中点击![image-20200807224425232](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200807224425232.png)，再重新跑一遍，就基本上可以了

## 主要的类的介绍

1. Resources: mybatis中的一个类，负责读取配置文件

   `InputStream is = Resources.getResourceAsStream("mybatis.xml");`

2. `SqlSessionFactoryBuilder:创建SqlSessionFactory对象，`

   ```java
   SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();
   //4.创建SqlSessionFactory对象
   SqlSessionFactory factory = builder.build(is);
   ```

3. `SqlSessionFactory`:重量级对象，程序创建一个对象耗时比较长，使用资源比较多

   在整个项目中，有一个就够用了

   `SqlSessionFactory`是个接口，接口实现类`DefaultSqlSessionFactory`

   `SqlSessionFactory`作用：获取`SqlSession对象`

   ```java
   SqlSession sqlSession = factory.openSession();
   ```

   `openSession`方法说明：

   - `openSession():`无参数的，获取的是非自动提交事务的`SqlSession`对象

   - `openSession(boolean):``openSession(true)`获取自动提交事务的`SqlSession对象`

     ​									`openSession(false)` 非自动提交事务的`SqlSession`对象

4. `SqlSession`:是一个接口，定义了操作数据的方法例如`selectOne(),selectList(),insert(),update(),delete(),commit(),rollback()`

   `SqlSession接口的实现类：DefaultSqlSession`

   使用要求：`SqlSession对象不是线程安全的，需要在方法内部使用，再执行完sql语句之前，使用openSession获取SqlSession，在执行完sql语句之后，需要关闭他，执行SqlSession.close(),这样才能保证他的使用时线程安全的`

**总结：其实就是层层拆封，像一个礼物外面包了很多个包装袋，不断地拆，这里拆了两层拆到了，但是上面的代码都是重复的，所以最好使用个工具类用起来**

```JAVA
//工具类,获取SqlSession
public class MyBatisUtils {

    private static SqlSessionFactory factory = null;
    static{
        //需要和你项目中的文件名一样
        String config = "mybatis.xml";
        try {
            InputStream is = Resources.getResourceAsStream(config);
            //创建SqlSessionFactory对象，使用创建SqlSessionFactoryBuilder
             factory = new SqlSessionFactoryBuilder().build(is);


        } catch (IOException e) {
            e.printStackTrace();
        }
    }


    //获取SqlSession的方法
    public static SqlSession getSqlSession(){
        SqlSession sqlSession = null;
        if(factory != null){
            //非自动提交事务
            sqlSession = factory.openSession();
        }
        return sqlSession;
    }
}

```

> 他们之前提到和接口完全一点关系都没有，我不这么觉得，我认为只是使用上关系不大，但是在代码背后是有关系的。就拿你执行完sql语句的返回值，你怎么知道是`List<Student>`还是`Student`，哪里都没写，就只有`StudentDao`接口那里写了，所以还是有依照接口的

![image-20200808092828625](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200808092828625.png)

![image-20200808093201001](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200808093201001.png)

## 动态代理

```java
    /**
     * 使用mybatis的动态代理机制，使用SqlSession.getMapper(dao接口)
     * getMapper能够获取dao接口对应的实现类对象
     */
    @Test
    public void  testSelectStudents(){
        SqlSession sqlSession = MyBatisUtils.getSqlSession();
        //用了动态代理？因为不是直接拿到dao的，有通过sqlSession拿到的
        StudentDao dao = sqlSession.getMapper(StudentDao.class);
        //调用dao的方法，执行数据库的操作
        List<Student> students = dao.selectStudents();
        for (Student stu:students){
            System.out.println(stu);
        }


    }
```

> 1. 使用`SqlSession.getMapper(dao接口.class)获取这个dao接口的对象`
>
> 2. 传入参数：从java代码中把数据传入到`mapper`文件的sql语句中
>
>    - `parameterType`:写在mapper文件中的一个属性，表示dao接口中方法的参数的数据类型
>
>      例如StudentDao接口
>
>      `public Student selectStudentById(Integer id)`
>
>    - ```java
>      /**
>       * 一个简单类型的参数：
>       *      简单类型：mybatis把java的基本数据类型和String都叫简单类型
>       *
>       *      在mapper文件获取简单类型的一个参数的值，使用#{任意字符}
>       // 接口：`public Student selectStudentById(Integer id)`
>       //mapper： select id,name,email,age from student where id = #{id}
>      
>       */
>      ```

![image-20200808151404730](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200808151404730.png)

> parameterType的别名 
>
> ```html
> <!--
>  parameterType:dao接口中方法参数的数据类型
>  parameterType它的值是java的数据类型全限定名称或者是mybatis定义的别名
>  例如： parameterType="java.lang.Integer"
>          parameterType = "int"
> 
>  注意：parameterType不是强制的，mybatis通过反射机制能够发现接口方法参数的数据类型
>  所以可以没有，一般我们也不写。
> 	那resultType 呢？
> 
>  由mybatis执行以下的代码：
>  1.mybatis创建connection， PreparedStatement对象
>      String sql = "select id,name,email,age from student where id = ?";
>      PreparedStatement pst =  conn.preparedStatement(sql);
>      pst.setInt(1,1001);
> 
>     2. 执行sql封装为resultType="com.zbr.domain.Student"这个对象
>     ResultSet rs = pst.executeQuery();
>     Student student = null;
>     while(rs.next()){
>     student = new Student();
>     student.setName(rs.getInt("id"));
>     ······等等
> 
>     }
>     return student;
> -->
> ```

> 我对于这个动态代理的理解： 说是动态代理因为我们本来是要用`StudentDaoImpl`来实现数据库的操作的，但是这里的话使用了`SqlSession`映射获取了`StudentDao`的接口，使用接口的方法进行操作，这两步跟动态代理的卖u盘比较像，但是呢，在作用上，我看不出来用动态代理的理由，感觉也没有控制访问和增强功能的意思，所以暂且就先这样吧，等我后面有能力去看源码的时候再来了解。

	>  
	>
	>  关于`StudentDao dao = sqlSession.getMapper(StudentDao.class);`这里为什么填的是`StudentDao.class`，也不是说我能清楚解释原因（我现在觉得是你总不能传个对象把，对象是具体的，而字节码文件像是个模板一样的），但这是我的一个想法，因为我一开始疑惑`StudentDao.xml`里面也填了`StudentDao`的映射了，那到底这两个作用是啥？ 
	>
	>  我认为是在`getMapper`里面填完之后就从`StudentDao.xml`准备好，建立好连接，两个文件联系起来，返回一个`StudentDao`就好了，之后每次要调用方法的时候，就通过这个接口跑去xml那里进行就好了。`xml`里面填的表示和某个接口的依赖关系，就像你要预约某个boss，首先一个boss和一个秘书是存在一个联系的关系的，你每次要预约boss的时候你是要通过秘书来预约的，然后你发现秘书就是接口，boss是`xml`，感觉有点动态代理的意思了诶，没错，感觉有点意思了，这里就是控制访问 了hhhhhhhhhhhh

### 传入多个参数

必会12 ， 34了解不推荐使用

### 1.第一种方法

![image-20200808162210478](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200808162210478.png)

使用@Param命名参数

- 接口	`public List<Student> selectMultiParam(@Param("myname") String name,@Param("myage")Integer age)`

  使用`@Param("参数名") String name`

  在mapper文件里使用:

  ​	`<select>`

  ​			`select * from student where name = #{myname} or age = #{myage}`

  ​	`</select>`

  > 为什么要这样？ 而不是像上面一样直接写两个`#{}`，然后在调用方法的时候传参呢？？原因：前面有提到 过`${任意字符}`，因为是任意字符就不起作用，所以你传多个参数的时候就谁也不认识谁，而且他也没规定按顺序传这样子，所以就有了上面注解的这种方法

### 2.第二种方法

```java
/*
        多个参数，使用java对象作为接口中方法参数
         */
        List<Student> selectMultiObject(QueryParam param);
//QueryParam中的
	private String paramName;
    private Integer paramAge;

```

```html
<!--       多个参数，使用java对象的属性值，作为参数实际值
            使用对象的语法：#{属性名，javaType=类型名称，jdbcType= 数据类型} 完整的语法格式，但很少用
            javaType:值java中的属性数据类型
            例如:#{paramName,javaType=java.lang.String,jdbcType=VARCHAR}

            我们使用的是简化方式：#{属性名}，javaType，jdbcType的值mybatis反射能获取值
-->
    <select id="selectMultiObject" resultType="com.zbr.domain.Student">
        select * from student where name = #{paramName} or age = #{paramAge}
    </select>
```

> 这里的话的要求就是你的参数名和对应`#{任意字符}`中的任意字符是对应的，想想嘛，你传参的时候传的是一个Object，那你的对象去找对应属性的时候就是根据他内部的参数名和映射文件中的参数名是一一对应的，就跟`spring里面的jdbcTemplate的一一对应差不多`。
>
> 这时候有一个疑问，为什么传参传的不是`Student`呢？ 这说明不严格要求传参，只要你做到一一对应ok

### 3.第三种方法

终于盼来了从左到右的，但是可读性不好，并不推荐,不易维护

v![image-20200809091833502](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200809091833502.png)

### 4.第四种方法

![image-20200809092931098](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200809092931098.png)

可读性也很差







## 两个占位符的区别

![image-20200809093525174](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200809093525174.png)

 ![image-20200809094505802](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200809094505802.png)

> ```java
>  select id,name,email,age from student where id = #{id}
> # 的结果:         select id,name,email,age from student where id = ?
>     
>  select id,name,email,age from student where id = ${id}
> $ 的结果：        select id,name,email,age from student where id =1001
> 
> 使用的Statement 对象执行sql，效率比PreparedStatement低，而且有sql注入的风险，如上图
>     但也不是完全没用，$可以替换表名或者列名，你能确定数据是安全的，就可以使用
> ```
>
> ![image-20200809105420047](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200809105420047.png)

![image-20200809112211865](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200809112211865.png)

![image-20200809112708556](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200809112708556.png)

## mybatis输出结果

### resultType

指sql语句执行完毕后，数据转为java对象，java类型是任意的，可以是别名or全限定名称

```java
int 
java.lang.Integer

```

#### 返回值是map

```html
<!--
    返回Map(建议Map<Object,Object>)
    1> 列名是map的key，列值是map的value
    2> 只能最多返回一行记录。多余一行是错误的
-->
    <select id="selectMapById" resultType="java.util.HashMap">
        select id,name from student where id = #{stuid}
    </select>
```



**建议全限定名称**

处理方式：

1. mybatis执行sql语句，然后mybatis调用类的无参构造器，创建对象
2. mybatis把`ResultSet`指定列值赋给同名的属性

> 这过程中写了一个例子，其实之前我也有思考过，比如一个表中对应的是一个student的实体类，有name，id，age，email的四个属性，但此时以我的权限只能拿到name和id的实体类`ViewStudent`(有view的作用的感觉),所以我这里设置的`ResultType是ViewStudent`,可以正常返回吗？ 可以的！

### resultMap

> 结构映射，指定列名和java对象的属性对应关系。
>
> 1. 自定义列值赋给哪个属性
> 2. 当列名和属性名不一样时，一定要使用`resultMap`

```html
<!--    使用resultMap
    1.先定义resultMap
    2.在select标签，使用resultMap来引用1定义的
-->
<!--    定义resultMap
        id:自定义名称，表示你定义的这个resultMap
        type:java类型的全限定名称
-->
    <resultMap id="studentMap" type="com.zbr.domain.Student">
<!--        列名和java属性的关系-->
<!--        注释列，使用id标签
            column:列名
            property:java类型的属性名
-->
            <id column="id" property="id"/>
<!--        非主键列-->
        <result column="name" property="name"/>
    </resultMap>
    <select id="selectAllStudents" resultMap="studentMap">
        select * from student
    </select>

<!--    列名和属性名不一样：第二种方式（第一种是resultMap，这里没写，因为还是可以理解的，上面写的resultMap对应的作用是赋给不同的属性）-->

    <select id="selectAllStudents" resultType="com.zbr.domain.Student">
        select id as stuid from student
    </select>
<!-- 反正是要么改我要么改你-->
```



总结：**resultMap 和 resultType不能一起使用**



## 定义自定义类型的别名

1. 在**mybatis主配置文件**中定义，使`<typeAlias>`定义别名
2. 可以在resultType中使用自定义别名

```html
<!--    定义别名-->
    <typeAliases>
<!--
            第一种方式：
            可以指定一个类型一个自定义别名
            type:自定义类型的全限定名称
            alias：别名(短小，容易记忆的)

-->
        <typeAlias type="com.zbr.domain.Student" alias="stu"></typeAlias>
        <typeAlias type="com.zbr.vo.ViewStudent" alias="vstu"></typeAlias>
<!--

         第二种方式
         <package> name是包名，这个包中的所有类，类名就是别名(类名不区分大小写)
        这种方式比较多
-->
        <package name="com.zbr.vo"/>
        <package name="com.zbr.domain"/>
    </typeAliases>
```

> 总结：**最好不要用别名**，可读性差，而且重复了也容易报错,上面的`resultType`也是

![image-20200809173633237](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200809173633237.png)

第二种方式一定要空格？不一定吧

第一种方式是在外面拼接提供好，比较灵活，推荐那个

## 动态SQL

> sql的内容是变化的，可以根据条件获取到不同的sql语句，主要是where发生变化
>
> 动态sql的实现，使用的是mybatis提供的标签，`<if>,<where>,<foreach>`
>
> 1. <if>是判断条件的
>
>    ```html
>    <if test= "判断java对象的属性值">
>        部分sql语句
>    </if>
>    ```
>
>    ![image-20200809192921310](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200809192921310.png)
>
>    ```html
>    <select id="selectStudentIf" resultType="com.zbr.domain.Student">
>            select * from student
>            where 1 = 1
>            <if test="name != null and name != ''">
>               and name = #{name}
>            </if>
>            <if test="age > 0 ">
>                and age > #{age}
>            </if>
>        </select>
>    ```
>
>    > 不足在于还是要考虑到where的情况，在下面和where并用可以解决。而且这种if的条件我以前没考虑过？ 看来是我写的代码不够好吧
>
> 2. `where`用来包含多个<if>的，当多个if有一个成立的，<where>会自动增加一个where关键字，并去掉if中多余的and，or等 ，！！！只删不加哈，所以后面的该加or就加上去
>
>    ```html
>     <select id="selectStudentWhere" resultType="com.zbr.domain.Student">
>            select * from student
>            <where>
>                <if test="name != null and name != ''">
>                     name = #{name}
>                </if>
>                <if test="age > 0 ">
>                    or age > #{age}
>                </if>
>            </where>
>        </select>
>    ```
>
>    有了这个where的标签就很easy 了
>
> 3. <foreach>循环java中的数组，list集合的，主要用在sql的in语句中。
>
>    比如`select * from student where id in (1001,1002,1003)`，但是我们一般是把1001,1002,1003放到数组or list集合中的，但是我们怎么遍历这个list呢？不可能手动一个个把值拿出来传进去把
>
>    ```html
>     <foreach collection="" item="" open="" close="" separator="" >
>                
>            </foreach>
>    collection:表示接口中方法参数的类型，如果是数组使用array，如果是list集合使用list
>    item：自定义的，表示数组和集合成员的变量
>    open：循环开始时的字符
>    close：循环结束时的字符
>    separator集合成员之间的分隔符
>    
>    <!--    foreach 使用1，List<Integer>-->
>        <select id="selectForeachOne" resultType="com.zbr.domain.Student">
>            select * from student where id in
>            <foreach collection="list" item="myid" open="(" close=")" separator="," >
>            #{myid}
>            </foreach>
>        </select>
>    <!-- forEach 用法2，List<Student>-->
>        <select id="selectForeachTwo" resultType="com.zbr.domain.Student">
>            select * from student where id in
>            <foreach collection="list" item="stu" open="(" close=")" separator=",">
>                #{stu.id}
>            </foreach>
>        </select>
>    ```
>
>    这样就完美解决了啊
>    
> 4. 代码片段,复用一些语句
>
>    ![image-20200809221334802](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200809221334802.png)
>
>    ![image-20200809221345289](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200809221345289.png)
>
>    步骤
>
>    1. 先定义<sql id="自定义名称唯一"> sql语句，表名，字段等</sql>
>    2. 再使用，<include refid="id的值">



![image-20200809222452988](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200809222452988.png)

![image-20200809222831026](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200809222831026.png)

## 主配置文件DataSource

![image-20200809231758838](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200809231758838.png)

![image-20200809232215702](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200809232215702.png)

### 数据库的属性配置文件

把数据库连接信息放到一个单独的文件中，和mybatis主配置文件分开

目的是便于修改，保存，处理多个数据库的信息。

1. 在resources目录中定义一个属性配置文件，xxx.properties，例如jdbc.properties,在属性配置文件中，定义数据，格式是key=value

   key：一般使用 `.` 做多级目录的(一般至少要一个`.`)

   例如`jdbc.mysql.driver,jdbc.driver,mydrive`

   `jdbc.driver=com.mysql.jdbc.Driver`

2. 在mybatis的主配置文件中，使用`<property>`指定文件的位置，在需要使用值的地方，`${key}`

![image-20200809233353705](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200809233353705.png)

![image-20200809233405366](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200809233405366.png)

```html
<!--    指定properties文件的位置，从类路径根开始找文件-->
    <properties resource="jdbc.properties"/>
```

![image-20200809233453693](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200809233453693.png)

![image-20200809233505844](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200809233505844.png)

优点就是易于维护

### 指定多个mapper文件的方式

```html
  <!--
    一个mapper标签指定一个文件的位置，
       从类路径开始的路径信息。 target/classes(类路径)
      
-->
<!--     第一种方式：指定多个mapper文件-->
        <mapper resource="com/zbr/dao/StudentDao.xml"/>
        <mapper resource="com/zbr/dao/OrderDao.xml"/>
<!--        第二种方式：使用包名
            name:xml文件(mapper文件)所在的包名,这个包中所有xml文件一次能加载给mybatis
            使用package的要求：
            1. mapper文件名称需要和接口名称一样，区分大小写的一样
            2.mapper文件和dao接口需要在同一目录
觉得这么做的原因是因为他找的时候看的是接口，然后去找对应接口名字的xml文件
-->
        <package name="com.zbr.dao"/>
```

> 一般使用的是第二种，要求掌握

## PageHelper插件

![image-20200809235120640](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200809235120640.png)

![image-20200809235222777](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200809235222777.png)

![image-20200810000849228](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200810000849228.png)