## 代理模式

![image-20200806120506595](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200806120506595.png)

![image-20200806121313482](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200806121313482.png)

> 想到一个串起来的故事。
>
> 小红想去美国读大学，然后她的爸妈就直接飞去美国了，但那所大学说不好意思，我们不接受单独录取。然后就灰溜溜地回国了，这时候有中介在广告，留学中介留学中介，我们的目标是进入美国大学，这里提供统一平台招生录取，费用合理，大家看一看，然后小红爸妈就去看了，给了笔钱，经过小红的努力，就考上了

![image-20200806123244222](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200806123244222.png)

### 使用代理模式的作用

1. 功能增强：在你原有的功能上，增加了额外的功能，新增加的功能，叫做功能增强
2. 控制访问：代理类不让你访问目标，例如商家不让用户访问厂家。

### 实现代理的方式

1. 静态代理： 

   - 代理类是自己手工实现的，自己创建一个java类，表示代理类
   - 同时你所要代理的目标类是确定的

   特点：1. 实现简单

   ​			2.	容易理解

   - 模拟一个用户购买u盘的行为。

     用户是客户端类

     商家：代理，代理某个品牌的u盘

     厂家：目标类

     三者关系： 用户(客户端)---商家(代理)---厂家（目标）

     商家和厂家都是卖u盘的，他们完成功能时一致的，都是卖u盘

   - 实现步骤：

     1. 创建一个接口，定义卖u盘的方法，表示你的厂家和商家做的事情
     2. 创建厂家类，实现1步骤的接口
     3. 创建商家，就是代理，也需要实现1步骤中的接口
     4. 创建客户端类，调用商家的方法买一个u盘

   - 代理类完成的功能：

     1. 目标类中方法的调用
     2. 功能增强

   - 静态代理的缺点：（当目标类和代理类有很多的时候）

      1. 当目标类增加了，代理类可能也需要成倍地增加，代理类数量过多。因为商家和厂家都	实现同一个接口(里面只有一个sell方法)，意味着一个类只能代理一个厂家(否则的话要使用两次sell方法，那就会有一个方法是多余的)，所以要想代理两个厂家，就要再创建一个类
      2. 当你的接口中功能增加了，或者修改了，会影响众多的实现类，厂家类，代理都需要修改。影响比较多，维护难度高

   ![image-20200806173515735](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200806173515735.png)

2. 动态代理

   - 在静态代理中目标类很多时候，可以使用动态代理，避免静态代理的缺点。动态代理中目标类即使很多，1> 代理类数量可以很少 ， 2> 当你修改了接口的方法时，不会影响代理类

   - 在程序执行中，使用jdk的反射机制，创建代理类对象，并动态指定要代理目标类

     换句话说：动态代理是一种创建java对象的能力，让你不用创建`TaoBao类`文件，就能创建代理类对象

   - 动态代理的实现 

      1. jdk动态代理(理解):java反射包中的类和接口实现动态代理的功能

         ​	反射包 `java.lang.reflect`，里面有三个类: `InvocationHandler,Method,Proxy`

         ​	要求必须有接口

         - `InvocationHandler`接口(调用处理器)，就一个方法`invoke()`:表示代理对象要执行的功能代码，你的代理类要完成的功能就写在`invoke()`方法中就可以了

           代理类完成的功能：1.调用目标方法，执行目标方法的功能。 2.功能增强，在目标方法调用时，增强功能。

           - 方法原型

             ```java
             //参数：Object proxy:jdk 创建的代理对象，无需赋值
             //		Method method:目标类中的方法，jdk提供method对象
             // 		Object[] args: 目标类中的方法参数，jdk提供的
             public Object invoke(Object proxy, Method method, Object[] args)
                     throws Throwable;
             ```

           - 如何使用？

             1. 创建类实现接口`InvocationHandler`：表示你的代理要干什么
             2. 重写`invoke()`方法，把原来静态代理类完成的功能，写在这里

         - `Method类：表示方法的，确切的说就是目标类中的方法`

           - 作用：通过Method可以执行某个目标类的方法，`Method.invoke();`(和上面的名字虽然一样，但这是反射中的方法哈)

             在`InvocationHandler`等同于`float price = factory.sell(amount);`

         - `Proxy类：核心的对象，创建代理对象，之前创建对象都是new 类的构造方法`

           ​	现在我们是使用`Proxy`类的方法，代替new的使用

           方法：静态方法`newProxyInstance()`

           作用：创建代理对象，等同于静态代理中`TaoBao taoBao = new TaoBao();`

           ```java
           public static Object newProxyInstance(ClassLoader loader,
                                                 Class<?>[] interfaces,
                                                 InvocationHandler h)
           ```

           参数：

           1. `ClassLoader loader 类加载器，负责向内存中加载对象，使用反射获取对象的ClassLoader` ,比如类a，`a.getClass().getClassLoader()`,目标对象的类加载器
           2. ` Class<?>[] interfaces:接口，目标对象实现的接口，也是反射获取的` 
           3. `InvocationHandler h:我们自己写的，代理类要完成的功能`，感觉有点矛盾了？ invoke的时候需要proxy，proxy需要接口？，互相需要？

           返回值就是代理对象

        2. 实现动态代理的步骤：

           	1. 创建接口，定义目标类要完成的功能。
                 	2. 创建目标类实现接口
                 	3.  创建`InvocationHandler接口的实现类，在invoke方法中完成代理功能`
                	4. 调用目标方法
                	5. 增强功能
                	6. 使用Proxy类的静态方法，创建代理对象，并把返回值转为接口类型

      3. cglib动态代理（了解）: `cglib`是第三方的工具库，创建代理对象。

         ​	`cglib`的原理是继承，`cglib`通过继承目标类，创建他的子类，在子类中重写父类中同名的方法，实现功能的修改

         因为`cglib`是继承，重写方法，所以要求目标类不能是final的，方法也不能是final的，`cglib`的要求目标类比较宽松，只要能继承就可以了，`cglib`在很多框架中使用,`mybatis`,`spring`中有。

         `cglib`对于无接口的类可以使用，`jdk` no

![image-20200806174543120](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200806174543120.png)





### 实例

![image-20200806225023403](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200806225023403.png)

> 动态代理今天是从懂-> 些许懵逼-> 也许懂了
>
> 说实话老师刚开始举例卖u盘的这个的作用感觉着重在控制访问上面了，增强作用效果不明显，所以导致后面我有些忽略这个作用，从而没想明白一些例子是利用这个作用使用动态代理的。先贴代码把。首先讲的是静态代理。
>
> 情景 如下：角色分为顾客，代理(代理类)和厂商(目标类)，代理有淘宝or微商，代理赚差价，厂商返回一个成本价，代理在其中作增强提高价格返回售价。

#### 静态代理

```java
//表示功能的，厂家，商家都要完成的功能
public interface UsbSell {

    //定义方法 参数 amount:表示一次购买的数量，暂时不用
    //返回值表示一个u盘的价格
    float sell(int amount);
}


//目标类：金士顿厂家，不接受用户单独购买
public class UsbKingFactory implements UsbSell {
    @Override
    public float sell(int amount) {
        //一个128G u盘85元
//        后期根据amount,可以实现不同价格,10000个 单价80,50000,单价 75
        return 85.0f;
    }
}

//taobao 是商家，代理u盘销售
public class TaoBao implements UsbSell {

    //声明 商家代理的厂家是谁
    private UsbKingFactory factory = new UsbKingFactory();
    @Override
    //实现销售u盘的功能
    public float sell(int amount) {
        //向厂家发送订单告诉厂家，我买了u盘，厂家发货
        float price = factory.sell(amount);
        //商家加价，代理需要增加价格
        //增强功能，代理类在完成目标类方法调用后，增强了功能
        //在目标类的方法调用后，你做的其他功能，都是增强的意思
        System.out.println("淘宝商家，给你返一个优惠券，或者红包");
        price = price +25;
        return price;
    }
}


public class WeiShang implements UsbSell {
   //代理u盘，定义目标厂家类
    private UsbKingFactory factory = new UsbKingFactory();
    @Override
    public float sell(int amount) {
        //调用目标方法
        float price = factory.sell(amount);
        //只增加1元
        price = price + 1;
        return price;
    }
}



public class ShopMain {

    public static void main(String[] args) {
        //创建代理的商家taobao对象
        TaoBao taoBao = new TaoBao();
        float price = taoBao.sell(1);
        System.out.println("通过淘宝商家，购买u盘单价：" + price);


        WeiShang weiShang = new WeiShang();
        float price2 = weiShang.sell(1);
        System.out.println("通过微商购买的价格:"+ price2);

    }
}

```

> 缺点上面也写了，比较明显，不是动态的，如果代理很多的话就会有很多类出现，而且牵一发而动全身，修改麻烦。

#### 动态代理

```java
//目标接口
public interface UsbSell {
    float sell(int amount);
    //这是我进行测试用的。
    float test(int amount);
}



public class UsbKingFactory implements UsbSell {
    @Override
    public float sell(int amount) {
       //目标方法
        System.out.println("目标类中，执行sell目标方法");
        return 85.0f;
    }

    @Override
    public float test(int amount) {
        System.out.println("目标类中，执行test方法");
        return 86.0f;
    }
}



//必须实现的接口，完成代理类要做的功能
public class MySellHandler implements InvocationHandler {
    private Object target = null;
//动态代理：目标对象是活动的，不是固定的，需要传入进来
    //传入的是谁。就给谁创建代理
    public MySellHandler(Object target) {
        //给目标对象赋值
        this.target = target;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {

        Object res = null;
        //向厂家发送订单告诉厂家，我买了u盘，厂家发货
        res = method.invoke(target, args);
        //商家加价，代理需要增加价格
        //增强功能，代理类在完成目标类方法调用后，增强了功能
        //在目标类的方法调用后，你做的其他功能，都是增强的意思
        System.out.println("淘宝商家，给你返一个优惠券，或者红包");
//        price = price +25;
        String name = method.getName();
        System.out.println(name);
        if(res != null){
            Float price = (Float) res;
            price +=25;
            res = price;
        }
        return res;


    }
}



public class MainShop {
    public static void main(String[] args) {
        //创建代理对象，使用 Proxy
        //1.创建目标对象
        UsbSell factory = new UsbKingFactory();
        //2.创建InvocationHandler对象
        InvocationHandler handler = new MySellHandler(factory);
        //3.创建代理对象
        //为什么返回值是UsbSell类型的？ 因为这里使用的都是用factory的classLoader，什么都是用他的（还是不大明白）
        UsbSell proxy = (UsbSell) Proxy.newProxyInstance(factory.getClass().getClassLoader(),factory.getClass().getInterfaces(),handler);
        //4.通过代理执行方法
        float price = proxy.sell(1);
        float test = proxy.test(3);
        System.out.println(test);
        System.out.println("通过代理对象调用方法"+ price);
    }
}

//		  目标类中，执行sell目标方法
//        淘宝商家，给你返一个优惠券，或者红包
//        sell
//        目标类中，执行test方法
//        淘宝商家，给你返一个优惠券，或者红包
//        test
//        111.0
//        通过代理对象调用方法110.0

```



> 前面已经把参数给讲得很清楚了，首先讲`InvocationHandler`，这里的`invoke`方法就是代理类中进行处理的方法，就是静态代理中的sell，只不过一些代码进行了替换，本来是通过传进来的参数的厂商调用sell方法获得成本价的，现在直接都拆开来，厂商通过构造器获得，sell方法通过method获得（只不过如果接口中有多个方法，你怎么 能分清是哪个方法？注意：接口中的方法都会通过`InvocationHandler`的`invoke`方法，所以我觉得这里还可以再扩展下，还可以进行反射，像`BaseServlet`那里一样，我猜的，所以如果这里的两个方法运行同一段程序诶，这个还是很危险的，很容易报错，所以应该还有别的措施），现在把代理类中的方法写完了，感觉基本上差不多了吧，差的就是如何联系起来，这里面就用到了反射了，这个底层 的代码我就没那么懂了，先学到这里，后面学更多东西的时候再看源码。

> 增强功能的扩展：在开发过程中，别人写了一些代码，实现了一些功能，但是对于我开发的项目不够用，需要再添加一些东西，怎么办？ 我不能去改他的源码，比如我要在输出的结果之上都乘个2，那这段代码就可以用到代理模式，注意，代理模式用到最多的功能时增强，而不是控制访问，那乘2的代码写哪？就写到淘宝发优惠券那里就行了，