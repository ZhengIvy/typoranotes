## 1.反射机制概述

![image-20200802102306740](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200802102306740.png)

![image-20200802102416741](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200802102416741.png)

![image-20200802103828466](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200802103828466.png)

> 这个讲的蛮形象的就是正常方式是 包->实例化->取得实例化对象
>
> 反射就反过来 实例化对象-> getClass()方法->得到完整的包类名称

![image-20200802104016164](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200802104016164.png)

![image-20200802104105267](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200802104105267.png)

> Class 可以作为类的类。举了个例子，Dog类和Person类可以再抽出一个共有的类。。 之前没想到这样子 我以为是`Person1` 和`Person2`共有的

```java
/**
 *
 */
public class ReflectionTest {
    //反射之前，对于Person的操作
    @Test
    public void test1(){
        //1.创建Person类的对象
        Person p1 = new Person("Tom",12);

        //2.通过对象，调用其内部的属性、方法
        p1.age = 10;
        System.out.println(p1.toString());
        p1.show();

        //在Person类外部，不可以通过Person类的对象调用其内部私有结构。
        //比如：name、showNation()以及私有的构造器
    }

    //反射之后
    @Test
    public void test2() throws IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchMethodException, NoSuchFieldException {
       Class clazz =  Person.class;
       //1.通过反射，创建Person类对象
       Constructor cons = clazz.getConstructor(String.class, int.class);
        Person p = (Person) cons.newInstance("Tom", 12);
        System.out.println(p.toString());
//        //咋连toString 方法一起继承了？
//        Object obj = cons.newInstance("Tom",12);
//        System.out.println(obj.toString());

        //2.通过反射，调用对象指定的属性、方法
        //调用属性
        Field age = clazz.getDeclaredField("age");
        age.set(p,10);
        System.out.println(p.toString());
        //调用方法
        Method show = clazz.getDeclaredMethod("show");
        show.invoke(p);

        System.out.println("********************");

        //通过反射，可以调用Person类的私有结构。比如：私有的构造器，方法、属性
        Constructor cons1 = clazz.getDeclaredConstructor(String.class);
        cons1.setAccessible(true);
        Person p1 = (Person) cons1.newInstance("Jerry");
        System.out.println(p1.toString());

        //调用私有的属性
        Field name = clazz.getDeclaredField("name");
        name.setAccessible(true);
        name.set(p1,"Hanna");
        System.out.println(p1);

        //调用私有的方法
        Method showNation = clazz.getDeclaredMethod("showNation", String.class);
        showNation.setAccessible(true);
        //相当于p1.showNation("中国"),返回值是对应方法的返回值
        String nation = (String) showNation.invoke(p1, "中国");
        System.out.println(nation);
    }
}

```

### 疑问

1. 通过直接new的方式或反射的方式可以调用公共的结构，开发中到底用哪个？

   建议：直接用new

2. 反射机制与面向对象的封装性是不是矛盾的，如何看待这两个技术？

   不矛盾，前者是可以调用私有，后者是建议调用公共

> 为什么要使用反射？ 什么时候使用？
>
> 前面也讲过了，反射是动态的，这说明你不知道创建哪个类的时候是使用反射的时候比较合适的。就比如说BaseServlet，你不确定他过来是要使用登录功能，注册功能还是别的，在运行的时候才能确定使用的类

### (1). 类加载的过程

![image-20200803162842454](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200803162842454.png)

![image-20200803162938439](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200803162938439.png)

![image-20200803163451089](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200803163451089.png)

![image-20200803164557227](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200803164557227.png)

![image-20200803164659651](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200803164659651.png)

> 这三个过程看的还是有些懵逼的哈，只是对类加载器有一些了解，根据上面那张图，那就写的是，先对类变量设置默认值，为0的那种，初始化就是再赋上应该赋的值

![image-20200803174934504](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200803174934504.png)

![image-20200803175039508](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200803175039508.png)

#### a.四种获取Class的实例的方式

```java
/*
    关于java.lang.Class类的理解
    1.类的加载过程：
    程序经过javac.exe命令之后，会生成一个或多个字节码文件(.class结尾),

    接着我们使用java.exe命令对某个字节码文件进行解释运行。
    相当于将某个字节码文件加载到内存中。此过程就称为类的加载。
    加载到内存中的类，我们就称为运行时类，
    此运行时类，就作为Class的一个实例。

    2.换句话说，Class的实例就对应着一个运行时类
    (我觉得这句话已经基本算是说的清楚了，比如 Class clazz = Person.class 右边当程序运行时就是
    字节码文件加载到内存中作为一个运行时类，而Class的实例也就是左边对应一个运行时类，那就刚好了)
    3.加载到内存中的运行时类，会缓存一定的时间，在此时间之内，我们可以通过不同的方式来获取运行时类

     */

    /**
     * 获取Class的实例的方式（前三种方式需要掌握）
     */
    @Test
    public void test3() throws ClassNotFoundException {
        //方式一：调用运行时类的属性: .class
        Class clazz1 = Person.class;
        System.out.println(clazz1);

        //方式二：通过运行时类的对象,调用getClass()
        Person p1 = new Person();
        Class clazz2 = p1.getClass();
        System.out.println(clazz2);

        //方式三：调用Class的静态方法：forName(String classPath),使用
        // 频率最高
        Class clazz3 = Class.forName("Reflection.Person");
        System.out.println(clazz3);

        //true
        System.out.println(clazz1 == clazz2);
        //true
        System.out.println(clazz1 == clazz3);

        //方式四：类的加载器：ClassLoader
        ClassLoader classLoader = ReflectionTest.class.getClassLoader();
        Class clazz4 = classLoader.loadClass("Reflection.Person");
        System.out.println(clazz4);
    }
}

```

#### b.利用classLoader读取properties的属性

```java
public class ClassLoaderTest {

    @Test
    public void test1(){
        //对于自定义类，用系统类加载器进行加载
        ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();
        System.out.println(classLoader);
        //调用系统类加载器的getParent():获取扩展类加载器
        ClassLoader classLoader1 = classLoader.getParent();
        System.out.println(classLoader1);
        //调用扩展类加载器的getParent():无法获取引导类加载器
        //引导类加载器主要负责加载java的核心库类，无法加载自定义类
        ClassLoader classLoader2 = classLoader1.getParent();
        System.out.println(classLoader2);


    }
    /*
    Properties:用来读取配置文件

     */
    @Test
    public void test2()throws Exception{

        Properties pros = new Properties();
        //此时的文件默认在当前的module下
        //读取配置文件的方式一
//        FileInputStream fis  = new FileInputStream("jdbc.properties");
//        pros.load(fis);

        //读取配置文件的方式二：使用ClassLoader
        //配置文件默认识别为：当前module的src下
        ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();
        //用不了绝对路径不知道为啥子
        InputStream is = classLoader.getResourceAsStream("jdbc.properties");
        pros.load(is);

        String user = pros.getProperty("user");
        System.out.println(user);
        String password = pros.getProperty("password");
        System.out.println(password);
    }
}

```

### (2).通过反射创建对应的运行时类的对象

```java
public class NewInstanceTest {

    /**
     * @throws IllegalAccessException
     * @throws InstantiationException
     */
    @Test
    public void test1() throws IllegalAccessException, InstantiationException {

        Class clazz = Person.class;
        /*
        newInstance():调用此方法，创建对应运行时类的对象，内部调用了运行时类的空参构造器，
        要创建对象就必须有构造器。只不过有时是直接new，有时以方法的形式呈现。

        要想此方法正常地创建运行时类的对象，要求：
        1.运行时类必须提供空参的构造器
        2.空参的构造器的访问权限得够。通常设置为public。


        在javabean中要求提供一个public的空参构造器，原因：
        1.便于通过反射，创建运行时类的对象
        2.便于子类继承此运行时类时，默认调用super()，保证父类有此构造器

        一般创建对象的话用这种比较多，因为要考虑到通用性，前面的时候使用过Constructor来创建对象的话通用性不好，
        因为参数不一定是一样的
         */
        Object obj = clazz.newInstance();
        System.out.println(obj);
    }

```

#### 反射的动态性体现

```java
  @Test
    public void test2(){
        int num = new Random().nextInt(3);//0,1,2
        String classPath = "";
        switch (num){
            case 0:
                classPath = "java.util.Date";
                break;
            case 1:
                //出现了Instantiation 的问题代表着这个类无空参构造器
                classPath = "java.sql.Date";
                break;
            case 2:
                classPath = "Reflection.Person";
                break;
        }
        Object obj = null;
        try {
            obj = getInstance(classPath);
            System.out.println(obj);
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (InstantiationException e) {
            e.printStackTrace();
        }


    }
    /*
    创建一个指定类的对象
    classPath:指定类的全类名
     */
    public Object getInstance(String classPath) throws ClassNotFoundException, IllegalAccessException, InstantiationException {
        Class clazz = Class.forName(classPath);
        return clazz.newInstance();
    }
```

### (3).获取运行时类的丰富结构

对应的javabean、接口和注解

```java
public class Creature<T> implements Serializable {
    private char gender;
    public double weight;

    private void breath(){
        System.out.println("生物呼吸");
    }
    public void eat(){
        System.out.println("生物吃东西");
    }

}

@MyAnnotation(value = "hi")
public class PersonBean extends Creature<String> implements Comparable<String>,MyInterface{
    private String name;
    int age;
    public int id;

    public PersonBean(){}
    @MyAnnotation(value = "abc")
    private PersonBean(String name){
        this.name = name;
    }
     PersonBean(String name,int age){
        this.name = name;
        this.age = age;
    }
    @MyAnnotation
    private String show(String nation){
        System.out.println("我的国籍是" + nation);
        return nation;
    }

    public String display(String interests,int age)throws NullPointerException,ClassCastException {
        return interests + age;
    }
    @Override
    public  void info() {
        System.out.println("我是一个人");
    }

    @Override
    public int compareTo(String o) {
        return 0;
    }

    private static void showDesc(){
        System.out.println("我是一个可爱的人");
    }

    @Override
    public String toString() {
        return "PersonBean{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", id=" + id +
                '}';
    }
}


```

```java
public interface MyInterface {
    void info();
}

```

```java
@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE, MODULE})
@Retention(RetentionPolicy.RUNTIME)
public @interface MyAnnotation {
    String value() default "hello";

}
```



```java
/**
 * 获取当前运行时类的所有属性结构
 */
public class FieldTest {
    @Test
    public void test1(){
        Class clazz = PersonBean.class;

        //获取属性结构
        //getFields():获取当前运行时类及其父类中声明为public访问权限的属性
        Field[] fields = clazz.getFields();
        for (Field f : fields){
            System.out.println(f);
        }
        System.out.println("*********************");

        //getDeclaredFields():获取当前运行时类中声明的所有属性。（不包含父类中声明的属性）
        Field[] declaredFields = clazz.getDeclaredFields();
        for(Field f : declaredFields){
            System.out.println(f);
        }
    }

    /**
     * 权限修饰符 数据类型 变量名
     */
    @Test
    public void test2(){
    Class clazz = PersonBean.class;
    Field[] declaredFields = clazz.getDeclaredFields();
    for (Field f : declaredFields){
        //1.权限修饰符
        //竟然是int？而不是String，因为他里面是这么规定的。
        int modifiers = f.getModifiers();
//        System.out.println(modifiers);
        //想要获得public private 的话就可以这样转变
        System.out.println(Modifier.toString(modifiers)+"\t");
        //2.数据类型
        Class<?> type = f.getType();
        //获取当前数据类型的名字 如果没有的话java.lang.String	会被写成class java.lang.String
        System.out.println(type.getName()+"\t");
        //3.变量名/**
 * 获得运行时类的方法结构
 */
public class MethodTest {

    @Test
    public void test1(){
        Class clazz = PersonBean.class;

        //getMethods():获取当前运行时类及其所有父类中声明为public 权限的方法
        Method[] methods = clazz.getMethods();
        for (Method m :methods){
            System.out.println(m);
        }
        //getDeclaredMethods():获取当前运行时类中声明的所有方法(不包含父类中声明的方法)
        Method[] declaredMethods = clazz.getDeclaredMethods();
        for(Method m :declaredMethods){
            System.out.println(m);
        }
    }

    /**
     * 权限修饰符  返回值类型  方法名(参数类型1 形参名1，...)throws xxxException
     */
    @Test
    public void test2() {
        Class clazz = PersonBean.class;
        Method[] declaredMethods = clazz.getDeclaredMethods();
        for (Method m : declaredMethods) {
//            System.out.println(m);
            //1.获取方法声明的注解
            Annotation[] annos = m.getAnnotations();
            for(Annotation a :annos){
                System.out.println(a);
            }
            //2.权限修饰符
            System.out.print(Modifier.toString(m.getModifiers())+"\t");

            //3.返回值类型
            System.out.println(m.getReturnType().getName()+"\t");

            //4.方法名
            System.out.println(m.getName());
            System.out.print("(");
           //5.形参列表
            Class[] parameterTypes = m.getParameterTypes();
            if(!(parameterTypes == null || parameterTypes.length == 0)){
                for (int i = 0; i<parameterTypes.length;i++){
                    if(i == parameterTypes.length -1){
                        System.out.print(parameterTypes[i].getName() +"args_" +i);
                        break;

                    }
                    System.out.print(parameterTypes[i].getName() +"args_" +i+",");
                }
            }
            System.out.print(")");



            //6.抛出的异常
            Class[] exceptionTypes = m.getExceptionTypes();
            if(!(exceptionTypes == null || exceptionTypes.length == 0)){
                System.out.print("throws ");
                for (int i = 0; i < exceptionTypes.length; i++) {
                    if (i == exceptionTypes.length - 1) {
                        System.out.print(exceptionTypes[i].getName());
                        break;
                    }
                    System.out.print(exceptionTypes[i].getName() + ",");
                }
            }
            System.out.println();



        }
    }
}

        String name = f.getName();
        System.out.println(name);
        System.out.println();
    }
    }
}

```

```java
public class OthreTest {

    @Test
    public void test1(){
        Class clazz = PersonBean.class;
        //getConstructors():获取当前运行时类中声明为public的构造器(没有父类的，因为也没必要)
        Constructor[] constructors = clazz.getConstructors();
        for(Constructor c :constructors){
            System.out.println(c);
        }

        System.out.println();
//      getDeclaredConstructors():获取当前运行时类中声明的所有构造器
        Constructor[] declaredConstructors = clazz.getDeclaredConstructors();
        for(Constructor c :declaredConstructors){
            System.out.println(c);
        }
    }

    /**
     * 获取运行时类的父类
     */
    @Test
    public void test2(){
        Class clazz = PersonBean.class;

        Class superclass = clazz.getSuperclass();
        System.out.println(superclass);
    }

    /**
     * 获取运行时类带泛型的父类
     */
    @Test
    public void test3(){
        Class clazz = PersonBean.class;

        Type genericSuperclass =  clazz.getGenericSuperclass();
        System.out.println(genericSuperclass);
    }


    /**
     * 获取运行时类带泛型的父类的泛型
     */
    @Test
    public void test4(){
        Class clazz = PersonBean.class;

        Type genericSuperclass =  clazz.getGenericSuperclass();
        System.out.println(genericSuperclass);

        ParameterizedType paramType = (ParameterizedType) genericSuperclass;
        //获取泛型类型,为什么是数组？ 因为有可能还是Map<?,String>类型
        Type[] actualTypeArguments = paramType.getActualTypeArguments();
//        System.out.println(actualTypeArguments[0].getTypeName());
        //Class实现Type
        System.out.println(((Class)actualTypeArguments[0]).getName());
    }

    /**
     * 获取运行时类实现的接口
     */
    @Test
    public void test5(){
        Class clazz = PersonBean.class;
        //拿到接口，不含父类的
        Class[] interfaces = clazz.getInterfaces();
        for(Class c :interfaces){
            System.out.println(c);
        }

        System.out.println();
        //获取运行时类的父类实现的接口
        Class[] interfaces1 = clazz.getSuperclass().getInterfaces();
        for(Class c : interfaces1){
            System.out.println(c);
        }
    }

    /**
     * 获取运行时类所在的包
     */
    @Test
    public void test6(){
        Class clazz = PersonBean.class;

        Package pack = clazz.getPackage();
        System.out.println(pack);
    }

    /**
     * 获取运行时类声明的注解
     */
    @Test
    public void test7(){
        Class clazz = PersonBean.class;
        Annotation[] annotations = clazz.getAnnotations();
        for(Annotation annos : annotations){
            System.out.println(annos);
        }
    }
}

```

### (4).调用运行时类中指定的结构：属性、方法、构造器

```java
/**
 * 调用运行时类中指定的结构：属性、方法、构造器
 */
public class ReflectionTest {

    @Test
    public void test1() throws NoSuchFieldException, IllegalAccessException, InstantiationException {
        Class clazz = PersonBean.class;
        //创建运行时类的对象
        PersonBean person  = (PersonBean) clazz.newInstance();
        //获取指定的属性:要求运行时类中属性声明为public
        //通常不采用此方法
        Field id = clazz.getField("id");

        //想要给非静态的属性设值，要依赖于对象
        //set():参数1:指明设置哪个对象的属性  参数2：将此属性值设置为多少
        id.set(person,1001);

        //获取当前属性的值
        //get():参数1：获取哪个对象的属性值
        int pId = (int) id.get(person);
        System.out.println(pId);
    }
    /*
    如何操作运行时类的指定的属性 -- 需要掌握
     */
    @Test
    public void testField1() throws IllegalAccessException, InstantiationException, NoSuchFieldException {
        Class clazz = PersonBean.class;
        //创建运行时类的对象
        PersonBean person  = (PersonBean) clazz.newInstance();

        //getDeclaredField(String fieldName):获取运行时类中指定变量名的属性
        Field name = clazz.getDeclaredField("name");
        //默认不修改私有的，之前都是获取，并没有修改，所以这里想要修改需要设置true
        //保证当前属性可访问的
        name.setAccessible(true);
        //获取、设置指定对象的此属性值
        name.set(person,"Tom");
        System.out.println(name.get(name));

    }

    /**
     * 如何操作运行时类的指定的方法 -- 需要掌握
     */
    @Test
    public void testMethod() throws IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException {
        Class clazz = PersonBean.class;

        //创建运行时类的对象
        PersonBean p  = (PersonBean) clazz.newInstance();

        //1.获取指定的某个方法
        //getDeclaredMethod():参数1 ：指明获取的方法的名称   参数2 ：指明获取方法的形参列表
        Method show = clazz.getDeclaredMethod("show", String.class);
        //2.保证当前方法可访问的
        show.setAccessible(true);

        /*
        invoke():参数1:方法的调用者  参数2：给方法形参赋值的实参
        invoke()的返回值即为对应类中调用的方法的返回值
         */
        Object chn = show.invoke(p, "CHN");//String nation = p.show("CHN");
        System.out.println(chn);

        System.out.println("***************如何调用静态方法*********");

        //private static void showDesc()
        Method showDesc = clazz.getDeclaredMethod("showDesc");
        showDesc.setAccessible(true);
        /*showDesc.invoke(null);
        也是可以的。因为静态方法不需要实例化对象呀。
        那你直接填个null也是行的

         */
        showDesc.invoke(PersonBean.class);
    }
    /**
     * 如何操作运行时类的指定的构造器
     */
    @Test
    public void testConstructor() throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {
        Class clazz = PersonBean.class;

        //private PersonBean(String name)
        //1.获取指定的构造器,不用输入名字了，构造器的名字他也知道的
        //getDeclaredConstructor():参数: 指明构造器的参数列表
        Constructor declaredConstructor = clazz.getDeclaredConstructor(String.class);

        //2.保证构造器是可访问的
        declaredConstructor.setAccessible(true);

        //3.调用此构造器创建运行时类的对象
        PersonBean per = (PersonBean) declaredConstructor.newInstance("Tom");
        System.out.println(per);
    }

}

```

