## 1.标识符

Java 对各种变量、方法和类等要素命名时使用的字符序列称为标识符

技巧：凡是可以自己起名字的地方都叫标识符

> 定义合法标识符规则：
>
> 1. 由26个英文字母大小写，0-9,_或$组成
> 2. 数字不可以开头
> 3. 不可以使用关键字和保留字，但能包含关键字和保留字
> 4. Java中严格区分大小写，长度无限制
> 5. 标识符不能包含空格

![image-20200807131505597](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200807131505597.png)

## 2.变量的分类

![image-20200807132923486](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200807132923486.png)

![image-20200807133428026](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200807133428026.png) 

### byte short int long

![image-20200823093939016](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200823093939016.png)

> 需要知道的点是表数范围，之前我一直都记不住哈。但是想想还是蛮好记的，拆成两半，正一半，负一半，0算正数，所以正数要减个一
>
> **注意：long型如果不加L就视为int型，当赋值未超过int型的取值范围，后面可以省略，超过的话就必须加，不然估计会报错**

### float double

![image-20200823094221955](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200823094221955.png)

> 1. 浮点型表示带小数点的数值‘
>
> 2. float存储数值的范围比long还大
>
> 3. 定义float类型的变量时要以`f` 或`F`结尾
>
>    **注意说明一下：不加F的时候默认为double，所以必须加**
>
> 4. 通常定义浮点型变量时使用double

### char

一个字符= 2 字节

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200823100725219.png" alt="image-20200823100725219" style="zoom: 80%;" />

> 三种表示方式
>
> 1. 声明一个字符
>
> 2. 转义字符;
>
>    ```java
>    char c = '\n';//换行符
>    System.out.print("hello" + c5);
>    System.out.println("world");
>    //hello
>    //world
>    ```
>
> 3. 直接使用Unicode 值来表示字符型常量
>
>    ```java
>    char c6 = '\u0043';
>    System.out.println(c6);//c
>    ```
>
> 总结: 之前我都是对后面两种几乎无了解的，还有如果是`char c1  =''`,那这样是不通过的，必须为1个

### 转义

```java
System.out.println("大家好，\n 我是xxx");
//问下这个\n 是直接输出还是换行了？
//当然是换行了，如果想要直接输出的话，要转义的
System.out.println("大家好， \\n 我是xxx");
```

### 基本数据类型之间的运算规则:

1. 自动类型提升

   ```java
   byte b1 = 2;
   int i1 = 129;
   //编译不通过
   //byte b2 = b1 + i1;
   int i2 = b1 + i1;
   long l1 = b1 + i1;
   System.out.println(i2);
   
   float f  = b1 + i1 ;
   System.out.println(f);//131.0
   ```

   当容量小的数据类型的变量与容量大的数据类型的变量做运算时，结果自动提升为容量大的类型

   说明:此时的容量大小指的是，表示数的范围的大和小，比如float容量要大于long 的容量

   `byte、short、char--->int -->long-->float-->double`

   **特别的:当byte、char、short 三种类型的变量做运算时，结果为int型,这之间自身相加也是**

   (可能会溢出把？)

   ```java
   char c1 = 'a';//97
   int i3 = 10;
   int i4 = c1 + i3;
   System.out.println(i4);
   
   short s2  = 10;
   //char c2  = c1 + s2;//编译不通过
   byte b2 = 10;
   //char c3 = c1 +b2;//编译不通过
   
   //short s3 = b2 + s2;//编译不通过
   
   //byte b3 = b1 + b2;编译不通过
   ```

2. 强制类型转换

   自动类型提升运算的逆运算

   1. 需要使用强转符:()
   2. 注意点:强制类型转换，可能导致精度损失

   ```java
   double d1 = 12.3;
   int i1 = (int)d1;//截断操作
   System.out.println(i1);
   
   //没有精度损失
   long l1 = 123;//这里没加也可以的，因为默认是int，但是没超过范围
   short s2 = (short)l1;
   
   //精度损失举例2
   int i2 = 128;
   byte b = (byte)i2;
   System.out.println(b);//-128
   ```

   

   

   ### 变量规范

   1. 整型常量，默认类型为int型
   2. 浮点型常量，默认类型为double型

## 3. String

> 1. String 属于引用类型数据，翻译为字符串
> 2. 声明String类型变量时，使用一对""
> 3. String可以和8中基本数据类型变量做运算，且运算只能是连接运算： +
> 4. 运算的结果仍然是String类型

### 练习

```java
char c = 'a';//97
int num = 10;
String str  ="hello";
System.out.println(c + num + str);//107hello
    System.out.println(c +str + num);//aherllo10
    System.out.println(c+ (num + str));//a10hello
    System.out.println((c + num)+ str);//107hello
    System.out.println(str + num + c);//hello10a
```

```java
String str2  = 3.5f + "";//3.5
```

注意这个不是3.5f哈，他只是代表那个数是浮点数罢了

## 3. 进制

![image-20200823164158066](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200823164158066.png)

![image-20200823165224884](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200823165224884.png)

![image-20200823171552556](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200823171552556.png)

> 诶总的来说，补码和反码都是用在负数上面的，正数的反码和补码是相同的(规定好的啊)，

![image-20200823173744532](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200823173744532.png)

![image-20200823174151155](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200823174151155.png)

> 解释一下，128和-128的二进制实际上都是1000 0000 ，那怎么区分呢？ 就要看前面是否还有位了，因为一般第一位会被视为符号位，所以int型是32位的，符号位在前面，所以表示的就是128，但是byte的话一共就8，所以的话刚好最高位是符号位了，所以也只能取-128了

### 十进制转二进制

![image-20200823174640933](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200823174640933.png)

记起来了些

### 二进制转八进制，十六进制

![image-20200823175352856](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200823175352856.png)

## 算术运算符

![image-20200824145711514](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200824145711514.png)

![image-20200824145727473](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200824145727473.png)

![image-20200824150049828](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200824150049828.png)

![image-20200824175409413](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200824175409413.png)

加完之后是-128

![image-20200824181526129](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200824181526129.png)

如果是不按这种写法来乘的话，编译估计会报错把，因为小数的话默认是double型，乘起来 应该赋值给double才对

![image-20200824182751009](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200824182751009.png)

看结果哈喽

###  & 与 && 的区别

> 相同点: 
>
> 1. 运算结果相同
> 2. 当符号左边是true时，二者都会执行符号右边的运算。
>
> 不同点：当符号左边是false时，&继续执行符号右边的运算，&&不再执行符号右边的运算。

| 与 || 也是一个道理

### 位移运算符	

![image-20200825105754869](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200825105754869.png)

往左移(如果是二进制的话就每移一个乘2)，但是要注意的是会出现溢出的问题，就像上面的最后一个，变成负数了

**结论：**

1. 位运算符操作的都是整形的数据
2. << : 在一定范围内，每向左移1位，相当于 * 2
3. `>>` 在一定范围内，每向右移一位，相当于/2

![image-20200825110607081](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200825110607081.png)

![image-20200825110838912](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200825110838912.png)

> 这个也很有趣哈

### 数据交换的三种方式

```java
//第一种，是最普遍的，也是最常用的
//推荐的方式
int temp = num1;
num1 = num2;
num2 = temp;

//方式二: 好处：不用定义临时变量
//弊端：1.相加操作可能超出存储范围 2.局限性：只能适用于数值类型
num1 = num1 + num2;
num2 = num1 -num2;
num1 = num1 - num2;

//方式三：使用位运算符
//有局限性：只能适合于数值类型
num1 = num1 ^ num2;
num2 = num1 ^ num2;
num1 = num1 ^ num2;
```

![image-20200825115135945](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200825115135945.png)

> 说下第二种和第三种分别是什么意思哈，第二种相当于只在两个变量中进行交换，你可以理解为有两个木块AB，要交换的话A木块先跳到B木块上，然后B木块跳到A位置上，接着A位置就顺势跳下来。
>
> 第三种的话看 可以这么理解， 有一个中间值`num1 ^ num2`,这时候只要任意异或一个 num1 num2 就可以得到 num2 num1 的值，所以大体就是这样啦

## 程序流程控制

分为三种结构

![image-20200825122759029](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200825122759029.png)

看看

## Scanner

```java
/*
如何从键盘获取不同类型的变量：需要使用Scanner类
具体实现步骤：
1.导包
2.Scanner实例化
3.调用Scanner类的相关方法，来获取指定类型的变量

*/

Class ScannerTest{
	public static void main(String[] args){
        Scanner scan = new Scanner(System.in);
        int num = scan.nextInt();
        String name = scan.next();
        int age = scan.nextInt();
        double weight = scan.nextDouble();
        boolean i = scan.nextBoolean();
        
        //对于char型的获取，Scanner没有提供相关的方法，只能获取一个字符串
        System.out.println(num);
    
    }
}


```

## 数组

```java
int ides;//声明
//1.1 静态初始化:数组的初始化和数组元素赋值操作同时进行
ids = new int[]{1001,1002,1003};

//1.2 动态初始化：数组的初始化和数组元素赋值操作分开进行
String[] names = new String[5];

//不要动静结合
//int arr1 = new int[3]{1,2,3}; 这个是错 的
```

### 数组元素的默认初始化值

1. 数组元素是整型：0

2. 浮点型：0.0

3. char型：0 或'\u0000'，而非'0'

   ```java
   char[] arr1 = new arr[4];
   for(int i = 0;i< arr1.length;i++){
       Sysrem.out.println("*****"+arr1[i] + "****");
   }
   /*
   **** ****
   **** ****
   **** ****
   **** ****
   
   这里实际上应该表示null的意思吧，你想拼接的时候要和string一起，那就跟unicode码进行转，结果就是null
   */
   
   
   if(arr1[0] == 0){
       System.out.println("你好");
   }
   //的确输出了
   ```

4. boolean ：false

5. 引用数据类型的: null

### 内存解析

![image-20200826112334442](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200826112334442.png)

> 我主要学到的是地址值是十六进制的
>
> 还有数组会默认初始化值，估计在堆中的都是这样

### 二维数组的默认初始化值

针对初始化方式一：比如：`int[][] arr = new int[4][3];` 外层元素的初始化值为地址值，内层元素的初始化值为：与一位数组初始化相同

初始化方式二：比如：`int[][] arr = new int[4][];`，外层元素的初始化值为null，内层元素的初始化值为：不能调用，否则报错

> 说下，感觉和之前学的c的好像不大一样啊，我记得的是对于一个二维数组而言 `arr,arr[0],arr[0][0];`的地址都是相同的，~~但这里并不是，所以也导致了第二种方式，外层初始化值为null，就感觉不是紧密衔接的，中间还留了一些地址，所以的话地址值不一致~~     这里的原因的话来了，那到底是我的c学得有问题，还是啥？我以为是在数组内部开辟空间，但并不是的哈，而是在该空间内放入地址值，指向内部元素的数组。看，如图，有趣哈

![image-20200826152630401](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200826152630401.png)

懂了

### 杨辉三角算法

```java
public class YangHuiTest {
    public static void main(String[] args) {
        //1.声明并初始化二维数组
        int[][] yangHui = new int[10][];

        //2.给数组的元素赋值
        for (int i = 0; i < yangHui.length; i++) {
            yangHui[i] = new int[i + 1];

            //2.1 给首末元素赋值
            yangHui[i][0] = 1;
            yangHui[i][i] = 1;
            //2.2 给每行的非首末元素赋值
            if(i > 1) {
                for (int j = 1; j < yangHui[i].length-1; j++) {
                    yangHui[i][j] = yangHui[i-1][j-1] +yangHui[i-1][j];
                }
            }
        }

        //3.遍历二维数组
        for (int i = 0; i < yangHui.length; i++) {
            for(int j = 0;j <yangHui[i].length;j++){
                System.out.print(yangHui[i][j] + " ");
            }
            System.out.println();
        }
    }

}

```

### 随机数

```java
/**
 * 定义一个int型的一维数组，包含10个元素，分别赋一些随机整数，然后求出所有元素的最大值，最小值和值，
 * 要求：所有的随机数都是两位数
 * [10,99]
 * 公式: (int)(Math.random() *(99-10+1) +10)
 * 因为返回的是double 型的值
 */
public class ArrayTest1 {
    public static void main(String[] args) {
        int[] arr = new int[10];

        for(int i = 0;i <arr.length;i++){
            arr[i] = (int)(Math.random()  * (99-10 + 1) + 10);
        }
        //求数组元素的最大值
        int maxValue =  arr[0];
        for (int i = 0; i < arr.length; i++) {
            if(maxValue < arr[i]){
                maxValue = arr[i];
            }
        }
        System.out.println("最大值为: " + maxValue);
        //后面就没写了，因为基本是一样的
        //求数组元素的最小值
        //求数组元素的总和
        //求数组元素的平均数
    }

}

```

### BubbleSort

```java
public class BubbleSortTest {
    public static void main(String[] args) {
        int[] arr = new int[]{43,32,76,-89,0,64,33,-21,32,99};

        //冒泡排序
        for (int i = 0; i < arr.length - 1; i++) {

            for (int j = 0; j < arr.length - i - 1; j++) {

                if(arr[j] > arr[j + 1]){
                    int temp = arr[j];
                    arr[j] = arr[j+1];
                    arr[j+ 1] = temp;
                }
            }
        }
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + "\t");
        }
    }
}

```

> 怎么说呢，还有其他的，但是我没写，是因为跟c的代码差不了多少，而且我想重点放在数据结构里面去学

### Arrays 工具类

> 因为java已经封装好了，所以里面的算法不用写，所以我们可以直接调用方法

```java
/**
 * java.util.Arrays: 操作数组的工具类，里面定义了很多操作数组的方法
 */
public class ArraysTest {
    public static void main(String[] args) {
        //1.boolean equals(int[] a,int[] b):判断两个数组是否相等
        int[] arr1 = new int[]{1,2,3,4};
        int[] arr2 = new int[]{1,3,2,4};
        boolean equals = Arrays.equals(arr1, arr2);
        System.out.println(equals);

        //2.String toString(int[] a):输出数组信息,我感觉我经常用但是却忽略了他是从哪儿来的了，就不需要你自个儿去for循环
        System.out.println(Arrays.toString(arr1));

        //3.void fill(int[] a,int val):将指定值填充到数组中
        Arrays.fill(arr1,10);
        System.out.println(Arrays.toString(arr1));

        //4.void sort(int[] a):对数组进行排序
        Arrays.sort(arr2);
        System.out.println(Arrays.toString(arr2));

        //5.int binarySearch(int[] a,int key),如果没找到返回某负值
        int[] arr3 = new int[]{1,2,3,4,5,6};
        System.out.println(Arrays.binarySearch(arr3,3));
    }
}

```



-------------------------------------------2020.9.2 anki到这里-----------------------------------------------

## 面向对象

> 一、java面向对象学习的三条主线：
>
> 1. java类及类的成员：属性、方法、构造器；代码块、内部类
> 2. 面向对象的三大特征：封装性、继承性、多态性、(抽象性)
> 3. 其他关键字：this、super、static、final、abstract、interface、package、import

### 面向过程与面向对象的区别

> 强调的是功能行为，以函数为最小单位，考虑怎么做。
>
> 1. 把冰箱打开
> 2. 抬起大象，塞进冰箱
> 3. 把冰箱门关闭

面向对象：

> 强调具备了功能的对象，以类/对象为最小单位，考虑谁来做

### 两个要素

类：对一类事物的描述，是抽象的，概念上的定义

对象：是实际存在的该类事物的每个个体，因而也称为实例

```java
/*
设计类，就是设计类的成员

属性 = 成员变量 = field = 域、字段
方法 = 成员方法 = 函数 = method
*/
public class PersonTest{
    //属性
    String name;
    //方法
    public void eat(){
        System.out.println("人可以吃饭吗");
    }
}
```

#### 对象的内存解析

1. 堆： 存放对象实例，几乎所有的对象实例都在这里分配内存
2. 栈：指的是虚拟机栈，用于存储局部变量
3. 方法区：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器后的代码等数据

![image-20200829203502546](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200829203502546.png)

很透彻了，之前没有考虑到

### 类中属性的使用

属性(成员变量) vs 局部变量

1. 相同点：

   1. 定义变量的格式：数据类型 变量名 = 变量值
   2. 先声明，后使用
   3. 变量都有其对应作用域

2. 不同点：

   1. 在类中声明的位置的不同

      属性：直接定义在类的一对{}中

      局部变量：声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量

   2. 关于权限修饰符

      属性：可以在声明属性时，指明其权限，使用权限修饰符

      常用的权限修饰符：private，public，缺省(默认)，protected-----> 封装性

      局部变量：不可以使用权限修饰符

   3. 默认初始化情况

      1. 属性：类的属性，根据其类型，都有默认初始化值

         整形(byte,short,int,long):0

         浮点型(float,double):0.0

         字符型(char):0(或'\u000')

         布尔型(boolean):false

         引用数据类型(类、数组、接口)：null

      2. 局部变量:没有默认初始化值

         意味着在调用之前，一定要显式赋值

         特别地，在形参调用时，赋值即可

   4. 内存中加载的位置

      属性：加载到堆空间中(非static)

      局部变量：加载到栈空间

### 类中方法的声明和使用

方法：描述类中应用的功能

比如：`Math类、sqrt()\random()`





## 理解万事万物皆对象

1. 在java语言范畴中，我们都将功能、结构等封装到类中，通过类的实例化，来调用具体的结构功能
   - Scanner，String等
   - 文件：File
   - 网络资源：url
2. 涉及到java语言与前端html、后端的数据库交互时，前后端的结构在java层面交互时，都体现为类、对象

## 匿名对象的使用

```java
public class InstanceTest{
    public static void main(String[] args){
        Phone p = new Phone();
        //p = null;
        System.out.println(p);
        p.sendEmail();
        p.playGame();
        
        //匿名对象
        new Phone().sendEmail();
        new Phone().playGame();//不同的对象
        //FileInputStream is = new FileInputStream(new File("111.txt"));  也是
    }
}

class Phone{
    double price;
    
    public void sendEmail(){
		System.out.println("发送邮件");
    }
    
    public void playGame(){
        System.out.println("玩游戏");
    }
}
```

## 方法的重载

1. 定义：在同一个类中，允许存在一个以上的同名方法，只要他们的参数个数或者参数类型不同即可。

   两同一不同：同一个类，相同方法名，参数列表不同，个数不同，类型不同

2. 判断是否是重载：

   跟方法的权限修饰符，返回值类型，形参变量名，方法体都没有关系(我一直以为返回值类型是算进去的(当只有返回类型不同的时候)，那看来是记错的，肯定是错的，因为如果可以的话那你到底是想有返回值呢还是不想呢？无法判断，当然不行)

3. 在通过对象调用方法时，如何确定某一个指定的方法：

   方法名 ---> 参数列表

### 可变个数的形参

格式：数据类型 ....  形参名(可以是0个，1个或者多个(但优先是确定好的))

可变个数形参在方法中，最多只能声明一个可变形参（因为可变形参必须在最后一个，所以的话总会有一个不是在最后一个）

```java
public void show(String ... strs){
    System.out.println("啦啦");
}

//public void show(String[] args){  
//} 和上面的不能共存，其实是同一种,上面那个参数可以看作数组,使用的时候可以用数组接受，方便的地方在于你不需要接收参数时创建一个数组了


//The variable argument type String of the method show must be the last parameter
//public void show(String ... strs,int i){} 这个是不行的，编译器不知道怎么分配个数，会晕的，但你说不是可以按照类型来划分吗？首先说不严谨，有些类型是可以转换的，而且，遇到 可变形参和另外一个形参类型相同的时候你怎么分？
```

### 方法的形参的传递机制：值传递

1. 形参：方法定义时，声明的小括号内的参数

   实参：方法调用时，实际传递给形参的值

2. 一个很常见的问题 值交换的时候`swap(int a,int b)`，但是这肯定是不行的，在c中我们经常用的是传地址进去，但在java中我们不常这么做，可以选择`swap(int[] array,int i,int j)`,后面两个表示的是数组中的位置

### 脑筋急转弯

![image-20200830185836325](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200830185836325.png)

![image-20200830185823946](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200830185823946.png)

![image-20200830185857811](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200830185857811.png)

![image-20200830192936913](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200830192936913.png)

> 啥意思？就是你输出char数组的时候你以为是地址值，但实际遍历了这个数组，因为打印里面刚好只有char型数组的这个方法。所以十分地神奇哈

## 面向对象的特征

### 1. 封装性

一、问题的引入

当我们创建一个类的对象以后，我们可以通过“对象.属性”的方式，对对象的属性进行赋值，这里赋值操作要受到数据的数据范围和数据类型的制约，除此之外，没有其他条件，但是在实际当中，我们需要给属性赋值加入额外的限制条件，这个条件不能在属性声明时体现，我们只能通过方法进行限制条件的添加，比如(setLegs():)同时我们需要避免用户再使用“对象.属性”的赋值，则需要将属性声明为私有的，此时，针对于属性就体现了封装性(感觉像是保安一样)

二、封装性的体现之一

我们将类的属性xxx私有化，同时，提供公共的方法来获取

封装性体现：1.如上 2.不对外暴露的私有方法 3. 单例方式



三、封装性的体现，需要权限修饰符来配合

1. java规定的4种权限，从小到大排列(private,缺省、protected，public)

   <img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200831153000819.png" alt="image-20200831153000819" style="zoom:67%;" />

2. 4种权限可以 用来修饰类的内部结构：属性、方法、构造器、内部类

3. 修饰类的话，只能使用:缺省、public

   ![image-20200831155044403](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200831155044403.png)

### 2.构造器

1. 构造器的作用：创建对象 、给属性初始化
2. 说明：
   1. 如果没有显示地定义类的构造器的话，则系统默认提供一个空参构造器
   2. 定义构造器的格式 权限修饰符 类名(形参列表){}
   3. 多个构造器构成重载
   4. 一旦我们显式地定义了类的构造器后，系统就不再提供默认的空参构造器
   5. 一个类中，至少会有一个构造器
   6. 构造器的默认权限和类的权限相同

### 3.属性赋值的先后顺序

1. 默认初始化
2. 显式初始化
3. 构造器赋值
4. 通过对象.方法 或 对象.属性 的方式赋值

顺序也是上面的排序哈

### 4. javabean

> javabean是一种java语言，是指符合如下标准的java类：
>
> 1. 类是公共的
> 2. 有一个无参的公共的构造器
> 3. 有属性，且有对应的get、set方法

### 5. this关键字的使用

1. this可以用来修饰：属性，方法。构造器

2. this修饰属性和方法：

   this理解为当前对象

   在类的方法(类的构造器中也可以)中，我们可以使用"this.属性"或"this.方法"的方式，调用当前对象的属性或方法，但是通常情况下我们都选择省略"this." 特殊情况，如果方法的形参和属性同名时，我们必须显式地使用"this.变量"的方式，表名此变量时属性，而非形参

3. this调用构造器

   1. 我们在类的构造器中，可以显式地使用"this(形参列表)"，调用本类中的其他构造器
   2. 构造器不能通过"this(形参列表)"来调用自己
   3. 如果一个类中有n个构造器，则最多有n-1构造器中使用了"this.(形参列表)"
   4. 规定："this(形参列表)"必须声明在当前构造器的首行
   5. 构造器内部，最多只能声明一个"this(形参列表)"的方式

### 6. import关键字

import：导入

1. 在源文件中显式地使用import结构导入指定包下的类、接口
2. 声明在包的声明和类的声明之间
3. 如果需要导入多个结构，则并列写出即可
4. 可以使用"xxx.*"的方式，表示导入xxx包下的所有结构
5. 如果使用的类或接是java.lang 包下定义的，则可以省略import结构
6. 如果在源文件中使用了不同包下的同名的类，则必须至少有一个类需要以全类名的方式显示
7. 使用"xxx.*"方式表明可以调用xxx包下的所有结构，但是如果使用的是xxx子包下的结构，则仍需要导包(所以本来lang包是不用导的，但因为是lang包的子包下的结构，所以还得导包)
8. import static:导入指定类或接口中的静态结构(比如说你导入 `import static java.lang.System.*`,这样的话就可以直接写为`out.println()了`)

### 7. extends

好处：

1. 减少了代码的冗余，提高了代码的复用性
2. 便于功能的扩展
3. 为之后多态性的使用，提供了前提

体现：

1. 一旦子类A继承父类B以后，子类A中就获取了父类B中声明的所有的属性和方法

   特别的，父类中声明为private的属性或方法，子类继承父类后，仍然认为获取了父类中私有的结构，只是因为封装性的影响，使得子类不能直接调用父类的结构而已(特别！！！！！！！！注意一下，这是我之前不了解的，没往这方面想过)

   ```java
   //比如说Person是个父类
   class Person{
       private int age;
       
       //age 的getter setter方法
   }
   
   //子类
   class Student{
       
       public void show(){
           System.out.println(age);//这是不可以的，你不能碰私有的，那怎么办？
           System.out.println(getAge());//这个才是正确的，所以赋值的话可以通过set赋值
       }
   }
   ```

   

2. 子类继承父类以后，还可以声明自己特有的属性或方法，实现功能的扩展，子类和父类的关系，不同于子集和集合的关系

### 8.重写

1. 子类继承父类以后，可以对父类中同名的同参数的方法，进行覆盖操作

2. 应用：重写以后，当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，实际执行的是子类重写父类的方法

3. 重写的规定：

   1. 约定俗称：子类中的叫重写的方法，父类中的叫被重写的方法

   2. 子类的重写方法的方法名和形参列表和父类被重写的方法的方法名和形参列表相同

   3. 子类的重写的方法的权限修饰符不小于父类被重写方法的权限修饰符(这个倒不是很清楚，一直以为是一样的，可以理解为上面说过的子类一般是父类的扩展，所以的话会更大点，也可以想象要覆盖，覆盖的话最低要求就是一样大)

   4. 特殊情况：子类不能重写父类中声明为private的方法

   5. 返回值类型：

      父类被重写的方法的返回值类型是void，子类重写的方法的返回值类型只能是void

      父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类

      ```java
      //父类中
      public Object show(){
          System.out.println("我在父类中");
      }
      
      //子类
      @Override
      public String show(){
          System.out.println("我在子类中");
      }
      ```

      父类被重写的方法的返回值是基本数据类型，则子类重写的方法的返回值必须是相同的数据类型

   6. 子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型

   7. 子类和父类中的同名同参数的方法要么都声明为非static的(考虑重写)，**要么就都声明为static(不是重写的)的**

   **可以总结为两收一放，权限修饰符是放的，返回值类型和异常时收的**

### 9. super

#### 调用方法和属性

首先需要注意的一点是属性是不会覆盖的，如果子类与父类的属性有同名的话那就是同时存在，这个时候是不会算覆盖的，所以你想要调父类的属性的话，可以使用`super.xx`

1. 我们可以在子类的方法或构造器中，通过使用`super.属性或方法的方式`，显式地调用父类中声明的属性或方法，但是，通常情况下，我们习惯省略`super`
2. 特殊情况，当子类和父类中定义了同名的属性时，我们要想再子类中调用父类声明的属性，则必须显式地使用`super.属性`的方式，表名调用父类中声明的属性(但通常情况下我们一般不会定义重名的)
3. 特殊情况:当子类重写了父类的方法时， 我们想在子类中调用父类的被重写的方法，则必须显式使用`super.方法`的方式

#### 调用构造器

1. 我们可以在子类的构造器中显式地使用`super(形参列表)`,调用父类中声明的指定构造器
2. `super(形参列表)`的使用，必须声明在子类构造器的首行！
3. 我们在类的构造器中，针对`this(形参列表)`或`super(形参列表)`只能二选一，不能同时出现
4. 在构造器的首行，没有显式地声明`this(形参列表)`或`super(形参列表)`，则默认调用的是父类中空参的构造器:`super()`
5. 在类的多个构造器中，至少有一个类的构造器使用了super(形参列表)，调用父类的构造器(emm 我觉得这个是极端的情况下要求你必须选的才是，因为每个构造器都会创建一个的，当创建对象的时候，所以他这个指的情况就是你一定要调this or super的时候，那的确是这样子)

### 子类对象实例化的全过程

1. 从结果来看：(结果上来看)子类继承父类以后，就获取了父类中声明的属性或方法，创建子类对象，在堆空间中，就会加载所有父类中声明的属性
2. 从过程上看：当我们通过子类的构造器创建子类对象时，我们一定会直接或间接地调用其父类的构造器，进而调用父类的父类的构造器，直到调用了java.lang.Object 类中空参的构造器为止，正因为加载过所有的父类结构，所以才可以看到内存中有父类的结构，子类的对象才可以考虑进行调用。
3. 明确：虽然创建子类的对象时，调用了父类的构造器，但是至始自终只创建过一个对象，即为new的子类对象，就像你在构造器中调别的构造器，那也只会创建出一个对象而已

> 总的来说，这个super，是反正会调super的，如果你在创建对象中使用的构造器调了别的构造器，那最后被调的构造器就会用上super的。

**说明**

```java
public class Student extends Person{
    public Student(){
        super(20);
        System.out.println("我是无参的Student构造器");
    }
    public Student(int age){
        super(20);
        System.out.println("我是有参的Student的构造器，我的年龄是"+age);
    }
    public Student(String name){
        this();
        System.out.println("我的名字是"+name);
    }
}
public class Person {
//    public Person(){
//        System.out.println("我在Person的构造器中");
//    }
    public Person(int age){
        System.out.println("我是有参的Person构造器，我今年"+age+"岁");
    }
}
```

> 这里说明一下，父类是不一定需要无参构造器的，但是此时就需要显式地调用其他构造器才可以，因为默认都是调用无参的。
>
> 结合后面的说一下：**如果子类和父类有同名同参的静态方法的话，使用多态时，想调用该方法，调用的是子类的还是父类的。还是其他结果？**
>
> 回答：调不出来，因为能调的前提是子类是塞进父类的模板的，也就是说方法得重写才行，但static的方法不能重写啊，所以结果就是这样子

---------------------------------------------------2020.9.7 anki----------------------------------------------------------------

## 多态性

> 1. 理解多态性：可以理解为一个事务的多种形态
>
> 2. 何为多态性：
>
>    对象的多态性：父类的引用指向子类的对象，子类的对象赋给父类引用
>
> 3. 多态的使用：虚拟方法调用
>
>    虚拟方法：子类中定义了与父类同名同参数的方法，在多态情况下，将此时父类的方法称为虚拟方法，父类根据赋给它的不同子类的对象，动态调用属于子类的该方法，这样的方法调用在编译期是无法确定的。
>
>    有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法。
>
>    总结：编译看左边，运行看右边	
>
> 4. 多态性的使用前提： 
>
>    1. 要有类的继承关系
>    2. 方法的重写
>
> 5. 对象的多态性，只适用于方法，不适用于属性(编译和运行都看左边)
>
> 6. 多态性是运行时行为，因为你最终调用什么方法是运行时才知道的，编译使行为的话你写代码的时候就知道
>
> 7. 重写是运行时多态？(emm 这里的多态指的是表面意思的多态把)，因为编译的时候是不知道你调用的是哪个方法的(编译指的不是写代码的过程，而是把高级语言编程二进制，意思就是纯体力活，不需要动脑子。) 重载是编译时多态，因为编译的时候可以帮你匹配好方法的

```java
public class PersonTest{
    
    public static void main(String[] args){
		//对象的多态性：父类的引用指向子类的对象，这里Person是Man和Woman的父类
        Person p2 = new Man();
        
    	Person p3 = new Woman();
        //多态的使用：当调用子父类同名同参数的方法时，实际执行的是子类重写父类的方法-----虚拟方法的调用
        //当你 CTRL 点进去方法的时候，点到了父类当中去
        p2.eat();
        p2.walk();
    }
}
```

> 看这个例子就是把一个孩子往父母的模板里敲，不能有自己的，只能在已有的基础上进行更新迭代

### 多态的使用举例一：

```java
public class AnimalTest{

    public static void main(String[] args){
        AnimalTest test = new AnimalTest();
        test.func(new Dog());
    }


public void func(Animal animal){//Animal animal =  new Dog();
    animal.eat();
    animal.shout();

	}
}
class Animal{
    
    public void eat(){
        System.out.println("动物：进食");
    }
    public void shout(){
	System.out.println("动物:叫");
    }
}

class Dog extends Animal{
    public void eat(){
        System.out.println("狗吃骨头");
    }
    
    public void shout(){
        System.out.println("汪！汪！汪！");
    }
}

class Cat extends Animal{
    public void eat(){
	System.out.println("猫吃鱼");
    }
    
    public void shout(){
        System.our.println("喵!喵!喵!");
    }
}
```

> 这个举例很生动了啊，用处蛮大的，就像这里有一个入口，上面写这郑氏入内，而且有一定的身份验证，要郑氏的孩子才可以，所以的话就要摒弃自己不属于郑氏的东西，否则的话一人给一个口，这就太浪费资源了吧

### instanceof

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200903162851473.png" alt="image-20200903162851473" style="zoom:67%;" />

```java
//Person是父类，Man是子类
Person p2 = new Man();
//不能调用子类所特有的方法、属性，编译时，p2是Person类型
//p2.earnMoney();
//p2.isSmoking = true;
//有了对象的多态性以后，内存中实际是加载了子类特有的属性和方法的，但是由于变量声明为父类类型，导致编译时，只能调用父类中声明的属性和方法，子类特有的属性和方法不能调用

//如何才能调用子类特有的属性和方法?
//向下转型：使用强制类型转换符
Man m1 = (Man)p2;
m1.earnMoney();

//使用强转时，可能出现ClassCastException的异常
Woman w1 = (Woman)p2;
w1.goShopping();

/*
instanceof关键字的使用
a instance of A : 判断对象a是否是类A的实例，如果是，返回true，如果不是返回false
使用情境：为了避免向下转型时出现异常，我们在向下转型之前，先进行instanceof的判断，一旦返回true，就向下转型，如果返回false，就不进行向下转型

如果a instanceof A 返回true，则 a instanceof B 也返回true
其中，类B是类A的父类,这里的a可以指的是p2，A可以是你想要转的类型
感觉实际上就是刻模子，你能不能塞到模子里面去，就看看你是哪个类的
*/
```

```java
//练习:
//问题一：编译时通过，运行时不通过，我猜强转的时候父类强转为子类编译才能通过
//举例一
//Person p3 = new Woman();
//Man m3 = (Man)p3;
//举例二：
//Person p4 = new Person();
// Man m4 = (Man)p4;

//举例三：
//所以这个就是乱写的，虽然编译通过，第一行的话就不说了吧，多态向上
//第二行的话父类强转为子类，ok编译通过，又因为instance不通过，所以就运行不通过
//Object obj = new Date();
//String str = (String)obj;
//问题二：编译通过，运行时也通过
//Object obj = new Woman();
//Person p = (Person)obj;

//问题三：编译不通过
//Man m5 = new Woman();

```

### 如何理解多态

![image-20200904163336061](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200904163336061.png)

## 区分重写和重载

1. 二者的概念不同
2. 重载和重写的具体规则
3. 重载不表现为多态性，重写表现为多态性
4. ![image-20200903153725517](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200903153725517.png)

### Object类

> 1. Object类是所有Java类的根父类
>2. 如果在类的声明中未使用`extends`关键字指明其他类，则默认父类为`java.lang.Object`
> 3. Object类中的功能就具有通用性
>4. Object类只声明了一个空参的构造器

#### `Object类中toString()的使用`

1. 当我们输出一个对象的引用时，实际上就是调用当前对象的`toString()`方法

2. ```java
   public String toString(){
       return getClass.getName() + "@" + Integer.toHexString(hashCode());
   }
   ```

3. 所以像String，Date，File、包装类都重写了Object类中的toString()方法,使得在调用对象的toString()时，返回"实体内容"信息

---------------------------------------anki--------------------------------------------------------

### == 与 equals的区别

`==:运算符`

1. 可以使用在基本数据类型变量和引用数据类型变量中
2. 如果比较的是基本数据类型变量，比较两个变量保存的数据是否相等。（不一定类型相同)
3. 如果比较的是引用数据类型，比较两个变量地址值是否相同,即两个引用是否指向同一个对象实体

```java
public class EqualsTest{
    public static void main(String[] args){
        
        int i = 10;
        int j = 10;
        double d = 10.0;
        System.out.println(i == j);//true
        //说一下这里怎么比呢？不同的类型诶？实际上和 + 一样，是可以自动类型提升的，所以是两个double在比
        System.out.println(i == d);//true
        
        char c = 10;
        System.out.println(i == c);//true
        
        char c1 = 'A';
        char c2 = 65;
        System.out.println(c1 == c2);//true
        
        Customer cust1 = new Customer("Tom",21);
        Customer cust2 = new Customer("Tom",21);
        // cust1 == cust2 ? false
    }
}
```

`equals`的使用

1. 是一个方法，而非运算符

2. 只能适用于引用数据类型

3. Object类中equals()的定义：

   ```java
   public boolean equals(Object obj){
   
   	return (this == obj);
   }
   ```

   说明：Object类中定义的equals() 和 == 的作用是相同的，比较的是地址值

4. 像String、Date、File、包装类等都重写了Object类中的equals()方法，重写以后比较的不是两个引用的地址是否相同，而是比较两个对象的"实体内容"是否相同,比较地址值也没意义了

5. 通常情况下，我们自定义的类如果使用equals()的话，也通常是比较两个对象的“实体内容”是否相同，那么我们就需要对Object类中的equals方法进行重写。(原来是这样啊)

6. 可以使用自动生成的equals(在Constructor那里)，不需要自己手写

```java
	    Customer cust1 = new Customer("Tom",21);
         Customer cust2 = new Customer("Tom",21);
		System.out.println(cust1.equals(cust2));//false

		String str1 = new String("zbr");
		String str2 = new String("zbr");
		System.our.println(str1.equals(str2));//true

		Date date1 = new Date(231313L);
		Date date2 = new Date(231313L);
		System.out.println(date1.equals(date2));//true
		
```

```java
//一般重写的内容
if(this == obj){

    return true;
}

if(obj instanceof Order){
    Order order = (Order)obj;
    
    return this.orderId == order.orderId && this.orderName.equals(order.orderName);
}
	return false;
```

> 关于这个，我有一句话需要说，这个实际上是和前面的对象的多态联系起来的，所以对于对象而言，如果有子父类关系`Person p = new Student(); p是Student也是Person，所以才会有下面强转的内容，基本服务于这里把`

**但是，这个有个漏洞**

？？？？

啥漏洞啊，我忘了

对不起是真的忘了哈



#### 区别来啦

额，老师没给你总结，但是我记得String和newString 好像也是有区别的啊

## 包装类

想让java的基本数据类型拥有类的特征 

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200904095814335.png" alt="image-20200904095814335" style="zoom:67%;" />

1. java提供了8种基本数据类型对应的包装类，使得基本数据类型的变量具有类的特征
2. 掌握的：基本数据类型、包装类、String三者之间的相互转换



```java
public class WrapperTest{
	
    

    //基本数据类型 -- > 包装类，调用包装类的构造器
    @Test
    public void test1(){
        
        int num1 = 10;
        //System.out.println(num1.toString);
        Integer in1 = new Integer(num1);
       System.out.println(in1.toString);
        
         Integer in2 = new Integer("123");
         System.out.println(in2.toString);
        
       //  Integer in3 = new Integer("123abc");
         //System.out.println(in3.toString);
        
        Float f1 = new Float(12.3f);
        //说实话这个我不怎么见过？噢，还是因为构造器的原因，他允许String类型的参数
        Float f2 = new Float("12.3");
  		
        Boolean b1 = new Boolean(true);//true
        Boolean b2 = new Boolean("True");//true
        Boolean b3 = new Boolean("true123");//false
         //上面这个是因为对这个包装类进行了优化，只要你的String中有true(不区分大小写)，就是true，否则的话就是false，不会报错
    }
    
    //包装类 --> 基本数据类型：调用包装类的xxxValue()
    //需求？ 类是不能加减乘除的，所以可以使用基本数据类型来进行
    @Test
    public void test2(){
	
        Integer in1 = new Integer(12);
        int i1 = in1.intValue();
        
        Float f1 = new Float(12.3);
        float f2 = f1.floatValue();
    }
    
    public void  method(Object obj){
	
        System.out.println(obj);
        
    }
    
    /*
    JDK 5.0 新特性：自动装箱与自动拆箱
    */
    
    @Test
    public void test3(){
        
        int num1 = 10;
        //基本数据类型 --> 包装类对象
        method(num1);//Object obj = num1;
        //可以输出噢
        
        //自动装箱：
        int num2 = 10;
        Integer in1 = num2;//自动装箱
        
        boolean b1 = true;
        Boolean b2 = b1;//自动装箱
        
        //自动拆箱：包装类 -- > 基本数据类型
        System.out.println(in1.toString());
        
        int num3 = in1;//自动拆箱
    }
    
    //基本数据类型、包装类 ---> String类型：调用String重载的valueOf(Xxx xxx)
    @Test
    public void test4(){
        
        int num1 = 10;
        //方式1：连接运算
        String str1 = num1 + "";
        //方式2：
    	float f1 = 12.3f;
        String str2 = String.valueOf(f1);//12.3
    }
    
    //String类型 ---> 基本数据类型、包装类：调用包装类的parsrXxx(String s)
    @Test
    public void test5(){
        String str1 = "123";
        int num2 = Intger.parseInt(str1);
    }
}
```

![image-20200904135048455](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200904135048455.png)

会类型提升哦，提升为double类型的

### 练习二：

![image-20200904145230118](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200904145230118.png)

> `Integer内部定义了IntegerCache结构，IntegerCache中定义了Integer[],保存了从-128~127范围的整数，如果我们使用自动装箱的方式，给Integer赋值的范围在-128~127范围内，可以直接使用数组中的元素，不用再去new了，目的：提高效率`
>
> 主要原因是有些数字用的太频繁了，所以就内部先创建好成一个数组，所以每次在这范围内的数字都从数组中取，缓存的东西就会加载地块一些，然后这个范围就是[-128,127],这些的
>
> 

## static

1. static:静态的

2. static可以用来修饰：属性、方法、代码块、内部类

3. 使用static修饰属性：静态变量

   1. 属性，按是否使用static修饰，又分为：静态属性 vs 非静态属性(实例变量)

      实例变量：我们创建了类的多个对象，每个对象都	独立地拥有一套类中的非静态属性，当修改其中的一个对象的一个非静态属性时，不会导致其他对象中同样的属性值修改

      静态变量：我们创建了类的多个对象，多个对象共享同一个静态变量，当通过某一个对象修改静态变量时，会导致其他对象调用静态变量时，是修改过了的

   2. static修饰属性的其他说明：

      1. 静态变量随着类的加载而加载，可以通过"类.静态变量"的方式进行调用

      2. 静态变量的加载要早于对象的创建

      3. 由于类只会加载一次，则静态变量在内存中也只会存在一份，存在方法区的静态域中

      4. |      | 类变量 | 实例变量 |
         | ---- | ------ | -------- |
         | 类   | yes    | no       |
         | 对象 | yes    | no       |

   3. 静态属性举例`System.out;Math.PI`

4. 使用static修饰方法：静态方法

   1. 随着类的加载而加载，可以通过"类.静态方法"的方式进行调用

   2. 静态方法中，只能调用静态的方法或属性(生命周期相同)

      非静态方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性

5. static注意点：

   1. 在静态的方法内，不能使用this关键字、super关键字。因为没对象啊

   2. 关于静态属性和静态方法的使用，大家都从生命周期的角度去解释

6. 在开发中，如何确定一个属性是否需要声明为static的？

   > 属性是可以被多个对象所共享的，不会随着对象的不同而不同的。
>
   > 类中的常量也常常声明为static(不妨就共享一个，又不能改，大家都用的一样)

   开发中，如何确定一个方法是否要声明为static的？

   	> 操作静态属性的方法，通常设置为static
   	>
   	> 工具类中的方法，习惯上声明为static的，比如Math，Arrays，Collections

```java
public class StaticTest{
    public static void main(String[] args){
        Chinese c1 = new Chinese();
        c1.name = "姚明";
        c1.age = 40;
        
        Chinese c2 = new Chinese();
        c2.name = "马龙";
        c2.age = 30;
        
        c1.nation = "CHN";
        //CHN
        System.out.println(c2.nation);
        Chinese.show();
    }
}

class Chinese{

    String name;
    int age;
    static String nation;
    
    public static void show(){
        System.out.println("我是一个中国人");
    }
}
```

### 注意：！！

> 我觉得上面的代码肯定我没有在idea上写的，不然不会不知道，现在就一件事情哈，用类实例对象去调用静态属性的时候他不会给你提示，就像你调用不了一样。而且你直接写的话会有红线，但并不算编译错误，因为还是可以运行的。
>
> 那是啥意思，我觉得是他不让你这样子做，虽然可以。因为的确像两个相同爸妈的孩子，一个说我的爸妈怎么样，另外一个也说我的爸妈怎么样，看起来像两个爸妈不同一样，所以的话还是？？？？用类来调把。

-----------------------------------------------anki 2020.10.09------------------------------

## 设计模式

### 单例设计模式

只能存在一个对象实例

```java
/*
单例设计模式:
1. 所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某一个只能存在一个对象	实例。
2.如何实现呢？
	饿汉式 vs 懒汉式
*/


public class SingletonTest1{
	
}
//饿汉式
class Bank{
    
    //1.私有化类的构造器
    private Bank(){
        
    }
    //2.内部创建类的对象
   //4.要求此对象也必须声明为静态的
    private static Bank instance = new Bank();
    
    //3.提供公共的静态方法，返回类的对象
    public static Bank getInstance(){
        return instance;
    }
}
```

#### 懒汉式

```java
/*
单例模式的懒汉式实现
*/

public class SingletonTest2{
    
}

class Order{
    
    //1.私有化类的构造器
    private Order(){
        
    }
    
    //2.声明当前类对象，没有初始化
    //4.此对象也必须声明为static的
    private static Order instance = null;
    
    //3.声明public、static的返回当前类对象的方法
    public static Order getInstance(){
        if(instance == null){
            
        instance  = new Order();
        }
            return instance;
    }
}
```

> 饿汉式和懒汉式你怎么区分记住的？ 饿汉式是一上来就造好了，懒汉式是需要的时候再造

#### 区分饿汉式和懒汉式

饿汉式：

​	坏处：对象加载时间过长

​	好处：饿汉式是线程安全的

懒汉式：

​	好处：延迟对象的创建，

​	 目前的写法坏处，是不安全的

#### 补充下另外的一种单例

![image-20200905213309686](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200905213309686.png)

很有趣，这里就是把权限给改了，但是会有比较多的限制，如果你想对instance动些手脚的话

## main()方法的使用说明

1. main()方法作为程序的入口

2. main()方法也是一个普通的方法

3. main()方法可以作为我们与控制台交互的方式(之前，使用Scanner)，emem没用过之前，是在`Run As Configuration 那里需要的`

   ![image-20200905111413819](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200905111413819.png)



```java
public class MainTest{
    
    public static void main(String[] args){
        Main.main(new String[100]);
    }
}


class Main{
    
    public static void main(String[] args){
        
        for(int i = 0;i < args.length;i ++){
            args[i] = "agrs_" + i;
            System.out.println(args[i]);
        }
    }
}
```

---------------------------------------------9.13 anki---------------------------------------

## 代码块

```java
/**
 * 类的成员之四：代码块(初始化块)
 * 1. 代码块作用：用来初始化类、对象
 * 2. 代码块如果有修饰的话，只能使用static
 * 3. 分类：静态代码块 vs 非静态代码块
 * 4. 静态代码块
 *      > 内部可以有输出语句
 *      > 随着类的加载而执行，而且只执行一次
 *      > 初始化类的信息
 *      > 如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行
 *      > 静态代码块要优先于非静态代码块执行
 *      > 静态代码块内只能调用静态的属性，静态的方法，不能调用非静态的结构
 * 5.非静态代码块
 *      > 内部可以有输出语句
 *      > 随着对象的创建而执行
 *      > 每创建一个对象就执行一次非静态代码块
 *      > 作用：   可以再创建对象时，对对象的属性等进行初始化
 *      > 如果一个类中定义了多个代码块，则按照声明的先后顺序执行
 *      > 非静态代码块内可以调用静态的属性、静态的方法，或非静态的属性、非静态的方法
 *
 * 对属性可以赋值的位置：
 * 1. 默认初始化
 * 2. 显式初始化
 * 3.构造器初始化
 * 4.有了对象以后，可以通过"对象.属性" 或 "对象.方法"进行赋值
 * 5. 在代码块中赋值
 */

public class BlockTest {
    public static void main(String[] args) {
        String desc = Person.desc;
        System.out.println(desc);
        Person p1 = new Person();
    }

}

class Person{
    //属性
    String name ;
    int age;
    static String desc = "我是一个人";
    //构造器
    public Person(){

    }

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    //静态代码块
    static {
        System.out.println("hello,static block -1");
        desc = "我是一个爱学习的人";
    }

    static{
        System.out.println("hello,static block -2");
    }
    //非静态代码块
    {
        System.out.println("hello,block");
    }
    public void eat(){
        System.out.println("吃饭");
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }

    public static void info(){
        System.out.println("我是一个快乐的人");
    }

}
```



> 好像明白了什么时候需要使用静态代码块了。
>
> <img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200905155429755.png" alt="image-20200905155429755" style="zoom:67%;" />
>
> 看这个，作为一个连接池是静态的是共享的，只有一个，但是呢在给它赋值之前还有别的操作，这个操作想能不能放到方法里啊？那得是静态的方法把，但是静态的方法需要进行加载欸，但你的用处很多，你哪知道你哪个地方是第一次加载的呢，而且从理解意思上来讲放到static代码块中再合适不过了，因为static即共用，加上再类加载时便执行，不用你再在外部中调用方法了，这很完美嘛

```java
public class Student {
    static{
	System.out.println("Student 的静态代码块");
    }
    {
     	System.out.println("Student 的非静态代码块");
    }
    public Student(){
        	System.out.println("Student 的构造器");
    }

    public static void main(String[] args){
        System.out.println("111111");
        new Student();
    }
}
class Person{
    static{
	System.out.println("Person 的静态代码块");
    }
    {
     	System.out.println("Person 的非静态代码块");
    }
    public Person(){
        	System.out.println("Person 的构造器");
    }
}
//执行结果是什么
//Person 的静态代码块
//Student 的静态代码块
//111111
//Student 的非静态代码块
//Student 的构造器
```

> 为什么在1111之前要执行静态代码块呢，因为你的main方法实在Student类下的，你要使用的话首先你得加载把，所以在方法前就率先加载了静态代码块，而且又因为非静态代码块是在构造器前面的。所以就是这种结果了

**总结：由父及子，静态先行**,

当创建一个对象时，先加载类再进行各种的初始化

静态代码块 > 非静态代码块> 构造方法

属性赋值和非静态代码块赋值时根据前后顺序的

```java
/**
 *对属性可以赋值的位置：
 * 1. 默认初始化
 * 2. 显式初始化
 * 3.  构造器初始化
 * 4.  有了对象以后，可以通过"对象.属性" 或 "对象.方法"进行赋值
 * 5.  在代码块中赋值
 *
 * 执行先后的顺序: 1 -> 2 / 5 -> 3 -> 4
 * 并列的原因是因为，它是按照顺序来的，因为非静态的属性和代码块都是在创建对象的时候完成的，创建对象时，属性值都默认为0，然后进行初始化的时候就一顺溜下来，所以的话就是看顺序咯
 */
public class OrderTest {
    public static void main(String[] args) {
        Order order = new Order();
        System.out.println(order.orderId);
    }

}

class Order{
    int orderId = 3;
    {
        orderId = 4;
    }
}

```

------------------------9.29    anki到这

## final

```java
/**
 * final：最终的
 * 1. final可以用来修饰的结构：类、方法、变量
 *
 * 2. final用来修饰一个类：此类不能被其他类锁继承
 *                  比如：String类、System类、StringBuffer类
 * 3. final用来修饰方法： 表名此方法不可以被重写
 *      比如：Object类中getClass();
 * 4. final 用来修饰一个变量，此时的"变量"就称为一个常量
 *      1.final修饰属性：可以考虑赋值的位置有：显式初始化、代码块中初始化、构造器中初始化
 *      2.final修饰局部变量:
 *          尤其是使用final修饰形参时，表名此形参是一个常量，当我们调用此方法时，给常量形参赋一个实参，一旦赋值以后，
 *          就只能在方法体内使用此形参，但不能进行重新赋值
 *
 *   static final：用来修饰属性：全局常量
 *              还可以用来修饰方法，但比较少这种情况
 */
public class FinalTest {
    final int WIDTH = 0;
    final int LEFT;
    final int RIGHT;
//    final int DOWN;
    {  LEFT = 1 ;  }
    public  FinalTest(){
        RIGHT = 2;
    }
    //如果这个构造器没有把n赋值给RIGHT的话，是会报错的，因为当你调用这个构造器的时候，final的RIGHT就没得赋值了，反正就是得确保他赋上值
    public FinalTest(int n){
        RIGHT = n;
    }
    //结合上面被注释掉的，为什么不可以呢？
    //一开始我以为只是因为你是否调用方法是不确定的，所以final的常量不一定赋上值，但重点不是这个
    //说说final为什么一定要赋上值，因为他是常量，必须在创建好对象的时候就初始化了，创建完对象之后就修改不了了。
    //所以你等到调用方法来赋值的时候，你堆空间上的final常量已经不能赋值了好吗，你就相当于修改值了，不行的
//    public void setDOWN(int down){
//        this.DOWN = down;
//    }

    public void show(){
        final int NUM = 10;//常量
//        NUM += 20;//不可以的
    }
    public void show(final int NUM){
        //做形参没有报错，因为必赋上值。
    }

}

```



## 抽象类与抽象方法

  什么时候会有抽象类，当你的父类不再需要造对象的时候，你就可以把父类写成一个抽象类，所以一般就用不到父类的一些方法，他的作用只是让子类去重写的话，那也可以是一个抽象类 

所以感觉抽象类的话应该很常用的，比如交通工具 细分为自行车，汽车，飞机等等，那你让交通工具这么抽象的概念去写自己内部的方法也不合适啊

```java
/**
 * abstract 关键字的使用
 *  1.abstract：抽象的
 *  2.abstract可以用来修饰的结构：类、方法
 *  3.abstract修饰类:抽象类
 *      >此类不能实例化
 *      >抽象类中一定有构造器，便于子类对象实例化的时候调用(子类对象实例化的全过程)
 *      >开发中，都会提供抽象类的子类，让子类对象实例化，完成相关操作
 *
 *  4. abstract修饰方法
 *      >抽象方法只有方法的声明，没有方法体
 *      >包含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象方法。
 *      >若子类重写了父类中的所有的抽象方法后，此子类可实例化
 *          若子类没有重写父类中所有的抽象方法，则此子类也是一个抽象类，需要使用abstract修饰
 *
 */
public class AbstractTest {

    public static void main(String[] args) {
       //一旦Person类抽象了，就不可实例化
//        Person p1 = new Person();
//        p1.eat();
    }
}

 abstract class Person{
    String name;
    int age;

    public Person(){

    }

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

//    public void eat(){
//        System.out.println("人吃饭");

//    }
    public abstract void eat();
    public void walk(){
        System.out.println("人走路");
    }

}


class Student extends  Person{

    public Student(String name,int age){
        super(name,age);
    }
    @Override
    public void eat() {

        System.out.println("学生多吃有营养的食物");
    }
}
 
```

```java
/**
 * abstract使用上的注意点
 * 1.abstract不能用来修饰: 属性、构造器等结构
 *
 * 2.abstract不能用来修饰私有方法(因为子类不能重写私有方法，不能重写的话，抽象就无意义了)、静态方法!!
 *  (因为静态方法不能重写哈),final的方法(也不能重写)、final的类
 */
```

### 匿名子类

```java
/**
 * 抽象类的匿名子类
 */
public class PersonTest {

    public static void main(String[] args) {
        method(new Student());//匿名对象
        Worker worker = new Worker();
        method1(worker);//非匿名的类非匿名的对象

        method1(new Worker());//非匿名的类匿名的对象

        //创建了一匿名类的对象: p
        Person p = new Person() {
            @Override
            public void eat() {
                System.out.println("吃东西");
            }
        };
        method1(p);
    }
    public static void method1(Person person){
        person.eat();
        person.walk();
    }
    public static void method(Student s){

    }
}

class Worker extends  Person{

    @Override
    public void eat() {

    }
}

```

### 模板方法

```java
/**
 * 抽象类的应用：模板方法的设计模式
 */
public abstract class TemplateTest {
    public static void main(String[] args) {

        Template t = new SubTemplate();
        t.spendTime();
    }

}

abstract  class Template{
    //计算某段代码执行所需要花费的时间
    public void spendTime(){
        long start = System.currentTimeMillis();

        code();//不确定的部分、易变的部分
        long end = System.currentTimeMillis();

        System.out.println("花费的时间为" +(end - start));
    }

    public abstract  void code();
}
class SubTemplate extends Template{

    @Override
    public void code() {

        for (int i = 2; i <1000 ; i++) {
            boolean isFlag = true;
            for (int j = 2; j < Math.sqrt(i); j++) {

                if(i% j ==0){
                    isFlag = false;
                    break;
                }
            }
            if(isFlag){
                System.out.println(i);
            }
        }
    }
}

```

> 这啥意思咧，就是抽象类的使用，抽象类父类已经把流程给你做好了，但有些里面的方法每个子类是不一样的，就需要你重写，然后使用的时候会显示出不同的功能。所以的话模板就是抽象类，模板中总有自己需要填写的东西，就是子类

## 接口

>  有了接口，就可以实现多继承,另一方面，有时必须从几个类中抽取出一些共同的行为特征，而他们之间又没有is-a关系，仅仅是具有相同的行为特征而已。例如：鼠标、键盘、打印机、扫描仪、摄像头等等都支持USB连接

```java
/**
 * 接口的使用：
 * 1.接口使用interface来定义
 * 2.Java中，接口和类是并列的两个结构
 * 3.如何定义接口：定义接口中的成员
 *
 *      3.1 JDK 及以前：只能定义全局常量和抽象方法
 *          >全局常量：public static final的,但是书写时可以省略不写
 *          >抽象方法：public abstract
 *
 *      3.2 JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法(略)
 * 4.接口中不能定义构造器！意味着接口不可以实例化
 *
 * 5.java开发中，接口都通过让类去实现(implements)的方法来使用
 *      如果实现类覆盖了接口中的所有抽象方法，则此实现类可以实例化
 *      如果实现类没有覆盖接口中所有的抽象方法，则此实现类仍为一个抽象类
 * 6.Java类可以实现多个接口---> 弥补了Java单继承性的局限性
 *  格式：class AA extends BB implements CC,DD,EE
 *
 *  7. 接口与接口之间可以继承，而且可以多继承
 *
 *  8.接口的使用：体现多态性
 *  9.接口：实际上可以看做一种规范
 *
 *  面试题：抽象类与接口有哪些异同
 *
 */
public class InterfaceTest {
    public static void main(String[] args) {
        System.out.println(Flyable.MAX_SPEED);
        System.out.println(Flyable.MIN_SPEED);

        Plane plane = new Plane();
        plane.fly();
    }


}

interface Flyable{
    //全局常量
    public static final int MAX_SPEED = 7900;//第一宇宙速度
    public static final int  MIN_SPEED =1;

    //抽象方法
    public abstract void fly();

    //省略了 public abstract
    void stop();
}
interface Attackable{
    void attack();
}
class Plane implements Flyable{

    @Override
    public void fly() {

        System.out.println("通过引擎起飞 ");
    }

    @Override
    public void stop() {

        System.out.println("驾驶员减速停止");
    }
}

abstract class Kite implements  Flyable{


    @Override
    public void fly() {

    }

    @Override
    public void stop() {

    }
}
class Bullet extends Object implements Flyable,Attackable{

    @Override
    public void fly() {

    }

    @Override
    public void stop() {

    }

    @Override
    public void attack() {

    }
}

interface  AA{
    void metho1();
}

interface  BB{
    void method2();
}
interface CC extends AA,BB{

}
```

### 接口的使用

```java
/**
 * 接口的使用
 * 1.接口使用上也满足多态性
 * 2.接口：实际上是定义了一个规范
 * 3.开发中，体会面向接口编程
 */
public class USBTest {
    public static void main(String[] args) {
        Computer com  = new Computer();
        //1. 创建了接口的非匿名实现类的非匿名对象
        Flash flash = new Flash();
        com.transferData(flash);

        //2.创建了接口的非匿名实现类的匿名对象
        com.transferData(new Printer());

        //3.创建了接口的匿名实现类的非匿名对象
        USB phone = new USB(){

            @Override
            public void start() {
                System.out.println("手机开始工作");
            }

            @Override
            public void stop() {

                System.out.println("手机结束工作");
            }
        };
        com.transferData(phone);

        //4.创建了接口的匿名实现类的匿名对象

        com.transferData(new USB() {
            @Override
            public void start() {
                System.out.println("mp3开始工作");
            }

            @Override
            public void stop() {

                System.out.println("mp3结束工作");
            }
        });
    }
}


class Computer{
    public void transferData(USB usb){//USB usb = new Flash();
        usb.start();

        System.out.println("具体传输数据的细节");

        usb.stop();
    }
}
interface USB{
    //常量：定义了长、宽、最大最小的传输速度等
    void start();

    void stop();
}

class Flash implements  USB{

    @Override
    public void start() {
        System.out.println("U盘开启工作");
    }

    @Override
    public void stop() {
        System.out.println("U盘结束工作");
    }
}

class Printer implements USB{
    @Override
    public void start() {
        System.out.println("打印机开启工作");
    }

    @Override
    public void stop() {
        System.out.println("打印机结束工作");
    }
}
```

> 匿名对象与匿名类？
>
> 匿名对象就是`FileInputStream fis = new FileInputStream(new File("h1.txt"));`
>
> 匿名类是
>
> ```java
>  USB phone = new USB(){
> 
>             @Override
>             public void start() {
>                 System.out.println("手机开始工作");
>             }
> 
>             @Override
>             public void stop() {
> 
>                 System.out.println("手机结束工作");
>             }
>         };
> ```
>
> 这种，USB是一个接口，然后本来是不能实例化的，需要有类去实现这个接口，但是这样写的话就算一个匿名类去实现了。抽象类也可以这样子的。

### 练习

看看

![image-20200907173945770](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200907173945770.png)

他的目的是在于问你想输出x的时候，输出的是谁？ 会报错把，因为接口和父类是平行的关系，那当你想分别输出接口和父类中的x时应该怎么操作呢，看图





```java
/**
 * 接口的应用：代理模式
 */
public class NetWorkTest {
    public static void main(String[] args) {
        new Proxy(new Server()).browse();
    }
}

interface NetWork{

    public void browse();
}
//被代理类
class Server implements NetWork{

    @Override
    public void browse() {
        System.out.println("真实的服务器访问网络");
    }
}

//代理类
class Proxy implements NetWork{

    private NetWork work;
    public Proxy(NetWork work){
        this.work = work;
    }
    public void check(){
        System.out.println("联网之前的检查工作");
    }
    @Override
    public void browse() {

        check();

        work.browse();
    }
}
```



------------------------------------------------anki 2020.10.14--------------------------------------------



### JDK 8 之后的功能

```java
/**
 * JDK8:除了定义全局常量和抽象方法之外，还可以定义静态方法，默认方法
 */
public interface CompareA {

    //静态方法
    public static void method1(){
        System.out.println("CompareA:北京");
    }

    //默认方法
    public default void method2(){
        System.out.println("CompareA:上海");
    }

    default  void method3(){
        System.out.println("CompareA:上海");
    }
}
```

```java
public interface CompareB {
    default void method3(){
        System.out.println("CompareB：上海");
    }
}
```

```java
public class SuperClass {
    public void method3(){
        System.out.println("SuperClass:北京");
    }
}
```

```java
public class SubClassTest {

    public static void main(String[] args) {
        SubClass s = new SubClass();
//        s.method1();
        //知识点1：接口中定义的静态方法，只能通过接口来调用
        //目前了解的原因是如果多个接口中有该方法的话，那么你就不知道是调哪个了。所以干脆就别调了
    CompareA.method1();
        //知识点2：通过实现类的对象，可以调用接口中的默认方法
        //如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写以后的方法
    s.method2();
        //知识点3：如果子类(或实现类)继承的父类和实现的接口中声明了同名同参数的方法
        //那么子类再没有重写此方法的情况下，默认调用的是父类中的同名同参数的方法 -->类优先原则
        //知识点4：如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法
        //那么再实现类没有重写此方法的情况下，报错 --> 接口冲突
        //这就需要我们必须再实现类中 重写此方法
    s.method3();
    }
}
class SubClass extends SuperClass implements CompareA,CompareB{
//    class SubClass  implements CompareA,CompareB{
    //默认方法
    @Override
    public  void method2(){
        System.out.println("SubClass:上海");
    }

    @Override
    public void method3() {
        System.out.println("SubClass:深圳");
    }

    //知识点5：如何在子类(或实现类)的方法调用父类，  接口中被重写的方法
    public void MyMethod(){
        method3();//自己定义的重写的方法
        super.method3();//调用的是父类中声明的
        //调用接口的默认方法
        CompareA.super.method3();
        CompareB.super.method3();
    }
}
```

> 总结：这里的知识点很杂，但是记住几点，这里发现和上面练习上有点区别，练习调的是同名的属性，但属性是final的啊，而且你又不能重新赋值，所以不能调同名的属性，但是同名同参的话就不一样了啊，但是要求你必须重写，因为也不知道调哪个方法。
>
> 然后如果又继承了父类，又实现了接口，还有同名同参的方法的话，那就是类优先了。

## 接口和抽象类的区别

相同点：

1. 不能实例化
2. 都可以被继承

不同点：

1. 抽象类：有构造类。接口：不能声明构造器
2. 多继承  vs 单继承

## 内部类

![image-20200908210826698](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200908210826698.png)

```java
/**
 * 类的内部成员之五：内部类
 * 1.Java中允许将一个类A声明在另一个类B中，则类A就是内部类，类B称为外部类
 * 2.内部类的分类：成员内部类(静态、非静态) vs 局部内部类(方法内、代码块内、构造器内)
 * 3.成员内部类：
 *          一方面，作为外部类成员：
 *              >   调用外部类的结构
 *              >   可以用static修饰
 *              >   可以被四种不同的权限修饰
 *          另一方面，作为一个类：
 *              >   类内可以定义属性、方法、构造器等
 *              >   可以被final修饰，表示此类不能被继承，言外之意，不使用final就可以被继承
 *              >   可以被abstract修饰
 *
 * 4. 关注如下的3个问题
 *  1.如何实例化成员内部类的对象
 *  2.如何在成员内部类中区分调用外部类的结构
 *  3.开发中局部内部类的使用,见<InnerClassTest1.java>
 */
public class InnerClassTest {
    public static void main(String[] args) {

        //创建Dog实例(静态的成员内部类):
        Person3.Dog dog = new Person3.Dog();
        dog.show();
        //创建Bird实例(非静态的成员内部类):
        //Person.Bird bird = new Person.Bird();//错误的
        Person3 p = new Person3();
        Person3.Bird bird = p. new Bird();
    }
}

class Person3{
        String name;
        int age;

        public void eat(){
            System.out.println("人，吃饭");
        }

    //静态成员内部类
     static class Dog{
        String name;
        int age;

        public void show(){
            System.out.println("我是一条狗");
        }
    }

    //非静态内部类
    class Bird{
        String name;

        public void sing(){
            System.out.println("我是一只小小鸟");
            Person3.this.eat();//调用外部类的非静态属性
        }

        public void display(String name){
            System.out.println(name);//方法的形参
            System.out.println(this.name);//内部类的属性
            //想说说为什么这个是Person3.this.name 呢？ 想想的话如果不是的话就是Person3.name ,
            //那这可是静态的啊，怎么可以呢,所以this代表的就是一个深入类内部的标志啊
            System.out.println(Person3.this.name);//外部类的属性
        }

    }

    public void method(){
        //局部内部类
        class AA{

        }
    }
    {
        //局部内部类
        class BB{
    }
    }

    public Person3(){
        //局部内部类
        class CC{
        }
    }
}

```

```java
package com.zbr.test3;

public class InnerClassTest1 {

    //开发很少见
    public void method() {
        //局部内部类
        class AA {

        }
    }

    //返回一个实现Comparable接口的类的对象
    public Comparable getComparable() {

        //创建一个实现Comparable接口的类:局部内部类
        //方式一：
//        class MyComparable implements Comparable{
//
//            @Override
//            public int compareTo(Object o) {
//                return 0;
//            }
//        }
//
//        return new MyComparable();
//    }
        //方式二：
        return new Comparable() {
            @Override
            public int compareTo(Object o) {
                return 0;
            }
        };
    }
}
```

## 异常处理

Java程序在执行过程所发生的异常事件可以分为两类

1. ERROR ： Java虚拟机无法解决的严重问题，如：JVM系统内部错误、资源耗尽等严重情况。比如：`StackOverflowError和OOM`，一般不编写针对性的代码进行处理
2. Exception : 其他因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理

异常可以分为

1. 运行时异常
2. 编译时异常

![image-20200909085402582](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200909085402582.png)

```java
/**
 * 一、异常的体系结构
 *          java.lang.Error：一般不编写针对性代码处理
 *          java.lang.Exception:可以进行异常的处理
 *              编译时异常(checked)
 *                  IOException
 *                      FileNotFoundException
 *                  ClassNotFoundException
 *              运行时异常(unchecked)
 *                  NullPointerException
 *                  ArrayIndexNotFoundException
 *                  ClassCastException
 *                  NumberFormatException
 *                  InputMismatchException
 *                  ArithmeticException
 *
 *面试题：常见的异常有哪些
 */
```

```java
/**
 * 异常的处理:抓抛模型
 *
 * 过程一："抛":程序在正常执行的过程中，一旦出现异常，就会在异常代码处生成一个对应异常类的对象
 *              并将此对象抛出。
 *              一旦抛出对象以后，其后的代码不再执行
 *
 *          关于异常对象的产生：1.系统自动生成的异常对象
 *                          2.手动地生成一个异常对象，并抛出(throw)
 * 过程二："抓":可以理解为异常的处理方式：1. try-catch-finally  2.throws
 *
 * 二、try-catch-finally 的使用
 *
 *  try{
 *      //可能出现异常的代码
 *  }catch(异常类型1 变量名1){
 *      //处理异常的方式1
 *  }catch(异常类型2 变量名2){
 *      //处理异常的方式2
 *  }
 *  ....
 *  finally{
 *      //一定会执行的代码
 *  }
 *
 *  说明：
 *  1.finally是可选的
 *  2.使用try将可能出现异常代码包装起来，一旦出现异常，就会生成一个对应异常类的对象，根据此对象的类型，去
 *      catch中进行匹配
 *  3.一旦try中的异常对象匹配到某一个catch时，就进入catch中进行异常的处理，一旦处理完成，就跳出当前的try catch结构
 *      (在没有写finally的情况下),继续执行其后的代码
 *  4.catch中的异常类型如果没有子父类关系，则谁声明在上，谁声明在下无所谓。
 *      catch中的异常类型如果满足子父类关系，则要求子类一定声明在父类的上面，否则，报错
 *  5. 常用的异常对象处理的方式：1.String getMessage() 2.printStackTrace()
 *  6.在try结构中声明的变量，在出了try结构以后，就不能再使用
 *
 *
 *  体会：使用try-catch处理编译时异常，使得程序在编译时不再报错，但是运行时仍可能报错。
 *      相当于我们使用try - catch- finally将一个编译时可能出现的异常，延迟到运行时出现
 *
 *      这个怎么理解？这个其实是本来就要处理的，编译期就有红线的，因为在编译期间就有可能会出错，所以你要么就throw一下，要么就自己解决哈
 *
 */
public class ExceptionTest1 {

    @Test
    public void test1(){

        String str = "123";
        str = "abc";
        try{
            int num  = Integer.parseInt(str);
            System.out.println("hello -----1");
        }catch (NumberFormatException e){
//            String message = e.getMessage();
//            System.out.println(message);
            e.printStackTrace();
            System.out.println("出现数值转换异常");
        }
        System.out.println("hello --------2");
    }
}

```

```java
/**
 * 异常处理的方式二： throws +异常类型
 *
 * 1."throws + 异常类型" 写在方法的声明处。指明此方法时，可能会抛出的异常类型。
 *      一旦当方法体执行时，出现异常，仍会在异常代码处生成一个异常类的对象，此对象满足throws异常时，就
 *      会被抛出。异常代码后续的代码就不再执行
 *
 * 2.体会：try-catch-finally: 真正地将异常给处理掉了。
 *      throws的方式只是将异常抛给了方法的调用者，并没有真正地将异常处理掉
 * 3.开发中如何选择使用 try-catch-finally 还是使用throws？
 *   1.如果父类中被重写的方法没有throws方式处理异常，则子类重写的方法也不能使用throws，意味着如果
 *      子类重写的方法中有异常，必须使用try-catch-finally方式处理
 *   2.执行的方法a中，先后又调用了另外的几个方法,这几个方法是递进执行的，我们建议这几个使用throws的方式处理。
 *      而执行的方法a可以考虑使用到try-catch-finally方式进行处理
 *      (解释一下，就是如果直接在方法内使用try catch解决后拿到的结果就不是我们想要的，那这时候的传参也是无意义的了，所以不如先throws，然后大家一起来)
 */
public class ExceptionTest2 {

    public void method2() {
        try {
            method1();
        }catch (IOException e){
            e.printStackTrace();
        }

    }
    public void method1() throws IOException {
        File file  = new File("hello.txt");

        FileInputStream fis =  new FileInputStream(file);
        int data = fis.read();
        while (data != -1){
            System.out.print((char)data);
            data = fis.read();
        }
    }

}

```

```java
/**
 * try-catch-finally 中finally的使用
 *
 * 1.finally是可选的
 * 2.finally中声明的是一定会被执行的代码，即使catch中又出现异常了，try中有return语句，catch中有return语句等情况
 *      话说不是你输出语句不写finally也照样会输出吗？是的，所以finally另有他用，当你有返回值或者在catch中又有异常的时候会跳到别的地方
 *      这时候你的finally就起作用啦，顺序是当跳到别的地方时候时，说先别，我还要执行呢，再跳到别的页面去，我一直以为是跳到别的地方去再回来的
 * 3.像数据库连接、输入输出流、网络编程中的Socket等资源，JVM是不能自动回收的，我们需要手动操作
 * 此时的资源释放，就需要声明在finally中
 *
 */
public class FinallyTest {

    @Test
    public void testMethod(){
        int num = method();
        System.out.println(num);
    }
    public int method(){
        try{
            int[] arr = new int[10];
            System.out.println(arr[10]);
            return 1;
        }catch (ArrayIndexOutOfBoundsException e){
            e.printStackTrace();
            return 2;
        }finally {
            System.out.println("我一定会被执行的");
        }
    }
    @Test
    public void test1(){
        try {
            int a = 10;
            int b = 0;
            System.out.println(a / b);
        }catch (ArithmeticException e){
            e.printStackTrace();
        }finally {
            System.out.println("我好帅啊~~");
        }
    }
}

```

```java
/**
 * 方法重写的规则之一：
 * 子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型
 *
 * 为什么要这么设置呢？
 * 对象多态的时候呀，虽然说调用方法的时候会使用子类重写的方法，但是呢感觉在调用的时候外界看方法名那一行还是使用的是父类的
 * 所以当父类的抛出了一个异常的时候，如果子类重写的方法抛出的异常比父类的还大的话，
 * 那你就可能会捕捉不到子类抛出的异常
 * (那你说你手动把捕捉的异常改大不就好了吗？我是这么觉得的，但是呢我觉得还是要考虑到便捷的原因，一般自动生成的catch的异常都是根据你方法
 * 中throw了什么异常来catch的，所以的话手动改就不好啊，不是便捷的编译器能做出的事情，所以的话就干脆ban掉了)
 */
public class OverrideTest {

    public static void main(String[] args) {
        OverrideTest test = new OverrideTest();
            test.display(new SubClass());
    }

    public void display(SuperClass s){
        try {
            s.method();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
class SuperClass {

    public void method() throws IOException{

    }
}
class SubClass extends SuperClass{
    @Override
    public void method() throws IOException{

    }
}
```

```java
public class StudentTest {
    public static void main(String[] args) {
        Student s = new Student();
        try {
            s.register(1001);
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
        System.out.println(s);
    }
}

class Student{

    private int id;

    @Override
    public String toString() {
        return "Student{" +
                "id=" + id +
                '}';
    }

    public void register(int id) throws Exception {
        if(id > 0){
            this.id = id;
        }else {
//            System.out.println("您输入的数据非法");
            //手动抛出异常对象
            //说一下一件事情哈
            //运行时异常时可以不用处理的，所以当你抛出这个异常的时候并没有强制你去选择try catch，
            // 还是抛出去，编译时异常需要的话是因为你不解决的话我编译过不了啊，开始键都按不了
//            throw new RuntimeException("您输入的数据非法");
            throw new Exception("您输入的数据非法");
        }
    }
}
```

## JDK8之前日期时间API

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200910192322306.png" alt="image-20200910192322306" style="zoom:67%;" />

![image-20200910210749272](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200910210749272.png)

![image-20200910213811162](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200910213811162.png)

![image-20200910213830835](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200910213830835.png)

![image-20200910214112846](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200910214112846.png)

```java
/**
 * jdk8之前的日期时间的API测试
 * 1.System类中currentTimeMillis();
 * 2.java.util.Date和子类java.sql.Date
 * 3.SimpleDateFormat
 * 4.Calendar
 */
public class Test5 {
    /*
        SimpleDateFormat的使用:SimpleDateFormat对日期Date类的格式化和解析

        1.两个操作：
            1.格式化：日期 --- > 字符串
            2.解析：格式化的逆过程，字符串---> 日期


        2.SimpleDateFormat的实例化

     */

    @Test
    public void testSimpleDateFormat() throws ParseException {
        //实例化SimpleDateFormat:使用默认的构造器
        SimpleDateFormat sdf = new SimpleDateFormat();

        //格式化:日期 --> 字符串
        Date date = new Date();
        //Thu Sep 10 19:38:10 CST 2020
        System.out.println(date);
        String format = sdf.format(date);
        //2020/9/10 下午7:38
        System.out.println(format);

        //解析：格式化的逆过程，字符串 --> 日期
//        String str = "2019-08-09";
//        Date date1 = sdf.parse(str);
//        System.out.println(date1);

        //***********按照指定的方式格式化和解析:调用带参的构造器************
//        SimpleDateFormat sdf1 = new SimpleDateFormat("yyyyy.MMMMM.dd GGG hh:mm aaa");
        SimpleDateFormat sdf1 = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");
        //格式化
        String format1 = sdf1.format(date);
        //2020-09-10 07:58:52
        System.out.println(format1);
        //解析:要求字符串必须是符合SimpleDateFormat识别的格式(通过构造器参数体现),
        //否则，抛异常
        Date date2 = sdf1.parse("2020-09-10 07:58:53");
        System.out.println(date2);
    }

    /*
    练习一：字符串"2020-09-08"转换成java.sql.Date
    练习二："三天打渔两天晒网"  1990-01-01 xxxx-xx-xx 打渔还是晒网？

    举例：2020-09-08？ 总天数

    总天数 % 5 == 1,2,3:打渔
    总天数 % 5 == 4,0 : 晒网

    总天数的计算?
    方式一：(date2.getTime() - date1.getTime()) / (1000 * 60 * 60 *24) + 1
    方式二：1990-01-01 --> 2019-12-31  + 2020-01-01 -->2020-09-08
     */

    @Test
    public void testExer() throws ParseException {
        String birth = "2020-09-08";
        SimpleDateFormat sdf1 = new SimpleDateFormat("yyyy-MM-dd");
        Date date = sdf1.parse(birth);
        //System.out.println(date);

        java.sql.Date birthDate = new java.sql.Date(date.getTime());
        System.out.println(birthDate);
    }

    /*
    Calendar日历类(抽象类)的使用
     */
    @Test
    public void testCalendar(){
        //1.实例化
        //方式一：创建起子类(GregorianCalendar)的对象
        //方式二：调用其静态方法getInstance()
        Calendar calendar = Calendar.getInstance();

        //2.常用方法
        //get()
        int days = calendar.get(Calendar.DAY_OF_MONTH);
        System.out.println(days);
        System.out.println(calendar.get(Calendar.DAY_OF_YEAR));
        //set()
        calendar.set(Calendar.DAY_OF_MONTH,22);
        days = calendar.get(Calendar.DAY_OF_MONTH);
        System.out.println(days);
        //add()
        calendar.add(Calendar.DAY_OF_MONTH,3);
        days = calendar.get(Calendar.DAY_OF_MONTH);
        System.out.println(days);
        //getTime():日历类--> Date
        Date date = calendar.getTime();

        //setTime(): Date --> 日历类
        Date date1 = new Date();
        calendar.setTime(date1);
        days = calendar.get(Calendar.DAY_OF_MONTH);
        System.out.println(days);
    }
}
```

JDK8 之后的

```java
/**
 * jdk 8中日期时间API的测试
 */
public class JDK8DateTimeTest {

    @Test
    public void testDate(){
        //偏移量
        Date date1 = new Date(2020 ,9,8);
        //Fri Oct 08 00:00:00 CST 3920
        //Date中的年份是从1900开始，月份从0开始
        System.out.println(date1);
    }

    /*
    LocalDate LocalTime LocalDateTime 的使用
    说明：
        1.LocalDateTime相较于另外两个类，使用的频率较高
        2.类似于Calendar
     */
    @Test
    public void test1(){
        //now():获取当前的日期、时间、日期 + 时间
        LocalDate localDate = LocalDate.now();
        LocalTime localTime = LocalTime.now();
        LocalDateTime localDateTime = LocalDateTime.now();

        System.out.println(localDate);
        System.out.println(localTime);
        System.out.println(localDateTime);

        //of():设置指定的年、月、日、时、分、秒是没有偏移量的
        LocalDateTime localDateTime1 = LocalDateTime.of(2020, 10, 6, 13, 23, 44);
        System.out.println(localDateTime1);

        //getXxx()
        //获得相关的属性
        System.out.println(localDateTime.getDayOfMonth());
        System.out.println(localDateTime.getDayOfWeek());
        System.out.println(localDateTime.getDayOfYear());
        System.out.println(localDateTime.getMonth());

        //体现不可变性：意思就是不会改变你本身的日期，而是创建一个在你本身的日期上操作后的对象,Calendar那里是会修改的
        //withXxx:设置相关的属性
        LocalDate localDate1 = localDate.withDayOfMonth(22);
        System.out.println(localDate);
        System.out.println(localDate1);

        LocalDateTime localDateTime2 = localDateTime.withHour(4);
        System.out.println(localDateTime);
        System.out.println(localDateTime2);

        //
        LocalDateTime localDateTime3 = localDateTime.plusMonths(3);
        System.out.println(localDateTime3);

        LocalDateTime localDateTime4 = localDateTime.minusDays(6);
        System.out.println(localDateTime4);

    }

    /*
    Instant的使用
    类似于java.util.Date 的使用
    上面的类似Calendar，那会不会也有转换的关系
     */
    @Test
    public void test2(){
        //now():获取本初子午线对应的标准时间
        Instant instant = Instant.now();
        System.out.println(instant);//2020-09-10T14:19:01.189794700Z

        //添加时间的偏移量
        OffsetDateTime offsetDateTime = instant.atOffset(ZoneOffset.ofHours(8));
        System.out.println(offsetDateTime);

        //获取自1970年1月1日0时0分0秒(UTC)开始的毫秒数  Date类的getTime()
        long epochMilli = instant.toEpochMilli();
        System.out.println(epochMilli);

        //ofEpochMilli():通过给定的毫秒数，获取Instant实例 --->Date(long millis)
        Instant instant1 = Instant.ofEpochMilli(epochMilli);
        System.out.println(instant1);
    }


    /*
    DateTimeFormatter: 格式化或解析日期或时间
    类似SimpleDateFormat
     */
    @Test
    public void test3(){
        //方式一： 预定义的标准格式,如：ISO_LOCAL_DATE_TIME;ISO_LOCAL_DATE;ISO_LOCAL_TIME
        DateTimeFormatter formatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME;
        //格式化:日期 -- > 字符串
        //会出现异常，如果不按照要求的话
        //java.time.temporal.UnsupportedTemporalTypeException
//       LocalDate date  = LocalDate.now();
//        String format = formatter.format(date);
//        System.out.println(format+"******");
        LocalDateTime now = LocalDateTime.now();
        String str1 = formatter.format(now);
        System.out.println(str1);
        System.out.println(now);

        //解析：字符串 --> 日期
        //多态形式：是LocalXxx的接口
        TemporalAccessor parse = formatter.parse(str1);
        System.out.println(parse);


        //方式二：本地化相关的格式.如ofLocalizedDateTime(FormatStyle.LONG)
        //ofLocalizedDateTime()
        DateTimeFormatter formatter1 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.SHORT);
        //格式化
        String str2 = formatter1.format(now);
        //2020/9/11 上午9:35
        System.out.println(str2);

        //ofLocalizedDate()
        DateTimeFormatter formatter2 = DateTimeFormatter.ofLocalizedDate(FormatStyle.FULL);
        String str3 = formatter2.format(LocalDate.now());
        //2020年9月11日星期五
        System.out.println(str3);


        //重点：方式三：自定义的格式。如:ofPattern("yyyy-MM-dd hh:mm:dd")
        DateTimeFormatter formatter3 = DateTimeFormatter.ofPattern("yyyy-MM-dd hh:mm:ss");
        //格式化
        String str4 = formatter3.format(LocalDateTime.now());
        System.out.println(str4);


        //解析
        TemporalAccessor accessor = formatter3.parse(str4);
        System.out.println(accessor);  
    }
}
```

> 这个东西其实蛮复杂的，但实际上就是分为一个Date和一个转换器和一个Calendar差不多罢了
>
> 但是因为这些有些功能不是很好，所以8之后就升级了一下，所以也有所改变。
>
> 转换器变为`DateTimeFormatter`了，而且呢本来是`String`和`Date`之间的转换，但是现在不是了，是在Calendar升级之后的转换，然后`Instant`我也不知道会在哪里用了

## Comparable Comparator

```java
/**
 * 一、说明：Java对象，正常情况下，只能进行比较： == 或！=，不能使用 > 或 <的
 *      但是在开发场景中，我们需要对多个对象进行排序，言外之意，就需要比较对象大小，
 *      如何实现？使用两个接口中的任何一个：Comparable或Comparator
 *
 * 二、Comparable接口与Comparator的使用对比:
 * Comparable接口的方式一旦一定，保证Comparable接口实现类的对象在任何位置都可以比较大小
 * Comparator临时性的比较
 *
 */
public class CompareTest {

    /*
    Comparable 接口的使用实例：自然排序
    1.像String、包装类等实现了Comparable接口，重写了compareTo方法，给出了比较两个对象大小的方式
    2.像String、包装类重写compareTo()方法以后，进行了从小到大排列
    3.重写compareTo()的规则：
        如果当前对象this大于形参对象obj，则返回正整数
        如果当前对象this小于形参对象obj，则返回负整数
        如果当前对象this等于形参对象obj，则返回零
    4.对于自定义类，如果需要排序，我们可以让自定义类实现Comparable接口，重写compareTo()方法
    在compareTo(obj)方法中指明如何排序
     */
    @Test
    public void test1(){
        String[] arr = new String[]{"AA","CC","MM","GG"};
        Arrays.sort(arr);
        System.out.println(Arrays.toString(arr));
    }

    @Test
    public void test2(){
        Goods[] arr = new Goods[5];
        arr[0] = new Goods("lenovoMouse",34);
        arr[1] = new Goods("dellMouse",43);
        arr[2] = new Goods("xiaomiMouse",12);
        arr[3] = new Goods("huaweiMouse",65);
        arr[4] = new Goods("microsoMouse",43);

        Arrays.sort(arr);

        System.out.println(Arrays.toString(arr));

    }


    /**
     * Comparator接口的使用：定制排序
     * 1.背景:
     * 当元素的类型没有实现java.lang.Comparable接口而又不方便修改代码，
     * 或者实现了java.lang.Comparable接口的排序规则不适合当前的操作
     * 那么可以考虑使用Comparator的对象来排序
     * 2.重写compare(Object o1, Object o2)方法，比较o1和o2的大小
     * 如果方法返回正整数，则表示o1大于o2，如果返回0，表示相等，返回负整数，表示o1小于o2
     */
    @Test
    public void test3(){
        String[] arr = new String[]{"AA","CC","MM","GG"};

        Arrays.sort(arr, new Comparator() {
            //按照字符串从大到小的顺序排列
            @Override
            public int compare(Object o1, Object o2) {
                if(o1 instanceof String && o2 instanceof String){
                    String s1 = (String) o1;
                    String s2 = (String) o2;
                    return -s1.compareTo(s2);
                }
//                return 0;
                throw new RuntimeException("输入的数据类型不一致");
            }
        });
        System.out.println(Arrays.toString(arr));
    }

    @Test
    public void test4(){
        Goods[] arr = new Goods[6];
        arr[0] = new Goods("lenovoMouse",34);
        arr[1] = new Goods("dellMouse",43);
        arr[2] = new Goods("xiaomiMouse",12);
        arr[3] = new Goods("huaweiMouse",65);
        arr[4] = new Goods("microsoMouse",43);
        arr[5] = new Goods("huaweiMouse",23);

        Arrays.sort(arr,new Comparator(){
            //指明商品比较大小的方式：按照产品名称从低到高排序，再按照价格从高到低排序
            @Override
            public int compare(Object o1, Object o2) {

                if(o1 instanceof Goods && o2 instanceof Goods){
                    Goods g1 = (Goods) o1;
                    Goods g2 = (Goods) o2;
                    if(g1.getName().equals(g2.getName())){
                        return Double.compare(g2.getPrice(),g1.getPrice());
                    }else {
                        return g1.getName().compareTo(g2.getName());
                    }

                }
                throw new RuntimeException("传入参数类型不一致");
            }
        });
        System.out.println(Arrays.toString(arr));
    }
}

```



> 还是蛮有用的，这个就是看你东西是可以怎么排序的了

## BigInteger  BigDecimal

![image-20200911220731329](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200911220731329.png)

![image-20200911220938398](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200911220938398.png)

## 枚举类和注解

![image-20200912161623614](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200912161623614.png)

```java

/**
 * 一、枚举类的使用
 * 1.枚举类的理解：类的对象只有有限个，确定的，我们称此类为枚举类
 * 2.当需要定义一组常量时，强烈建议使用枚举类
 * 3.如果枚举类中只有一个对象，则可以作为单例模式的实现方式
 *
 * 二、如何定义枚举类
 * 方式一：jdk5.0 之前，自定义枚举类
 * 方式二：jdk5.0时，可以使用enum关键字定义枚举类
 *
 *
 * 三、Enum类中的常用方法：
 *  values方法:返回枚举类型的对象数组，该方法可以很方便地遍历所有的枚举值
 *  valueOf(String str):可以把一个字符串转为对应的枚举类对象，要求字符串必须是枚举类对象
 *  toString():返回当前枚举类对象常量的名称
 *
 * 四、使用enum关键字定义的枚举类实现接口的情况
 *      情况一：实现接口，在enum类中实现抽象方法
 *      情况二：
 */
public class SeasonTest {
    public static void main(String[] args) {
        Season spring = Season.SPRING;
        //toString() 方法
        System.out.println(spring.toString());


    }
}

//自定义枚举类
class Season{
    //1.声明Season对象的属性:private final修饰
    private final String seasonName;
    private final String seasonDesc;

    //2.私有化类的构造器,并给对象赋值
    private Season(String seasonName,String seasonDesc){
        this.seasonDesc = seasonDesc;
        this.seasonName = seasonName;

    }

    //3.提供当前枚举类的多个对象：public static final
    public static final Season SPRING = new Season("春天","春暖花开");
    public static final Season SUMMER = new Season("夏天","夏日炎炎");
    public static final Season AUTUMN = new Season("秋天","秋高气爽");
    public static final Season WINTER = new Season("冬天","冰天雪地");

    //4.其他述求：获取枚举类对象的属性

    public static final String str = "年后";
    public String getSeasonName() {
        return seasonName;
    }

    public String getSeasonDesc() {
        return seasonDesc;
    }

    @Override
    public String toString() {
        return "Season{" +
                "seasonName='" + seasonName + '\'' +
                ", seasonDesc='" + seasonDesc + '\'' +
                '}';
    }
}

```

```java
/**
 * 使用enum关键字定义枚举类
 * 说明：定义的枚举类默认继承于java.lang.Enum
 * 为什么这么说，因为我们见到的class的默认的父类就是Object，而直接打印对象打印出来的是一个地址值
 * 但是发现竟然不是，像是被重写的样子啊
 */
public class SeasonTest1 {
    public static void main(String[] args) {
        Season1 summer  = Season1.SUMMER;
        System.out.println(summer);
        System.out.println(Season1.class.getSuperclass());

        //toString() 方法
        System.out.println(summer.toString());
        System.out.println("**********");
        //values():
        Season1[] values = Season1.values();
        for (int i = 0; i <values.length ; i++) {

            System.out.println(values[i]);
            values[i].show();

        }

        //valueOf(String objName):返回枚举类中对象名是objName的对象
        //如果没有objName的枚举类对象，则抛异常，IllegalArgumentException
        Season1 winter = Season1.valueOf("WINTER");
        System.out.println(winter);
        winter.show();
    }
}
interface info{
    void show();
}
//自定义枚举类
enum  Season1 implements info{
    //1.提供当前枚举类的对象，多个对象之间用","隔开，末尾对象";"结束
     SPRING ("春天","春暖花开"){
        @Override
        public void show() {
            System.out.println("春天在哪里?");
        }
    },
     SUMMER ("夏天","夏日炎炎"){
         @Override
         public void show() {

             System.out.println("宁夏");
         }
     },
     AUTUMN ("秋天","秋高气爽"){
         @Override
         public void show() {
             System.out.println("秋天来了");
         }
     },
     WINTER ("冬天","冰天雪地"){
         @Override
         public void show() {
             System.out.println("大约在冬季");
         }
     };
    //1.声明Season对象的属性:private final修饰
    private final String seasonName;
    private final String seasonDesc;

    //2.私有化类的构造器,并给对象赋值
    private Season1(String seasonName,String seasonDesc){
        this.seasonDesc = seasonDesc;
        this.seasonName = seasonName;

    }


    //4.其他述求：获取枚举类对象的属性


    public String getSeasonName() {
        return seasonName;
    }

    public String getSeasonDesc() {
        return seasonDesc;
    }

//    @Override
//    public void show() {
//        System.out.println("这是一个季节");
//    }

//    @Override
//    public String toString() {
//        return "Season1{" +
//                "seasonName='" + seasonName + '\'' +
//                ", seasonDesc='" + seasonDesc + '\'' +
//                '}';
//    }
}


```

> 什么时候需要呢用到呢？就是一组状态的时候需要，emememm感觉我还是用的比较少吧

## 注解

<img src="C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200913090028210.png" alt="image-20200913090028210" style="zoom:67%;" />



![image-20200913091406271](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200913091406271.png)

![image-20200913093048158](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200913093048158.png)

```java
@Inherited
@Repeatable(MyAnnotations.class)
@Retention(RetentionPolicy.RUNTIME)
@Target({TYPE,FIELD,METHOD,TYPE_PARAMETER,TYPE_USE})
public @interface MyAnnotation {
    String value() default "hello";
}


```

上面这个是自定义的注解哈，目前有什么用呢，感觉没啥用，但是是让我们去懂注解的底层是怎么样定义的，这样的话以后才能看得懂，也说不定自己也能写一个出来吧

### 进行可重复注解需要到的

```java
/**
 * 注解的使用
 *
 * 1.理解注解
 *      1.jdk5.0新增的功能
 *      2.代码中的特殊标记，这些标记可以在编译，类加载，运行时被读取
 *      3.在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等
 *
 * 2.Annotation的使用实例
 * 示例一：生成文档相关的注释
 * 示例二：在编译时期进行格式的检查(JDK内置的三个基本注解)
 * @Override @Deprecated @SuppressWarnings
 *
 * 3.如何自定义注解:参照@SuppressWarnings
 *      1.注解声明为 @interface
 *      2.内部定义成员，通常使用value表示
 *      3.可以指定成员的默认值，使用default定义
 *      4.如果自定义注解没有成员，表明是一个标识作用
 *
 *      如果注解有成员，在使用注解时，需要指明成员的值。
 *      自定义注解必须配上注解的信息处理流程(使用反射)才有意义。
 *      自定义注解一般都会指明两个元注解：Retention，Target
 *
 * 4. jdk提供的四种元注解:
 *      元注解：对现有的注解进行解释说明的注解
 *      Retention:只能修饰于一个Annotation的定义，用于指定该Annotation的生命周期
 *              SOURCE/CLASS(默认行为)/RUNTIME 只有声明为RUNTIME生命周期的注解，才能通过反射获取
 *      Target：用于指定被修饰的Annotation能用于修饰哪些程序元素，比如TYPE,FIELD,METHOD,CONSTRUCTOR
 *      -----------出现频率比较低-------------------
 *      Documented：表示所修饰的注解在javadoc解析时，保留下来，比如@Deprecated
 *      inherited：被它修饰的Annotation 将具有继承性
 *
 * 5.通过反射获取注解信息
 *
 * 6.jdk8 中注解的新特性：可重复注解、类型注解
 *      1.可重复注解：①在MyAnnotation声明@Repeatable,成员值为MyAnnotations.class
 *                  ②MyAnnotation的Target和Retention和MyAnnotations的相同
 *      2.类型注解
 *      ElementType.TYPE_PARAMETER 表示该注解能够写在类型变量的声明语句中(如：泛型声明)，
 *      ElementType.TYPE_USE 表示该注解能写在使用类型的任何语句中
 */
public class AnnotationTest {

}
//jdk 8 之前的写法
//@MyAnnotations({@MyAnnotation(value = "hi"),@MyAnnotation(value = "hi")})
@MyAnnotation(value = "hi")
@MyAnnotation(value = "abc")
class Person{
    private String name;
    private  int age;

    public Person(){

    }

    public Person(String name,int age){
        this.age = age;
        this.name = name;
    }
}

class Generic<@MyAnnotation T>{

    public void show()throws @MyAnnotation RuntimeException{
        ArrayList<@MyAnnotation String> list = new ArrayList<>();
    }
}

```



```java
@Target({TYPE,FIELD,METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface MyAnnotations {
    MyAnnotation[] value();
}

```

> 说实话不知道是不是时间隔了太久了，就有点懵逼不知道在讲什么了，这里一般说的是两个注解不重复，但这时候我非要重复怎么办，可以放到一个数组里面去，并且要在`MyAnnotation`中使用`Repeatable`的元注解，而且`MyAnnotations`和`MyAnnotation`的元注解是得相同的，然后大概就是这样子





## 集合

![image-20200916085339157](C:\Users\zbr\AppData\Roaming\Typora\typora-user-images\image-20200916085339157.png)

```java
/**
 * 一、集合框架的概述
 *
 * 1.集合、数组都是对多个数据进行存储操作的结构，简称Java容器
 *      说明：此时的存储，主要指的是内存层面的存储，不涉及到持久化的存储(.txt,.jpg,.avi)
 *
 * 2.1数组在存储多个数据方面的特点：
 *      > 一旦初始化以后，长度确定了
 *      > 数组一旦定义好，其元素的类型也就确定了，也就只能操作指定类型的数据了。
 *      比如：String[] arr;int[] arr1;Object[] arr2;
 * 2.2数组在存储多个数据方面的缺点：
 *      > 一旦初始化以后，其长度就不可修改
 *      > 数组中提供的方法非常有限，对于添加、删除，插入数据等操作非常不便,同时效率不高
 *      > 获取数组中实际元素的个数的需求，数组没有现存的属性或方法可用(注意，arr.length 并不是实际长度，而是你整个数组的长度)
 *      > 数组存储数据的特点：有序、可重复，对于无序、不可重复的需求，不能满足
 *
 *  二、集合框架
 *      |-------Collection接口
 *          |------List接口:存储有序的，可重复的数据,"动态数组"
 *              |----ArrayList、LinkedList、Vector
 *          |------Set接口:存储无序的，不可重复的数据 --->高中讲的"集合",
 *              |----HashSet LinkedHashSet TreeSet
 *
 *      |-------Map接口：双列集合，用来存储一对(key,value)一对的数值  -->高中的函数: y = f(x)
 *              |----HashMap LinkedHashMap TreeMap HashTable Properties
 *
 *  三、Collection接口方法的使用
 */
public class CollectionTest {
    @Test
    public void test1(){

        Collection collection = new ArrayList();

        //add(Object e):将元素e添加到集合collection 中
        collection.add("AA");
        collection.add("BB");
        collection.add(123);//自动装箱
        collection.add(new Date());

        //size();
        System.out.println(collection.size());//4

        //addAll(Collection collection1):将collection1集合中的元素添加到当前的集合中
        Collection collection1 = new ArrayList();
        collection1.add(456);
        collection1.add("CC");
        collection.addAll(collection1);

        System.out.println(collection.size());//4


        //clear():清空集合元素
        collection.clear();

        //isEmpty():判断当前集合是否为空
        System.out.println(collection.isEmpty());
    }
}
```

```java
/**
 * Collection接口中声明的方法的测试
 *
 * 向Collection接口的实现类的对象中添加数据obj时，要求obj所在类要重写equals()
 */
public class CollectionTest1 {

    @Test
    public void test1(){
        Collection collection = new ArrayList();
        collection.add(123);
        collection.add(456);
        collection.add(new String("Tom"));
        collection.add(false);
        collection.add(new Person("Hel",20));


        //contains(Object obj)  :判断当前集合中是否包含obj
        //我们在判断时会调用obj对象所在类的equals
        boolean contains = collection.contains(123);
        System.out.println(contains);
        //true:意味着contains底层用的是equals而不是 ==
        System.out.println(collection.contains(new String("Tom")));
        //true
        System.out.println(collection.contains(new Person("Hel",20)));

        System.out.println("***************************");
        //2.containsAll(Collection coll);判断形参coll中的所有元素是否都存在于当前集合中
        Collection collection1 = Arrays.asList(123,456);
        System.out.println(collection.containsAll(collection1));
    }


    @Test
    public void test2(){
        //3.remove(Object obj):从当前集合中移除obj元素
        Collection collection = new ArrayList();
        collection.add(123);
        collection.add(456);
        collection.add(new String("Tom"));
        collection.add(false);
        collection.add(new Person("Hel",20));

        //需要使用到equals方法
         collection.remove(123);
        System.out.println(collection);

        collection.remove(new Person("Hel",20));
        System.out.println(collection);

        //4.removeAll(Collection coll1);从当前集合中移除coll1中所有的元素
        Collection collection1 = Arrays.asList(123,456);
        collection.removeAll(collection1);
        System.out.println(collection);
    }

    @Test
    public void test3(){
        Collection collection = new ArrayList();
        collection.add(123);
        collection.add(456);
        collection.add(new String("Tom"));
        collection.add(false);
        collection.add(new Person("Hel",20));

        //5.retainAll(Collection coll1):交集：获取当前集合和coll1集合的交集，并返回给当前集合
//        Collection collection1 = Arrays.asList(123,456,789);
//        collection.retainAll(collection1);
//        System.out.println(collection);

        //6.equals(Object obj):要想返回true，需要当前集合和形参的元素相同
        //因为这里是ArrayList，所以会依照顺序比较的，所以不按一致的顺序放的话也是会返回false的
        Collection collection1 = new ArrayList();
        collection1.add(123);
        collection1.add(456);
        collection1.add(new String("Tom"));
        collection1.add(false);
        collection1.add(new Person("Hel",20));

        System.out.println(collection.equals(collection1));
    }
}
```

> 这些方法的感受是的确是比Array直接来的方法多，可以删除，增加，交集，并集之类的操作，我感受到的是`xxAll`的参数基本上是都是`Colletion`,因为比较的是`All`嘛，没别的就没意思了

```java
/**
 * 集合元素的遍历操作，使用迭代器Iterator接口
 * 1.内部的方法：hasNext() 和next()
 *
 */
public class IteratorTest {

    @Test
    public void test1(){
        Collection collection = new ArrayList();
        collection.add(123);
        collection.add(456);
        collection.add(new String("Tom"));
        collection.add(false);
        collection.add(new Person("Hel",20));

        Iterator iterator = collection.iterator();
        //方式一
//        System.out.println(iterator.next());
//        System.out.println(iterator.next());
//        System.out.println(iterator.next());
//        System.out.println(iterator.next());
//        System.out.println(iterator.next());

        //报异常：NoSuchElementException
//        System.out.println(iterator.next());

        //方式二:不这样写
        for (int i = 0; i < collection.size(); i++) {
            System.out.println(iterator.next());
            
        }

        //方式三：推荐
        while (iterator.hasNext()){
            System.out.println(iterator.next());
        }
    }


    @Test
    public void test2(){
        Collection collection = new ArrayList();
        collection.add(123);
        collection.add(456);
        collection.add(new String("Tom"));
        collection.add(false);
        collection.add(new Person("Hel",20));


        //错误方式一：
//        Iterator iterator = collection.iterator();
//        while ((iterator.next()) != null){
//            System.out.println(iterator.next());
//        }

        //错误方式二：集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前
        while ((collection.iterator().hasNext())){
            System.out.println(collection.iterator().next());
        }

    }
}

```

```java
/**
 * jdk 5.0 新增了foreach循环，用来遍历集合和数组
 */
public class ForTest {

    @Test
    public void test1(){
        Collection collection = new ArrayList();
        collection.add(123);
        collection.add(456);
        collection.add(new String("Tom"));
        collection.add(false);
        collection.add(new Person("Hel",20));

        //for(集合元素的类型 局部变量 集合对象)
        //内部仍然调用迭代器
        for(Object obj: collection){
            System.out.println(obj);

        }

    }

    @Test
    public void test2(){
        int[] arr = new int[]{1,2,3,4,5,6};

        for(int i : arr){
            System.out.println(i);
        }
    }


    //练习题
    @Test
    public void test3(){

        String[] arr = new String[]{"MM","MM","MM"};

        //方式一：普通for赋值
        for(int i = 0;i< arr.length;i++){
            arr[i] = "GG";
        }
        //方式二：增强for循环
        //输出仍为MM,因为这种方法只是把每个元素都取出来然后赋值给新的变量，所以不会改变原来的
        for (String s: arr
             ) {

            s = "GG";
        }

        for (int i = 0; i < arr.length;i++){
            System.out.println(arr[i]);
        }

    }

}

```

```java
/**
 * |-----Collection接口：单列集合，用来存储一个一个的对象
 *      |-----List接口:存储有序的，可重复的数据。  -->"动态"数组，替换原有的数据
 *              |---ArrayList:作为List接口的主要实现类,线程不安全，效率高，底层使用Object[]存储
 *              |---LinkedList:对于频繁的插入、删除操作，使用此类效率比ArrayList高，底层使用双向链表存储
 *              |---Vector:作为List接口的古老实现类，线程安全的，效率低;底层使用Object[]数组
 *
 * 2.ArrayList的源码分析：
 *      1.jdk 7的情况下
 *      ArrayList list = new ArrayList();//底层创建了长度是10的Object[]数组elementData
 *      list.add(123);//elementDat[0] = new Integer(123);
 *      ...
 *      list.add(11);//如果此次的添加导致底层elementData数组容量不够，则扩容。
 *      默认情况下，扩容为原来的容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中
 *
 *      结论：建议开发中使用带参的构造器：ArrayList list = new ArrayList(int capacity);
 *
 *      2.jdk 8 中ArrayList的变化
 *          ArrayList list =  new ArrayList();//底层Object[] elementData初始化为{}.并没有创建长度为10的数组
 *
 *          list.add(123);//第一次调用add()时，底层才创建了长度为10的数组，并将数据123添加到elementData中
 *          ...
 *          后续的添加和扩容操作与jdk无异
 *      3.小结：
 *          jdk7中的ArrayList的对象的创建类似于单例的饿汉式，而jdk8中的ArrayList的对象
 *          的创建类类似于单例的懒汉式，延迟了数组的创建，节省内存
 *   3. LinkedList源码分析
 *      LinkedList list = new LinkedList();//内部声明了Node类型的first和last属性，默认值为null
 *      list.add(123);//将123封装到Node中，创建Node对象
 *      其中，Node类是双向链表
 *   4.Vector源码分析：jdk7和jdk8中通过Vector()构造器创建对象时，底层都创建了长度为10的数组
 *      在扩容方面，默认扩容为原来的数组长度的2倍
 * 面试题：ArrayList LinkedList Vector 三者的异同?
 * 同：三个类都实现了List接口，存储数据的特点相同;存储有效的、可重复的数据
 * 不同:见上
 */
public class ListTest {

}
 
```

